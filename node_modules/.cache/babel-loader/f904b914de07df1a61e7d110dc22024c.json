{"ast":null,"code":"import _regeneratorRuntime from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\nvar _s = $RefreshSig$();\n\nimport { i18n } from \"@lingui/core\";\nimport { WETH } from '@kyberswap/ks-sdk-core';\nimport { useMemo } from 'react';\nimport { nativeOnChain } from 'constants/tokens';\nimport { calculateGasMargin } from 'utils';\nimport { tryParseAmount } from '../state/swap/hooks';\nimport { useTransactionAdder } from '../state/transactions/hooks';\nimport { useCurrencyBalance } from '../state/wallet/hooks';\nimport { useActiveWeb3React } from './index';\nimport { useWETHContract } from './useContract';\nexport var WrapType;\n\n(function (WrapType) {\n  WrapType[WrapType[\"NOT_APPLICABLE\"] = 0] = \"NOT_APPLICABLE\";\n  WrapType[WrapType[\"WRAP\"] = 1] = \"WRAP\";\n  WrapType[WrapType[\"UNWRAP\"] = 2] = \"UNWRAP\";\n})(WrapType || (WrapType = {}));\n\nvar NOT_APPLICABLE = {\n  wrapType: WrapType.NOT_APPLICABLE\n};\n/**\n * Given the selected input and output currency, return a wrap callback\n * @param inputCurrency the selected input currency\n * @param outputCurrency the selected output currency\n * @param typedValue the user input value\n */\n\nexport default function useWrapCallback(inputCurrency, outputCurrency, typedValue) {\n  _s();\n\n  var _useActiveWeb3React = useActiveWeb3React(),\n      chainId = _useActiveWeb3React.chainId,\n      account = _useActiveWeb3React.account;\n\n  var wethContract = useWETHContract();\n  var balance = useCurrencyBalance(account !== null && account !== void 0 ? account : undefined, inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined); // we can always parse the amount typed as the input currency, since wrapping is 1:1\n\n  var inputAmount = useMemo(function () {\n    return tryParseAmount(typedValue, inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined);\n  }, [inputCurrency, typedValue]);\n  var addTransactionWithType = useTransactionAdder();\n  return useMemo(function () {\n    if (!wethContract || !chainId || !inputCurrency || !outputCurrency) return NOT_APPLICABLE;\n    var sufficientBalance = inputAmount && balance && !balance.lessThan(inputAmount);\n    var nativeTokenSymbol = nativeOnChain(chainId).symbol;\n\n    if (inputCurrency.isNative && WETH[chainId].equals(outputCurrency)) {\n      return {\n        wrapType: WrapType.WRAP,\n        execute: sufficientBalance && inputAmount ? /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n          var estimateGas, txReceipt;\n          return _regeneratorRuntime().wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.prev = 0;\n                  _context.next = 3;\n                  return wethContract.estimateGas.deposit({\n                    value: \"0x\".concat(inputAmount.quotient.toString(16))\n                  });\n\n                case 3:\n                  estimateGas = _context.sent;\n                  _context.next = 6;\n                  return wethContract.deposit({\n                    value: \"0x\".concat(inputAmount.quotient.toString(16)),\n                    gasLimit: calculateGasMargin(estimateGas)\n                  });\n\n                case 6:\n                  txReceipt = _context.sent;\n                  addTransactionWithType(txReceipt, {\n                    type: 'Wrap',\n                    summary: \"\".concat(inputAmount.toSignificant(6), \" \").concat(nativeTokenSymbol, \" to \").concat(inputAmount.toSignificant(6), \" W\").concat(nativeTokenSymbol)\n                  });\n                  _context.next = 13;\n                  break;\n\n                case 10:\n                  _context.prev = 10;\n                  _context.t0 = _context[\"catch\"](0);\n                  console.error('Could not deposit', _context.t0);\n\n                case 13:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, null, [[0, 10]]);\n        })) : undefined,\n        inputError: !typedValue ?\n        /*i18n*/\n        i18n._(\"Enter an amount\") : sufficientBalance ? undefined :\n        /*i18n*/\n        i18n._(\"Insufficient {0} balance\", {\n          0: nativeOnChain(chainId).symbol\n        })\n      };\n    } else if (WETH[chainId].equals(inputCurrency) && outputCurrency.isNative) {\n      return {\n        wrapType: WrapType.UNWRAP,\n        execute: sufficientBalance && inputAmount ? /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n          var estimateGas, txReceipt;\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.prev = 0;\n                  _context2.next = 3;\n                  return wethContract.estimateGas.withdraw(\"0x\".concat(inputAmount.quotient.toString(16)));\n\n                case 3:\n                  estimateGas = _context2.sent;\n                  _context2.next = 6;\n                  return wethContract.withdraw(\"0x\".concat(inputAmount.quotient.toString(16)), {\n                    gasLimit: calculateGasMargin(estimateGas)\n                  });\n\n                case 6:\n                  txReceipt = _context2.sent;\n                  addTransactionWithType(txReceipt, {\n                    type: 'Unwrap',\n                    summary: \"\".concat(inputAmount.toSignificant(6), \" W\").concat(nativeTokenSymbol, \" to \").concat(inputAmount.toSignificant(6), \" \").concat(nativeTokenSymbol)\n                  });\n                  _context2.next = 13;\n                  break;\n\n                case 10:\n                  _context2.prev = 10;\n                  _context2.t0 = _context2[\"catch\"](0);\n                  console.error('Could not withdraw', _context2.t0);\n\n                case 13:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, null, [[0, 10]]);\n        })) : undefined,\n        inputError: !typedValue ?\n        /*i18n*/\n        i18n._(\"Enter an amount\") : sufficientBalance ? undefined :\n        /*i18n*/\n        i18n._(\"Insufficient W{0} balance\", {\n          0: nativeOnChain(chainId).symbol\n        })\n      };\n    } else {\n      return NOT_APPLICABLE;\n    }\n  }, [wethContract, chainId, inputCurrency, outputCurrency, inputAmount, balance, addTransactionWithType, typedValue]);\n}\n\n_s(useWrapCallback, \"nz1GZq0jI4Cf+eokJXG5HAOfJp8=\", false, function () {\n  return [useActiveWeb3React, useWETHContract, useCurrencyBalance, useTransactionAdder];\n});","map":{"version":3,"names":["WETH","useMemo","nativeOnChain","calculateGasMargin","tryParseAmount","useTransactionAdder","useCurrencyBalance","useActiveWeb3React","useWETHContract","WrapType","NOT_APPLICABLE","wrapType","useWrapCallback","inputCurrency","outputCurrency","typedValue","chainId","account","wethContract","balance","undefined","inputAmount","addTransactionWithType","sufficientBalance","lessThan","nativeTokenSymbol","symbol","isNative","equals","WRAP","execute","estimateGas","deposit","value","quotient","toString","gasLimit","txReceipt","type","summary","toSignificant","console","error","inputError","UNWRAP","withdraw"],"sources":["/Applications/XAMPP/voxel-interface/src/hooks/useWrapCallback.ts"],"sourcesContent":["import { Currency, WETH } from '@kyberswap/ks-sdk-core'\nimport { t } from '@lingui/macro'\nimport { useMemo } from 'react'\n\nimport { nativeOnChain } from 'constants/tokens'\nimport { calculateGasMargin } from 'utils'\n\nimport { tryParseAmount } from '../state/swap/hooks'\nimport { useTransactionAdder } from '../state/transactions/hooks'\nimport { useCurrencyBalance } from '../state/wallet/hooks'\nimport { useActiveWeb3React } from './index'\nimport { useWETHContract } from './useContract'\n\nexport enum WrapType {\n  NOT_APPLICABLE,\n  WRAP,\n  UNWRAP,\n}\n\nconst NOT_APPLICABLE = { wrapType: WrapType.NOT_APPLICABLE }\n/**\n * Given the selected input and output currency, return a wrap callback\n * @param inputCurrency the selected input currency\n * @param outputCurrency the selected output currency\n * @param typedValue the user input value\n */\nexport default function useWrapCallback(\n  inputCurrency: Currency | undefined | null,\n  outputCurrency: Currency | undefined | null,\n  typedValue: string | undefined,\n): { wrapType: WrapType; execute?: undefined | (() => Promise<void>); inputError?: string } {\n  const { chainId, account } = useActiveWeb3React()\n  const wethContract = useWETHContract()\n  const balance = useCurrencyBalance(account ?? undefined, inputCurrency ?? undefined)\n  // we can always parse the amount typed as the input currency, since wrapping is 1:1\n  const inputAmount = useMemo(() => tryParseAmount(typedValue, inputCurrency ?? undefined), [inputCurrency, typedValue])\n  const addTransactionWithType = useTransactionAdder()\n\n  return useMemo(() => {\n    if (!wethContract || !chainId || !inputCurrency || !outputCurrency) return NOT_APPLICABLE\n\n    const sufficientBalance = inputAmount && balance && !balance.lessThan(inputAmount)\n\n    const nativeTokenSymbol = nativeOnChain(chainId).symbol\n\n    if (inputCurrency.isNative && WETH[chainId].equals(outputCurrency)) {\n      return {\n        wrapType: WrapType.WRAP,\n        execute:\n          sufficientBalance && inputAmount\n            ? async () => {\n                try {\n                  const estimateGas = await wethContract.estimateGas.deposit({\n                    value: `0x${inputAmount.quotient.toString(16)}`,\n                  })\n                  const txReceipt = await wethContract.deposit({\n                    value: `0x${inputAmount.quotient.toString(16)}`,\n                    gasLimit: calculateGasMargin(estimateGas),\n                  })\n                  addTransactionWithType(txReceipt, {\n                    type: 'Wrap',\n                    summary: `${inputAmount.toSignificant(6)} ${nativeTokenSymbol} to ${inputAmount.toSignificant(\n                      6,\n                    )} W${nativeTokenSymbol}`,\n                  })\n                } catch (error) {\n                  console.error('Could not deposit', error)\n                }\n              }\n            : undefined,\n        inputError: !typedValue\n          ? t`Enter an amount`\n          : sufficientBalance\n          ? undefined\n          : t`Insufficient ${nativeOnChain(chainId).symbol} balance`,\n      }\n    } else if (WETH[chainId].equals(inputCurrency) && outputCurrency.isNative) {\n      return {\n        wrapType: WrapType.UNWRAP,\n        execute:\n          sufficientBalance && inputAmount\n            ? async () => {\n                try {\n                  const estimateGas = await wethContract.estimateGas.withdraw(`0x${inputAmount.quotient.toString(16)}`)\n                  const txReceipt = await wethContract.withdraw(`0x${inputAmount.quotient.toString(16)}`, {\n                    gasLimit: calculateGasMargin(estimateGas),\n                  })\n                  addTransactionWithType(txReceipt, {\n                    type: 'Unwrap',\n                    summary: `${inputAmount.toSignificant(6)} W${nativeTokenSymbol} to ${inputAmount.toSignificant(\n                      6,\n                    )} ${nativeTokenSymbol}`,\n                  })\n                } catch (error) {\n                  console.error('Could not withdraw', error)\n                }\n              }\n            : undefined,\n        inputError: !typedValue\n          ? t`Enter an amount`\n          : sufficientBalance\n          ? undefined\n          : t`Insufficient W${nativeOnChain(chainId).symbol} balance`,\n      }\n    } else {\n      return NOT_APPLICABLE\n    }\n  }, [wethContract, chainId, inputCurrency, outputCurrency, inputAmount, balance, addTransactionWithType, typedValue])\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}