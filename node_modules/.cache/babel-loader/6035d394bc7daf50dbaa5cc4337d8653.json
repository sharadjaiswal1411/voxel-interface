{"ast":null,"code":"\"use strict\"; // Copyright (c) 2018-2022 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\n\nvar _slicedToArray = require(\"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _classCallCheck = require(\"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletSDKRelay = void 0;\n\nvar bind_decorator_1 = __importDefault(require(\"bind-decorator\"));\n\nvar eth_rpc_errors_1 = require(\"eth-rpc-errors\");\n\nvar rxjs_1 = require(\"rxjs\");\n\nvar operators_1 = require(\"rxjs/operators\");\n\nvar DiagnosticLogger_1 = require(\"../connection/DiagnosticLogger\");\n\nvar WalletSDKConnection_1 = require(\"../connection/WalletSDKConnection\");\n\nvar WalletUIError_1 = require(\"../provider/WalletUIError\");\n\nvar types_1 = require(\"../types\");\n\nvar util_1 = require(\"../util\");\n\nvar aes256gcm = __importStar(require(\"./aes256gcm\"));\n\nvar Session_1 = require(\"./Session\");\n\nvar WalletSDKRelayAbstract_1 = require(\"./WalletSDKRelayAbstract\");\n\nvar Web3Method_1 = require(\"./Web3Method\");\n\nvar Web3RequestCanceledMessage_1 = require(\"./Web3RequestCanceledMessage\");\n\nvar Web3RequestMessage_1 = require(\"./Web3RequestMessage\");\n\nvar Web3Response_1 = require(\"./Web3Response\");\n\nvar Web3ResponseMessage_1 = require(\"./Web3ResponseMessage\");\n\nvar WalletSDKRelay = /*#__PURE__*/function (_WalletSDKRelayAbstra) {\n  _inherits(WalletSDKRelay, _WalletSDKRelayAbstra);\n\n  var _super = _createSuper(WalletSDKRelay);\n\n  function WalletSDKRelay(options) {\n    var _this;\n\n    _classCallCheck(this, WalletSDKRelay);\n\n    var _a;\n\n    _this = _super.call(this);\n    _this.accountsCallback = null;\n    _this.chainCallback = null;\n    _this.appName = \"\";\n    _this.appLogoUrl = null;\n    _this.subscriptions = new rxjs_1.Subscription();\n    _this.linkAPIUrl = options.linkAPIUrl;\n    _this.storage = options.storage;\n    _this.options = options;\n\n    var _this$subscribe = _this.subscribe(),\n        session = _this$subscribe.session,\n        ui = _this$subscribe.ui,\n        connection = _this$subscribe.connection;\n\n    _this._session = session;\n    _this.connection = connection;\n    _this.relayEventManager = options.relayEventManager;\n\n    if (options.diagnosticLogger && options.eventListener) {\n      throw new Error(\"Can't have both eventListener and diagnosticLogger options, use only diagnosticLogger\");\n    }\n\n    if (options.eventListener) {\n      _this.diagnostic = {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        log: options.eventListener.onEvent\n      };\n    } else {\n      _this.diagnostic = options.diagnosticLogger;\n    }\n\n    _this._reloadOnDisconnect = (_a = options.reloadOnDisconnect) !== null && _a !== void 0 ? _a : true;\n    _this.ui = ui;\n    return _this;\n  }\n\n  _createClass(WalletSDKRelay, [{\n    key: \"subscribe\",\n    value: function subscribe() {\n      var _this2 = this;\n\n      var session = Session_1.Session.load(this.storage) || new Session_1.Session(this.storage).save();\n      var connection = new WalletSDKConnection_1.WalletSDKConnection(session.id, session.key, this.linkAPIUrl, this.diagnostic);\n      this.subscriptions.add(connection.sessionConfig$.subscribe({\n        next: function next(sessionConfig) {\n          _this2.onSessionConfigChanged(sessionConfig);\n        },\n        error: function error() {\n          var _a;\n\n          (_a = _this2.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {\n            message: \"error while invoking session config callback\"\n          });\n        }\n      }));\n      this.subscriptions.add(connection.incomingEvent$.pipe((0, operators_1.filter)(function (m) {\n        return m.event === \"Web3Response\";\n      })).subscribe({\n        next: this.handleIncomingEvent\n      }));\n      this.subscriptions.add(connection.linked$.pipe((0, operators_1.skip)(1), (0, operators_1.tap)(function (linked) {\n        var _a;\n\n        _this2.isLinked = linked;\n\n        var cachedAddresses = _this2.storage.getItem(WalletSDKRelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY);\n\n        if (linked) {\n          // Only set linked session variable one way\n          _this2.session.linked = linked;\n        }\n\n        _this2.isUnlinkedErrorState = false;\n\n        if (cachedAddresses) {\n          var addresses = cachedAddresses.split(\" \");\n          var wasConnectedViaStandalone = _this2.storage.getItem(\"IsStandaloneSigning\") === \"true\";\n\n          if (addresses[0] !== \"\" && !linked && _this2.session.linked && !wasConnectedViaStandalone) {\n            _this2.isUnlinkedErrorState = true;\n\n            var sessionIdHash = _this2.getSessionIdHash();\n\n            (_a = _this2.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.UNLINKED_ERROR_STATE, {\n              sessionIdHash: sessionIdHash\n            });\n          }\n        }\n      })).subscribe()); // if session is marked destroyed, reset and reload\n\n      this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)(function (c) {\n        return !!c.metadata && c.metadata.__destroyed === \"1\";\n      })).subscribe(function () {\n        var _a;\n\n        var alreadyDestroyed = connection.isDestroyed;\n        (_a = _this2.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.METADATA_DESTROYED, {\n          alreadyDestroyed: alreadyDestroyed,\n          sessionIdHash: _this2.getSessionIdHash()\n        });\n        return _this2.resetAndReload();\n      }));\n      this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)(function (c) {\n        return c.metadata && c.metadata.WalletUsername !== undefined;\n      })).pipe((0, operators_1.mergeMap)(function (c) {\n        return aes256gcm.decrypt(c.metadata.WalletUsername, session.secret);\n      })).subscribe({\n        next: function next(walletUsername) {\n          _this2.storage.setItem(WalletSDKRelayAbstract_1.WALLET_USER_NAME_KEY, walletUsername);\n        },\n        error: function error() {\n          var _a;\n\n          (_a = _this2.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {\n            message: \"Had error decrypting\",\n            value: \"username\"\n          });\n        }\n      }));\n      this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)(function (c) {\n        return c.metadata && c.metadata.AppVersion !== undefined;\n      })).pipe((0, operators_1.mergeMap)(function (c) {\n        return aes256gcm.decrypt(c.metadata.AppVersion, session.secret);\n      })).subscribe({\n        next: function next(appVersion) {\n          _this2.storage.setItem(WalletSDKRelayAbstract_1.APP_VERSION_KEY, appVersion);\n        },\n        error: function error() {\n          var _a;\n\n          (_a = _this2.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {\n            message: \"Had error decrypting\",\n            value: \"appversion\"\n          });\n        }\n      }));\n      this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)(function (c) {\n        return c.metadata && c.metadata.ChainId !== undefined && c.metadata.JsonRpcUrl !== undefined;\n      })).pipe((0, operators_1.mergeMap)(function (c) {\n        return (0, rxjs_1.zip)(aes256gcm.decrypt(c.metadata.ChainId, session.secret), aes256gcm.decrypt(c.metadata.JsonRpcUrl, session.secret));\n      })).pipe((0, operators_1.distinctUntilChanged)()).subscribe({\n        next: function next(_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              chainId = _ref2[0],\n              jsonRpcUrl = _ref2[1];\n\n          if (_this2.chainCallback) {\n            _this2.chainCallback(chainId, jsonRpcUrl);\n          }\n        },\n        error: function error() {\n          var _a;\n\n          (_a = _this2.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {\n            message: \"Had error decrypting\",\n            value: \"chainId|jsonRpcUrl\"\n          });\n        }\n      }));\n      this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)(function (c) {\n        return c.metadata && c.metadata.EthereumAddress !== undefined;\n      })).pipe((0, operators_1.mergeMap)(function (c) {\n        return aes256gcm.decrypt(c.metadata.EthereumAddress, session.secret);\n      })).subscribe({\n        next: function next(selectedAddress) {\n          if (_this2.accountsCallback) {\n            _this2.accountsCallback([selectedAddress]);\n          }\n\n          if (WalletSDKRelay.accountRequestCallbackIds.size > 0) {\n            // We get the ethereum address from the metadata.  If for whatever\n            // reason we don't get a response via an explicit web3 message\n            // we can still fulfill the eip1102 request.\n            Array.from(WalletSDKRelay.accountRequestCallbackIds.values()).forEach(function (id) {\n              var message = (0, Web3ResponseMessage_1.Web3ResponseMessage)({\n                id: id,\n                response: (0, Web3Response_1.RequestEthereumAccountsResponse)([selectedAddress])\n              });\n\n              _this2.invokeCallback(Object.assign(Object.assign({}, message), {\n                id: id\n              }));\n            });\n            WalletSDKRelay.accountRequestCallbackIds.clear();\n          }\n        },\n        error: function error() {\n          var _a;\n\n          (_a = _this2.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {\n            message: \"Had error decrypting\",\n            value: \"selectedAddress\"\n          });\n        }\n      }));\n      var ui = this.options.uiConstructor({\n        linkAPIUrl: this.options.linkAPIUrl,\n        version: this.options.version,\n        darkMode: this.options.darkMode,\n        session: session,\n        connected$: connection.connected$\n      });\n      connection.connect();\n      return {\n        session: session,\n        ui: ui,\n        connection: connection\n      };\n    }\n  }, {\n    key: \"attachUI\",\n    value: function attachUI() {\n      this.ui.attach();\n    }\n  }, {\n    key: \"resetAndReload\",\n    value: function resetAndReload() {\n      var _this3 = this;\n\n      this.connection.setSessionMetadata(\"__destroyed\", \"1\").pipe((0, operators_1.timeout)(1000), (0, operators_1.catchError)(function (_) {\n        return (0, rxjs_1.of)(null);\n      })).subscribe(function (_) {\n        var _a, _b, _c;\n\n        var isStandalone = _this3.ui.isStandalone();\n\n        try {\n          _this3.subscriptions.unsubscribe();\n        } catch (err) {\n          (_a = _this3.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {\n            message: \"Had error unsubscribing\"\n          });\n        }\n\n        (_b = _this3.diagnostic) === null || _b === void 0 ? void 0 : _b.log(DiagnosticLogger_1.EVENTS.SESSION_STATE_CHANGE, {\n          method: \"relay::resetAndReload\",\n          sessionMetadataChange: \"__destroyed, 1\",\n          sessionIdHash: _this3.getSessionIdHash()\n        });\n\n        _this3.connection.destroy();\n        /**\n         * Only clear storage if the session id we have in memory matches the one on disk\n         * Otherwise, in the case where we have 2 tabs, another tab might have cleared\n         * storage already.  In that case if we clear storage again, the user will be in\n         * a state where the first tab allows the user to connect but the session that\n         * was used isn't persisted.  This leaves the user in a state where they aren't\n         * connected to the mobile app.\n         */\n\n\n        var storedSession = Session_1.Session.load(_this3.storage);\n\n        if ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) === _this3._session.id) {\n          _this3.storage.clear();\n        } else if (storedSession) {\n          (_c = _this3.diagnostic) === null || _c === void 0 ? void 0 : _c.log(DiagnosticLogger_1.EVENTS.SKIPPED_CLEARING_SESSION, {\n            sessionIdHash: _this3.getSessionIdHash(),\n            storedSessionIdHash: Session_1.Session.hash(storedSession.id)\n          });\n        }\n\n        if (_this3._reloadOnDisconnect) {\n          _this3.ui.reloadUI();\n\n          return;\n        }\n\n        if (_this3.accountsCallback) {\n          _this3.accountsCallback([], true);\n        }\n\n        var _this3$subscribe = _this3.subscribe(),\n            session = _this3$subscribe.session,\n            ui = _this3$subscribe.ui,\n            connection = _this3$subscribe.connection;\n\n        _this3._session = session;\n        _this3.connection = connection;\n        _this3.ui = ui;\n        if (isStandalone && _this3.ui.setStandalone) _this3.ui.setStandalone(true);\n\n        _this3.attachUI();\n      }, function (err) {\n        var _a;\n\n        (_a = _this3.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.FAILURE, {\n          method: \"relay::resetAndReload\",\n          message: \"failed to reset and reload with \".concat(err),\n          sessionIdHash: _this3.getSessionIdHash()\n        });\n      });\n    }\n  }, {\n    key: \"setAppInfo\",\n    value: function setAppInfo(appName, appLogoUrl) {\n      this.appName = appName;\n      this.appLogoUrl = appLogoUrl;\n    }\n  }, {\n    key: \"getStorageItem\",\n    value: function getStorageItem(key) {\n      return this.storage.getItem(key);\n    }\n  }, {\n    key: \"session\",\n    get: function get() {\n      return this._session;\n    }\n  }, {\n    key: \"setStorageItem\",\n    value: function setStorageItem(key, value) {\n      this.storage.setItem(key, value);\n    }\n  }, {\n    key: \"signEthereumMessage\",\n    value: function signEthereumMessage(message, address, addPrefix, typedDataJson) {\n      return this.sendRequest({\n        method: Web3Method_1.Web3Method.signEthereumMessage,\n        params: {\n          message: (0, util_1.hexStringFromBuffer)(message, true),\n          address: address,\n          addPrefix: addPrefix,\n          typedDataJson: typedDataJson || null\n        }\n      });\n    }\n  }, {\n    key: \"ethereumAddressFromSignedMessage\",\n    value: function ethereumAddressFromSignedMessage(message, signature, addPrefix) {\n      return this.sendRequest({\n        method: Web3Method_1.Web3Method.ethereumAddressFromSignedMessage,\n        params: {\n          message: (0, util_1.hexStringFromBuffer)(message, true),\n          signature: (0, util_1.hexStringFromBuffer)(signature, true),\n          addPrefix: addPrefix\n        }\n      });\n    }\n  }, {\n    key: \"signEthereumTransaction\",\n    value: function signEthereumTransaction(params) {\n      return this.sendRequest({\n        method: Web3Method_1.Web3Method.signEthereumTransaction,\n        params: {\n          fromAddress: params.fromAddress,\n          toAddress: params.toAddress,\n          weiValue: (0, util_1.bigIntStringFromBN)(params.weiValue),\n          data: (0, util_1.hexStringFromBuffer)(params.data, true),\n          nonce: params.nonce,\n          gasPriceInWei: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,\n          maxFeePerGas: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,\n          maxPriorityFeePerGas: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,\n          gasLimit: params.gasLimit ? (0, util_1.bigIntStringFromBN)(params.gasLimit) : null,\n          chainId: params.chainId,\n          shouldSubmit: false\n        }\n      });\n    }\n  }, {\n    key: \"signAndSubmitEthereumTransaction\",\n    value: function signAndSubmitEthereumTransaction(params) {\n      return this.sendRequest({\n        method: Web3Method_1.Web3Method.signEthereumTransaction,\n        params: {\n          fromAddress: params.fromAddress,\n          toAddress: params.toAddress,\n          weiValue: (0, util_1.bigIntStringFromBN)(params.weiValue),\n          data: (0, util_1.hexStringFromBuffer)(params.data, true),\n          nonce: params.nonce,\n          gasPriceInWei: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,\n          maxFeePerGas: params.maxFeePerGas ? (0, util_1.bigIntStringFromBN)(params.maxFeePerGas) : null,\n          maxPriorityFeePerGas: params.maxPriorityFeePerGas ? (0, util_1.bigIntStringFromBN)(params.maxPriorityFeePerGas) : null,\n          gasLimit: params.gasLimit ? (0, util_1.bigIntStringFromBN)(params.gasLimit) : null,\n          chainId: params.chainId,\n          shouldSubmit: true\n        }\n      });\n    }\n  }, {\n    key: \"submitEthereumTransaction\",\n    value: function submitEthereumTransaction(signedTransaction, chainId) {\n      return this.sendRequest({\n        method: Web3Method_1.Web3Method.submitEthereumTransaction,\n        params: {\n          signedTransaction: (0, util_1.hexStringFromBuffer)(signedTransaction, true),\n          chainId: chainId\n        }\n      });\n    }\n  }, {\n    key: \"scanQRCode\",\n    value: function scanQRCode(regExp) {\n      return this.sendRequest({\n        method: Web3Method_1.Web3Method.scanQRCode,\n        params: {\n          regExp: regExp\n        }\n      });\n    }\n  }, {\n    key: \"getQRCodeUrl\",\n    value: function getQRCodeUrl() {\n      return (0, util_1.createQrUrl)(this._session.id, this._session.secret, this.linkAPIUrl, false);\n    }\n  }, {\n    key: \"genericRequest\",\n    value: function genericRequest(data, action) {\n      return this.sendRequest({\n        method: Web3Method_1.Web3Method.generic,\n        params: {\n          action: action,\n          data: data\n        }\n      });\n    }\n  }, {\n    key: \"sendGenericMessage\",\n    value: function sendGenericMessage(request) {\n      return this.sendRequest(request);\n    }\n  }, {\n    key: \"sendRequest\",\n    value: function sendRequest(request) {\n      var _this4 = this;\n\n      var hideSnackbarItem = null;\n      var id = (0, util_1.randomBytesHex)(8);\n\n      var cancel = function cancel(error) {\n        _this4.publishWeb3RequestCanceledEvent(id);\n\n        _this4.handleErrorResponse(id, request.method, error);\n\n        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n      };\n\n      var promise = new Promise(function (resolve, reject) {\n        if (!_this4.ui.isStandalone()) {\n          hideSnackbarItem = _this4.ui.showConnecting({\n            isUnlinkedErrorState: _this4.isUnlinkedErrorState,\n            onCancel: cancel,\n            onResetConnection: _this4.resetAndReload // eslint-disable-line @typescript-eslint/unbound-method\n\n          });\n        }\n\n        _this4.relayEventManager.callbacks.set(id, function (response) {\n          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n\n          if (response.errorMessage) {\n            return reject(new Error(response.errorMessage));\n          }\n\n          resolve(response);\n        });\n\n        if (_this4.ui.isStandalone()) {\n          _this4.sendRequestStandalone(id, request);\n        } else {\n          _this4.publishWeb3RequestEvent(id, request);\n        }\n      });\n      return {\n        promise: promise,\n        cancel: cancel\n      };\n    }\n  }, {\n    key: \"setConnectDisabled\",\n    value: function setConnectDisabled(disabled) {\n      this.ui.setConnectDisabled(disabled);\n    }\n  }, {\n    key: \"setAccountsCallback\",\n    value: function setAccountsCallback(accountsCallback) {\n      this.accountsCallback = accountsCallback;\n    }\n  }, {\n    key: \"setChainCallback\",\n    value: function setChainCallback(chainCallback) {\n      this.chainCallback = chainCallback;\n    }\n  }, {\n    key: \"publishWeb3RequestEvent\",\n    value: function publishWeb3RequestEvent(id, request) {\n      var _this5 = this;\n\n      var _a;\n\n      var message = (0, Web3RequestMessage_1.Web3RequestMessage)({\n        id: id,\n        request: request\n      });\n      var storedSession = Session_1.Session.load(this.storage);\n      (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.WEB3_REQUEST, {\n        eventId: message.id,\n        method: \"relay::\".concat(message.request.method),\n        sessionIdHash: this.getSessionIdHash(),\n        storedSessionIdHash: storedSession ? Session_1.Session.hash(storedSession.id) : \"\",\n        isSessionMismatched: ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) !== this._session.id).toString()\n      });\n      this.subscriptions.add(this.publishEvent(\"Web3Request\", message, true).subscribe({\n        next: function next(_) {\n          var _a;\n\n          (_a = _this5.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.WEB3_REQUEST_PUBLISHED, {\n            eventId: message.id,\n            method: \"relay::\".concat(message.request.method),\n            sessionIdHash: _this5.getSessionIdHash(),\n            storedSessionIdHash: storedSession ? Session_1.Session.hash(storedSession.id) : \"\",\n            isSessionMismatched: ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) !== _this5._session.id).toString()\n          });\n        },\n        error: function error(err) {\n          _this5.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n            id: message.id,\n            response: {\n              method: message.request.method,\n              errorMessage: err.message\n            }\n          }));\n        }\n      }));\n    }\n  }, {\n    key: \"publishWeb3RequestCanceledEvent\",\n    value: function publishWeb3RequestCanceledEvent(id) {\n      var message = (0, Web3RequestCanceledMessage_1.Web3RequestCanceledMessage)(id);\n      this.subscriptions.add(this.publishEvent(\"Web3RequestCanceled\", message, false).subscribe());\n    }\n  }, {\n    key: \"publishEvent\",\n    value: function publishEvent(event, message, callWebhook) {\n      var _this6 = this;\n\n      var secret = this.session.secret;\n      return new rxjs_1.Observable(function (subscriber) {\n        void aes256gcm.encrypt(JSON.stringify(Object.assign(Object.assign({}, message), {\n          origin: location.origin\n        })), secret).then(function (encrypted) {\n          subscriber.next(encrypted);\n          subscriber.complete();\n        });\n      }).pipe((0, operators_1.mergeMap)(function (encrypted) {\n        return _this6.connection.publishEvent(event, encrypted, callWebhook);\n      }));\n    }\n  }, {\n    key: \"handleIncomingEvent\",\n    value: function handleIncomingEvent(event) {\n      var _this7 = this;\n\n      try {\n        this.subscriptions.add(aes256gcm.decrypt(event.data, this.session.secret).pipe((0, operators_1.map)(function (c) {\n          return JSON.parse(c);\n        })).subscribe({\n          next: function next(json) {\n            var message = (0, Web3ResponseMessage_1.isWeb3ResponseMessage)(json) ? json : null;\n\n            if (!message) {\n              return;\n            }\n\n            _this7.handleWeb3ResponseMessage(message);\n          },\n          error: function error() {\n            var _a;\n\n            (_a = _this7.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {\n              message: \"Had error decrypting\",\n              value: \"incomingEvent\"\n            });\n          }\n        }));\n      } catch (_a) {\n        return;\n      }\n    }\n  }, {\n    key: \"handleWeb3ResponseMessage\",\n    value: function handleWeb3ResponseMessage(message) {\n      var _this8 = this;\n\n      var _a;\n\n      var response = message.response;\n      (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.WEB3_RESPONSE, {\n        eventId: message.id,\n        method: \"relay::\".concat(response.method),\n        sessionIdHash: this.getSessionIdHash()\n      });\n\n      if ((0, Web3Response_1.isRequestEthereumAccountsResponse)(response)) {\n        WalletSDKRelay.accountRequestCallbackIds.forEach(function (id) {\n          return _this8.invokeCallback(Object.assign(Object.assign({}, message), {\n            id: id\n          }));\n        });\n        WalletSDKRelay.accountRequestCallbackIds.clear();\n        return;\n      }\n\n      this.invokeCallback(message);\n    }\n  }, {\n    key: \"handleErrorResponse\",\n    value: function handleErrorResponse(id, method, error, errorCode) {\n      this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n        id: id,\n        response: (0, Web3Response_1.ErrorResponse)(method, (error !== null && error !== void 0 ? error : WalletUIError_1.WalletUIError.UserRejectedRequest).message, errorCode)\n      }));\n    }\n  }, {\n    key: \"invokeCallback\",\n    value: function invokeCallback(message) {\n      var callback = this.relayEventManager.callbacks.get(message.id);\n\n      if (callback) {\n        callback(message.response);\n        this.relayEventManager.callbacks.delete(message.id);\n      }\n    }\n  }, {\n    key: \"requestEthereumAccounts\",\n    value: function requestEthereumAccounts() {\n      var _this9 = this;\n\n      var request = {\n        method: Web3Method_1.Web3Method.requestEthereumAccounts,\n        params: {\n          appName: this.appName,\n          appLogoUrl: this.appLogoUrl || null\n        }\n      };\n      var hideSnackbarItem = null;\n      var id = (0, util_1.randomBytesHex)(8);\n\n      var cancel = function cancel(error) {\n        _this9.publishWeb3RequestCanceledEvent(id);\n\n        _this9.handleErrorResponse(id, request.method, error); // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n\n\n        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n      };\n\n      var promise = new Promise(function (resolve, reject) {\n        var _a;\n\n        _this9.relayEventManager.callbacks.set(id, function (response) {\n          _this9.ui.hideRequestEthereumAccounts(); // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n\n\n          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n\n          if (response.errorMessage) {\n            return reject(new Error(response.errorMessage));\n          }\n\n          resolve(response);\n        });\n\n        var userAgent = ((_a = window === null || window === void 0 ? void 0 : window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) || null;\n\n        if (userAgent && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)) {\n          window.location.href = \"https://go.cb-w.com/xoXnYwQimhb?cb_url=\".concat(encodeURIComponent(window.location.href));\n          return;\n        }\n\n        if (_this9.ui.inlineAccountsResponse()) {\n          var onAccounts = function onAccounts(accounts) {\n            _this9.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n              id: id,\n              response: (0, Web3Response_1.RequestEthereumAccountsResponse)(accounts)\n            }));\n          };\n\n          _this9.ui.requestEthereumAccounts({\n            onCancel: cancel,\n            onAccounts: onAccounts\n          });\n        } else {\n          // Error if user closes TryExtensionLinkDialog without connecting\n          var err = eth_rpc_errors_1.ethErrors.provider.userRejectedRequest(\"User denied account authorization\");\n\n          _this9.ui.requestEthereumAccounts({\n            onCancel: function onCancel() {\n              return cancel(err);\n            }\n          });\n        }\n\n        WalletSDKRelay.accountRequestCallbackIds.add(id);\n\n        if (!_this9.ui.inlineAccountsResponse() && !_this9.ui.isStandalone()) {\n          _this9.publishWeb3RequestEvent(id, request);\n        }\n      });\n      return {\n        promise: promise,\n        cancel: cancel\n      };\n    }\n  }, {\n    key: \"selectProvider\",\n    value: function selectProvider(providerOptions) {\n      var _this10 = this;\n\n      var request = {\n        method: Web3Method_1.Web3Method.selectProvider,\n        params: {\n          providerOptions: providerOptions\n        }\n      };\n      var id = (0, util_1.randomBytesHex)(8);\n\n      var cancel = function cancel(error) {\n        _this10.publishWeb3RequestCanceledEvent(id);\n\n        _this10.handleErrorResponse(id, request.method, error);\n      };\n\n      var promise = new Promise(function (resolve, reject) {\n        _this10.relayEventManager.callbacks.set(id, function (response) {\n          if (response.errorMessage) {\n            return reject(new Error(response.errorMessage));\n          }\n\n          resolve(response);\n        });\n\n        var _cancel = function _cancel(_error) {\n          _this10.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n            id: id,\n            response: (0, Web3Response_1.SelectProviderResponse)(types_1.ProviderType.Unselected)\n          }));\n        };\n\n        var approve = function approve(selectedProviderKey) {\n          _this10.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n            id: id,\n            response: (0, Web3Response_1.SelectProviderResponse)(selectedProviderKey)\n          }));\n        };\n\n        if (_this10.ui.selectProvider) _this10.ui.selectProvider({\n          onApprove: approve,\n          onCancel: _cancel,\n          providerOptions: providerOptions\n        });\n      });\n      return {\n        cancel: cancel,\n        promise: promise\n      };\n    }\n  }, {\n    key: \"watchAsset\",\n    value: function watchAsset(type, address, symbol, decimals, image, chainId) {\n      var _this11 = this;\n\n      var request = {\n        method: Web3Method_1.Web3Method.watchAsset,\n        params: {\n          type: type,\n          options: {\n            address: address,\n            symbol: symbol,\n            decimals: decimals,\n            image: image\n          },\n          chainId: chainId\n        }\n      };\n      var hideSnackbarItem = null;\n      var id = (0, util_1.randomBytesHex)(8);\n\n      var cancel = function cancel(error) {\n        _this11.publishWeb3RequestCanceledEvent(id);\n\n        _this11.handleErrorResponse(id, request.method, error);\n\n        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n      };\n\n      if (!this.ui.inlineWatchAsset()) {\n        hideSnackbarItem = this.ui.showConnecting({\n          isUnlinkedErrorState: this.isUnlinkedErrorState,\n          onCancel: cancel,\n          onResetConnection: this.resetAndReload // eslint-disable-line @typescript-eslint/unbound-method\n\n        });\n      }\n\n      var promise = new Promise(function (resolve, reject) {\n        _this11.relayEventManager.callbacks.set(id, function (response) {\n          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n\n          if (response.errorMessage) {\n            return reject(new Error(response.errorMessage));\n          }\n\n          resolve(response);\n        });\n\n        var _cancel = function _cancel(_error) {\n          _this11.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n            id: id,\n            response: (0, Web3Response_1.WatchAssetReponse)(false)\n          }));\n        };\n\n        var approve = function approve() {\n          _this11.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n            id: id,\n            response: (0, Web3Response_1.WatchAssetReponse)(true)\n          }));\n        };\n\n        if (_this11.ui.inlineWatchAsset()) {\n          _this11.ui.watchAsset({\n            onApprove: approve,\n            onCancel: _cancel,\n            type: type,\n            address: address,\n            symbol: symbol,\n            decimals: decimals,\n            image: image,\n            chainId: chainId\n          });\n        }\n\n        if (!_this11.ui.inlineWatchAsset() && !_this11.ui.isStandalone()) {\n          _this11.publishWeb3RequestEvent(id, request);\n        }\n      });\n      return {\n        cancel: cancel,\n        promise: promise\n      };\n    }\n  }, {\n    key: \"addEthereumChain\",\n    value: function addEthereumChain(chainId, rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency) {\n      var _this12 = this;\n\n      var request = {\n        method: Web3Method_1.Web3Method.addEthereumChain,\n        params: {\n          chainId: chainId,\n          rpcUrls: rpcUrls,\n          blockExplorerUrls: blockExplorerUrls,\n          chainName: chainName,\n          iconUrls: iconUrls,\n          nativeCurrency: nativeCurrency\n        }\n      };\n      var hideSnackbarItem = null;\n      var id = (0, util_1.randomBytesHex)(8);\n\n      var cancel = function cancel(error) {\n        _this12.publishWeb3RequestCanceledEvent(id);\n\n        _this12.handleErrorResponse(id, request.method, error);\n\n        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n      };\n\n      if (!this.ui.inlineAddEthereumChain(chainId)) {\n        hideSnackbarItem = this.ui.showConnecting({\n          isUnlinkedErrorState: this.isUnlinkedErrorState,\n          onCancel: cancel,\n          onResetConnection: this.resetAndReload // eslint-disable-line @typescript-eslint/unbound-method\n\n        });\n      }\n\n      var promise = new Promise(function (resolve, reject) {\n        _this12.relayEventManager.callbacks.set(id, function (response) {\n          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n\n          if (response.errorMessage) {\n            return reject(new Error(response.errorMessage));\n          }\n\n          resolve(response);\n        });\n\n        var _cancel = function _cancel(_error) {\n          _this12.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n            id: id,\n            response: (0, Web3Response_1.AddEthereumChainResponse)({\n              isApproved: false,\n              rpcUrl: \"\"\n            })\n          }));\n        };\n\n        var approve = function approve(rpcUrl) {\n          _this12.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n            id: id,\n            response: (0, Web3Response_1.AddEthereumChainResponse)({\n              isApproved: true,\n              rpcUrl: rpcUrl\n            })\n          }));\n        };\n\n        if (_this12.ui.inlineAddEthereumChain(chainId)) {\n          _this12.ui.addEthereumChain({\n            onCancel: _cancel,\n            onApprove: approve,\n            chainId: request.params.chainId,\n            rpcUrls: request.params.rpcUrls,\n            blockExplorerUrls: request.params.blockExplorerUrls,\n            chainName: request.params.chainName,\n            iconUrls: request.params.iconUrls,\n            nativeCurrency: request.params.nativeCurrency\n          });\n        }\n\n        if (!_this12.ui.inlineAddEthereumChain(chainId) && !_this12.ui.isStandalone()) {\n          _this12.publishWeb3RequestEvent(id, request);\n        }\n      });\n      return {\n        promise: promise,\n        cancel: cancel\n      };\n    }\n  }, {\n    key: \"switchEthereumChain\",\n    value: function switchEthereumChain(chainId) {\n      var _this13 = this;\n\n      var request = {\n        method: Web3Method_1.Web3Method.switchEthereumChain,\n        params: {\n          chainId: chainId\n        }\n      };\n      var hideSnackbarItem = null;\n      var id = (0, util_1.randomBytesHex)(8);\n\n      var cancel = function cancel(error) {\n        _this13.publishWeb3RequestCanceledEvent(id);\n\n        _this13.handleErrorResponse(id, request.method, error);\n\n        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n      };\n\n      if (!this.ui.inlineSwitchEthereumChain()) {\n        hideSnackbarItem = this.ui.showConnecting({\n          isUnlinkedErrorState: this.isUnlinkedErrorState,\n          onCancel: cancel,\n          onResetConnection: this.resetAndReload // eslint-disable-line @typescript-eslint/unbound-method\n\n        });\n      }\n\n      var promise = new Promise(function (resolve, reject) {\n        _this13.relayEventManager.callbacks.set(id, function (response) {\n          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n\n          if (response.errorMessage && response.errorCode) {\n            return reject(eth_rpc_errors_1.ethErrors.provider.custom({\n              code: response.errorCode,\n              message: \"Unrecognized chain ID. Try adding the chain using addEthereumChain first.\"\n            }));\n          } else if (response.errorMessage) {\n            return reject(new Error(response.errorMessage));\n          }\n\n          resolve(response);\n        });\n\n        var _cancel = function _cancel(error) {\n          if (typeof error === \"number\") {\n            // backward compatibility\n            var errorCode = error;\n\n            _this13.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n              id: id,\n              response: (0, Web3Response_1.ErrorResponse)(Web3Method_1.Web3Method.switchEthereumChain, WalletUIError_1.WalletUIError.SwitchEthereumChainUnsupportedChainId.message, errorCode)\n            }));\n          } else if (error instanceof WalletUIError_1.WalletUIError) {\n            _this13.handleErrorResponse(id, Web3Method_1.Web3Method.switchEthereumChain, error, error.errorCode);\n          } else {\n            _this13.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n              id: id,\n              response: (0, Web3Response_1.SwitchEthereumChainResponse)({\n                isApproved: false,\n                rpcUrl: \"\"\n              })\n            }));\n          }\n        };\n\n        var approve = function approve(rpcUrl) {\n          _this13.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n            id: id,\n            response: (0, Web3Response_1.SwitchEthereumChainResponse)({\n              isApproved: true,\n              rpcUrl: rpcUrl\n            })\n          }));\n        };\n\n        _this13.ui.switchEthereumChain({\n          onCancel: _cancel,\n          onApprove: approve,\n          chainId: request.params.chainId\n        });\n\n        if (!_this13.ui.inlineSwitchEthereumChain() && !_this13.ui.isStandalone()) {\n          _this13.publishWeb3RequestEvent(id, request);\n        }\n      });\n      return {\n        promise: promise,\n        cancel: cancel\n      };\n    }\n  }, {\n    key: \"inlineAddEthereumChain\",\n    value: function inlineAddEthereumChain(chainId) {\n      return this.ui.inlineAddEthereumChain(chainId);\n    }\n  }, {\n    key: \"getSessionIdHash\",\n    value: function getSessionIdHash() {\n      return Session_1.Session.hash(this._session.id);\n    }\n  }, {\n    key: \"sendRequestStandalone\",\n    value: function sendRequestStandalone(id, request) {\n      var _this14 = this;\n\n      var _cancel = function _cancel(error) {\n        _this14.handleErrorResponse(id, request.method, error);\n      };\n\n      var onSuccess = function onSuccess(response) {\n        _this14.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n          id: id,\n          response: response\n        }));\n      };\n\n      switch (request.method) {\n        case Web3Method_1.Web3Method.signEthereumMessage:\n          this.ui.signEthereumMessage({\n            request: request,\n            onSuccess: onSuccess,\n            onCancel: _cancel\n          });\n          break;\n\n        case Web3Method_1.Web3Method.signEthereumTransaction:\n          this.ui.signEthereumTransaction({\n            request: request,\n            onSuccess: onSuccess,\n            onCancel: _cancel\n          });\n          break;\n\n        case Web3Method_1.Web3Method.submitEthereumTransaction:\n          this.ui.submitEthereumTransaction({\n            request: request,\n            onSuccess: onSuccess,\n            onCancel: _cancel\n          });\n          break;\n\n        case Web3Method_1.Web3Method.ethereumAddressFromSignedMessage:\n          this.ui.ethereumAddressFromSignedMessage({\n            request: request,\n            onSuccess: onSuccess\n          });\n          break;\n\n        default:\n          _cancel();\n\n          break;\n      }\n    }\n  }, {\n    key: \"onSessionConfigChanged\",\n    value: function onSessionConfigChanged(_nextSessionConfig) {}\n  }]);\n\n  return WalletSDKRelay;\n}(WalletSDKRelayAbstract_1.WalletSDKRelayAbstract);\n\nWalletSDKRelay.accountRequestCallbackIds = new Set();\n\n__decorate([bind_decorator_1.default], WalletSDKRelay.prototype, \"resetAndReload\", null);\n\n__decorate([bind_decorator_1.default], WalletSDKRelay.prototype, \"handleIncomingEvent\", null);\n\nexports.WalletSDKRelay = WalletSDKRelay;","map":null,"metadata":{},"sourceType":"script"}