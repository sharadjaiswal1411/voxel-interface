{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethUtil = require(\"ethereumjs-util\");\n\nvar ethers = require(\"ethers\");\n\nvar configured_bignumber_1 = require(\"./configured_bignumber\");\n\nexports.signTypedDataUtils = {\n  /**\n   * Generates the EIP712 Typed Data hash for signing\n   * @param   typedData An object that conforms to the EIP712TypedData interface\n   * @return  A Buffer containing the hash of the typed data.\n   */\n  generateTypedDataHash: function generateTypedDataHash(typedData) {\n    return ethUtil.sha3(Buffer.concat([Buffer.from('1901', 'hex'), exports.signTypedDataUtils._structHash('EIP712Domain', typedData.domain, typedData.types), exports.signTypedDataUtils._structHash(typedData.primaryType, typedData.message, typedData.types)]));\n  },\n  _findDependencies: function _findDependencies(primaryType, types, found) {\n    if (found === void 0) {\n      found = [];\n    }\n\n    var e_1, _a, e_2, _b;\n\n    if (found.includes(primaryType) || types[primaryType] === undefined) {\n      return found;\n    }\n\n    found.push(primaryType);\n\n    try {\n      for (var _c = __values(types[primaryType]), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var field = _d.value;\n\n        try {\n          for (var _e = __values(exports.signTypedDataUtils._findDependencies(field.type, types, found)), _f = _e.next(); !_f.done; _f = _e.next()) {\n            var dep = _f.value;\n\n            if (!found.includes(dep)) {\n              found.push(dep);\n            }\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return found;\n  },\n  _encodeType: function _encodeType(primaryType, types) {\n    var e_3, _a;\n\n    var deps = exports.signTypedDataUtils._findDependencies(primaryType, types);\n\n    deps = deps.filter(function (d) {\n      return d !== primaryType;\n    });\n    deps = [primaryType].concat(deps.sort());\n    var result = '';\n\n    try {\n      for (var deps_1 = __values(deps), deps_1_1 = deps_1.next(); !deps_1_1.done; deps_1_1 = deps_1.next()) {\n        var dep = deps_1_1.value;\n        result += dep + \"(\" + types[dep].map(function (_a) {\n          var name = _a.name,\n              type = _a.type;\n          return type + \" \" + name;\n        }).join(',') + \")\";\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (deps_1_1 && !deps_1_1.done && (_a = deps_1.return)) _a.call(deps_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    return result;\n  },\n  _encodeData: function _encodeData(primaryType, data, types) {\n    var e_4, _a;\n\n    var encodedTypes = ['bytes32'];\n    var encodedValues = [exports.signTypedDataUtils._typeHash(primaryType, types)];\n\n    try {\n      for (var _b = __values(types[primaryType]), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var field = _c.value;\n        var value = data[field.name];\n\n        if (field.type === 'string' || field.type === 'bytes') {\n          var hashValue = ethUtil.sha3(value);\n          encodedTypes.push('bytes32');\n          encodedValues.push(hashValue);\n        } else if (types[field.type] !== undefined) {\n          encodedTypes.push('bytes32');\n          var hashValue = ethUtil.sha3( // tslint:disable-next-line:no-unnecessary-type-assertion\n          exports.signTypedDataUtils._encodeData(field.type, value, types));\n          encodedValues.push(hashValue);\n        } else if (field.type.lastIndexOf(']') === field.type.length - 1) {\n          throw new Error('Arrays currently unimplemented in encodeData');\n        } else {\n          encodedTypes.push(field.type);\n\n          var normalizedValue = exports.signTypedDataUtils._normalizeValue(field.type, value);\n\n          encodedValues.push(normalizedValue);\n        }\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n\n    return ethers.utils.defaultAbiCoder.encode(encodedTypes, encodedValues);\n  },\n  _normalizeValue: function _normalizeValue(type, value) {\n    var normalizedValue = type === 'uint256' && configured_bignumber_1.BigNumber.isBigNumber(value) ? value.toString() : value;\n    return normalizedValue;\n  },\n  _typeHash: function _typeHash(primaryType, types) {\n    return ethUtil.sha3(exports.signTypedDataUtils._encodeType(primaryType, types));\n  },\n  _structHash: function _structHash(primaryType, data, types) {\n    return ethUtil.sha3(exports.signTypedDataUtils._encodeData(primaryType, data, types));\n  }\n};","map":null,"metadata":{},"sourceType":"script"}