{"ast":null,"code":"import { isAddress } from 'utils';\n\nvar alwaysTrue = function alwaysTrue() {\n  return true;\n};\n/**\n * Create a filter function to apply to a token for whether it matches a particular search query\n * @param search the search query to apply to the token\n */\n\n\nexport function createTokenFilterFunction(search) {\n  var searchingAddress = isAddress(search);\n\n  if (searchingAddress) {\n    var lower = searchingAddress.toLowerCase();\n    return function (t) {\n      return 'isToken' in t ? searchingAddress === t.address : lower === t.address.toLowerCase();\n    };\n  }\n\n  var lowerSearchParts = search.toLowerCase().split(/\\s+/).filter(function (s) {\n    return s.length > 0;\n  });\n  if (lowerSearchParts.length === 0) return alwaysTrue;\n\n  var matchesSearch = function matchesSearch(s) {\n    var sParts = s.toLowerCase().split(/\\s+/).filter(function (s) {\n      return s.length > 0;\n    });\n    return lowerSearchParts.every(function (p) {\n      return p.length === 0 || sParts.some(function (sp) {\n        return sp.startsWith(p) || sp.endsWith(p);\n      });\n    });\n  };\n\n  return function (_ref) {\n    var name = _ref.name,\n        symbol = _ref.symbol;\n    return Boolean(symbol && matchesSearch(symbol) || name && matchesSearch(name));\n  };\n}\nexport function filterTokens(tokens, search) {\n  return tokens.filter(createTokenFilterFunction(search));\n}\nexport function filterTokensWithExactKeyword(tokens, search) {\n  var result = filterTokens(tokens, search);\n  if (isAddress(search)) return result;\n  var filterExact = result.filter(function (e) {\n    return e.symbol ? e.symbol.toLowerCase() === search.toLowerCase() : true;\n  }); // Exact Keyword\n\n  return filterExact.length ? filterExact : result;\n}","map":{"version":3,"names":["isAddress","alwaysTrue","createTokenFilterFunction","search","searchingAddress","lower","toLowerCase","t","address","lowerSearchParts","split","filter","s","length","matchesSearch","sParts","every","p","some","sp","startsWith","endsWith","name","symbol","Boolean","filterTokens","tokens","filterTokensWithExactKeyword","result","filterExact","e"],"sources":["/Applications/XAMPP/voxel-interface/src/utils/filtering.ts"],"sourcesContent":["import { Token } from '@kyberswap/ks-sdk-core'\nimport { TokenInfo } from '@uniswap/token-lists'\n\nimport { isAddress } from 'utils'\n\nconst alwaysTrue = () => true\n\n/**\n * Create a filter function to apply to a token for whether it matches a particular search query\n * @param search the search query to apply to the token\n */\nexport function createTokenFilterFunction<T extends Token | TokenInfo>(search: string): (tokens: T) => boolean {\n  const searchingAddress = isAddress(search)\n\n  if (searchingAddress) {\n    const lower = searchingAddress.toLowerCase()\n    return (t: T) => ('isToken' in t ? searchingAddress === t.address : lower === t.address.toLowerCase())\n  }\n\n  const lowerSearchParts = search\n    .toLowerCase()\n    .split(/\\s+/)\n    .filter(s => s.length > 0)\n\n  if (lowerSearchParts.length === 0) return alwaysTrue\n\n  const matchesSearch = (s: string): boolean => {\n    const sParts = s\n      .toLowerCase()\n      .split(/\\s+/)\n      .filter(s => s.length > 0)\n\n    return lowerSearchParts.every(p => p.length === 0 || sParts.some(sp => sp.startsWith(p) || sp.endsWith(p)))\n  }\n\n  return ({ name, symbol }: T): boolean => Boolean((symbol && matchesSearch(symbol)) || (name && matchesSearch(name)))\n}\n\nexport function filterTokens<T extends Token | TokenInfo>(tokens: T[], search: string): T[] {\n  return tokens.filter(createTokenFilterFunction(search))\n}\n\nexport function filterTokensWithExactKeyword<T extends Token | TokenInfo>(tokens: T[], search: string): T[] {\n  const result = filterTokens(tokens, search)\n  if (isAddress(search)) return result\n  const filterExact = result.filter(e => (e.symbol ? e.symbol.toLowerCase() === search.toLowerCase() : true)) // Exact Keyword\n  return filterExact.length ? filterExact : result\n}\n"],"mappings":"AAGA,SAASA,SAAT,QAA0B,OAA1B;;AAEA,IAAMC,UAAU,GAAG,SAAbA,UAAa;EAAA,OAAM,IAAN;AAAA,CAAnB;AAEA;AACA;AACA;AACA;;;AACA,OAAO,SAASC,yBAAT,CAAgEC,MAAhE,EAAwG;EAC7G,IAAMC,gBAAgB,GAAGJ,SAAS,CAACG,MAAD,CAAlC;;EAEA,IAAIC,gBAAJ,EAAsB;IACpB,IAAMC,KAAK,GAAGD,gBAAgB,CAACE,WAAjB,EAAd;IACA,OAAO,UAACC,CAAD;MAAA,OAAW,aAAaA,CAAb,GAAiBH,gBAAgB,KAAKG,CAAC,CAACC,OAAxC,GAAkDH,KAAK,KAAKE,CAAC,CAACC,OAAF,CAAUF,WAAV,EAAvE;IAAA,CAAP;EACD;;EAED,IAAMG,gBAAgB,GAAGN,MAAM,CAC5BG,WADsB,GAEtBI,KAFsB,CAEhB,KAFgB,EAGtBC,MAHsB,CAGf,UAAAC,CAAC;IAAA,OAAIA,CAAC,CAACC,MAAF,GAAW,CAAf;EAAA,CAHc,CAAzB;EAKA,IAAIJ,gBAAgB,CAACI,MAAjB,KAA4B,CAAhC,EAAmC,OAAOZ,UAAP;;EAEnC,IAAMa,aAAa,GAAG,SAAhBA,aAAgB,CAACF,CAAD,EAAwB;IAC5C,IAAMG,MAAM,GAAGH,CAAC,CACbN,WADY,GAEZI,KAFY,CAEN,KAFM,EAGZC,MAHY,CAGL,UAAAC,CAAC;MAAA,OAAIA,CAAC,CAACC,MAAF,GAAW,CAAf;IAAA,CAHI,CAAf;IAKA,OAAOJ,gBAAgB,CAACO,KAAjB,CAAuB,UAAAC,CAAC;MAAA,OAAIA,CAAC,CAACJ,MAAF,KAAa,CAAb,IAAkBE,MAAM,CAACG,IAAP,CAAY,UAAAC,EAAE;QAAA,OAAIA,EAAE,CAACC,UAAH,CAAcH,CAAd,KAAoBE,EAAE,CAACE,QAAH,CAAYJ,CAAZ,CAAxB;MAAA,CAAd,CAAtB;IAAA,CAAxB,CAAP;EACD,CAPD;;EASA,OAAO;IAAA,IAAGK,IAAH,QAAGA,IAAH;IAAA,IAASC,MAAT,QAASA,MAAT;IAAA,OAAkCC,OAAO,CAAED,MAAM,IAAIT,aAAa,CAACS,MAAD,CAAxB,IAAsCD,IAAI,IAAIR,aAAa,CAACQ,IAAD,CAA5D,CAAzC;EAAA,CAAP;AACD;AAED,OAAO,SAASG,YAAT,CAAmDC,MAAnD,EAAgEvB,MAAhE,EAAqF;EAC1F,OAAOuB,MAAM,CAACf,MAAP,CAAcT,yBAAyB,CAACC,MAAD,CAAvC,CAAP;AACD;AAED,OAAO,SAASwB,4BAAT,CAAmED,MAAnE,EAAgFvB,MAAhF,EAAqG;EAC1G,IAAMyB,MAAM,GAAGH,YAAY,CAACC,MAAD,EAASvB,MAAT,CAA3B;EACA,IAAIH,SAAS,CAACG,MAAD,CAAb,EAAuB,OAAOyB,MAAP;EACvB,IAAMC,WAAW,GAAGD,MAAM,CAACjB,MAAP,CAAc,UAAAmB,CAAC;IAAA,OAAKA,CAAC,CAACP,MAAF,GAAWO,CAAC,CAACP,MAAF,CAASjB,WAAT,OAA2BH,MAAM,CAACG,WAAP,EAAtC,GAA6D,IAAlE;EAAA,CAAf,CAApB,CAH0G,CAGE;;EAC5G,OAAOuB,WAAW,CAAChB,MAAZ,GAAqBgB,WAArB,GAAmCD,MAA1C;AACD"},"metadata":{},"sourceType":"module"}