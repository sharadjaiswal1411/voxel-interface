{"ast":null,"code":"import _classCallCheck from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { dropUndefinedKeys } from '@sentry/utils';\nimport { getCurrentHub } from './hub.js';\n/**\n * @inheritdoc\n */\n\nvar SessionFlusher = /*#__PURE__*/function () {\n  function SessionFlusher(client, attrs) {\n    var _this = this;\n\n    _classCallCheck(this, SessionFlusher);\n\n    ;\n\n    SessionFlusher.prototype.__init.call(this);\n\n    SessionFlusher.prototype.__init2.call(this);\n\n    SessionFlusher.prototype.__init3.call(this);\n\n    this._client = client; // Call to setInterval, so that flush is called every 60 seconds\n\n    this._intervalId = setInterval(function () {\n      return _this.flush();\n    }, this.flushTimeout * 1000);\n    this._sessionAttrs = attrs;\n  }\n  /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSession` */\n\n\n  _createClass(SessionFlusher, [{\n    key: \"__init\",\n    value: function __init() {\n      this.flushTimeout = 60;\n    }\n  }, {\n    key: \"__init2\",\n    value: function __init2() {\n      this._pendingAggregates = {};\n    }\n  }, {\n    key: \"__init3\",\n    value: function __init3() {\n      this._isEnabled = true;\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      var sessionAggregates = this.getSessionAggregates();\n\n      if (sessionAggregates.aggregates.length === 0) {\n        return;\n      }\n\n      this._pendingAggregates = {};\n\n      this._client.sendSession(sessionAggregates);\n    }\n    /** Massages the entries in `pendingAggregates` and returns aggregated sessions */\n\n  }, {\n    key: \"getSessionAggregates\",\n    value: function getSessionAggregates() {\n      var _this2 = this;\n\n      var aggregates = Object.keys(this._pendingAggregates).map(function (key) {\n        return _this2._pendingAggregates[parseInt(key)];\n      });\n      var sessionAggregates = {\n        attrs: this._sessionAttrs,\n        aggregates: aggregates\n      };\n      return dropUndefinedKeys(sessionAggregates);\n    }\n    /** JSDoc */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      clearInterval(this._intervalId);\n      this._isEnabled = false;\n      this.flush();\n    }\n    /**\n     * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then\n     * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to\n     * `_incrementSessionStatusCount` along with the start date\n     */\n\n  }, {\n    key: \"incrementSessionStatusCount\",\n    value: function incrementSessionStatusCount() {\n      if (!this._isEnabled) {\n        return;\n      }\n\n      var scope = getCurrentHub().getScope();\n      var requestSession = scope && scope.getRequestSession();\n\n      if (requestSession && requestSession.status) {\n        this._incrementSessionStatusCount(requestSession.status, new Date()); // This is not entirely necessarily but is added as a safe guard to indicate the bounds of a request and so in\n        // case captureRequestSession is called more than once to prevent double count\n\n\n        if (scope) {\n          scope.setRequestSession(undefined);\n        }\n      }\n    }\n    /**\n     * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of\n     * the session received\n     */\n\n  }, {\n    key: \"_incrementSessionStatusCount\",\n    value: function _incrementSessionStatusCount(status, date) {\n      // Truncate minutes and seconds on Session Started attribute to have one minute bucket keys\n      var sessionStartedTrunc = new Date(date).setSeconds(0, 0);\n      this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {}; // corresponds to aggregated sessions in one specific minute bucket\n      // for example, {\"started\":\"2021-03-16T08:00:00.000Z\",\"exited\":4, \"errored\": 1}\n\n      var aggregationCounts = this._pendingAggregates[sessionStartedTrunc];\n\n      if (!aggregationCounts.started) {\n        aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();\n      }\n\n      switch (status) {\n        case 'errored':\n          aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;\n          return aggregationCounts.errored;\n\n        case 'ok':\n          aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;\n          return aggregationCounts.exited;\n\n        default:\n          aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;\n          return aggregationCounts.crashed;\n      }\n    }\n  }]);\n\n  return SessionFlusher;\n}();\n\nexport { SessionFlusher };","map":null,"metadata":{},"sourceType":"module"}