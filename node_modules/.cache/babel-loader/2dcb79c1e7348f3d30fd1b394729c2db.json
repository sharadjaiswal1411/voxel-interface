{"ast":null,"code":"import _regeneratorRuntime from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectSpread from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Fraction, Price, TokenAmount, TradeType } from '@kyberswap/ks-sdk-core';\nimport { captureException } from '@sentry/react';\nimport JSBI from 'jsbi';\nimport invariant from 'tiny-invariant';\nimport { DEX_TO_COMPARE } from 'constants/dexes';\nimport { ETHER_ADDRESS, KYBERSWAP_SOURCE, sentryRequestId } from 'constants/index';\nimport fetchWaiting from './fetchWaiting';\n/**\n */\n\nexport var Aggregator = /*#__PURE__*/function () {\n  /**\n   * The type of the trade, either exact in or exact out.\n   */\n\n  /**\n   * The input amount for the trade assuming no slippage.\n   */\n\n  /**\n   * The output amount for the trade assuming no slippage.\n   */\n\n  /**\n   */\n\n  /**\n   */\n\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  // -1 mean can not get price of token => can not calculate price impact\n  function Aggregator(inputAmount, outputAmount, amountInUsd, amountOutUsd, receivedUsd, swaps, tokens, tradeType, gasUsd, priceImpact, encodedSwapData, routerAddress) {\n    _classCallCheck(this, Aggregator);\n\n    this.tradeType = void 0;\n    this.inputAmount = void 0;\n    this.outputAmount = void 0;\n    this.swaps = void 0;\n    this.tokens = void 0;\n    this.executionPrice = void 0;\n    this.amountInUsd = void 0;\n    this.amountOutUsd = void 0;\n    this.receivedUsd = void 0;\n    this.gasUsd = void 0;\n    this.priceImpact = void 0;\n    this.encodedSwapData = void 0;\n    this.routerAddress = void 0;\n    this.tradeType = tradeType;\n    this.inputAmount = inputAmount;\n    this.outputAmount = outputAmount;\n    this.amountInUsd = amountInUsd;\n    this.amountOutUsd = amountOutUsd;\n    this.receivedUsd = receivedUsd;\n    this.executionPrice = new Price(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.quotient, this.outputAmount.quotient);\n    this.swaps = swaps;\n    this.tokens = tokens;\n    this.gasUsd = gasUsd;\n    this.priceImpact = priceImpact;\n    this.encodedSwapData = encodedSwapData;\n    this.routerAddress = routerAddress;\n  }\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n\n\n  _createClass(Aggregator, [{\n    key: \"minimumAmountOut\",\n    value: function minimumAmountOut(slippageTolerance) {\n      invariant(!slippageTolerance.lessThan(JSBI.BigInt(0)), 'SLIPPAGE_TOLERANCE');\n\n      if (this.tradeType === TradeType.EXACT_OUTPUT) {\n        return this.outputAmount;\n      } else {\n        var slippageAdjustedAmountOut = new Fraction(JSBI.BigInt(1)).add(slippageTolerance).invert().multiply(this.outputAmount.quotient).quotient;\n        return TokenAmount.fromRawAmount(this.outputAmount.currency, slippageAdjustedAmountOut);\n      }\n    }\n    /**\n     * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n     * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n     */\n\n  }, {\n    key: \"maximumAmountIn\",\n    value: function maximumAmountIn(slippageTolerance) {\n      invariant(!slippageTolerance.lessThan(JSBI.BigInt(0)), 'SLIPPAGE_TOLERANCE');\n\n      if (this.tradeType === TradeType.EXACT_INPUT) {\n        return this.inputAmount;\n      } else {\n        var slippageAdjustedAmountIn = new Fraction(JSBI.BigInt(1)).add(slippageTolerance).multiply(this.inputAmount.quotient).quotient;\n        return TokenAmount.fromRawAmount(this.inputAmount.currency, slippageAdjustedAmountIn);\n      }\n    }\n    /**\n     * @param baseURL\n     * @param currencyAmountIn exact amount of input currency to spend\n     * @param currencyOut the desired currency out\n     * @param saveGas\n     * @param dexes\n     * @param slippageTolerance\n     * @param deadline\n     * @param to\n     * @param feeConfig\n     * @param signal\n     * @param minimumLoadingTime\n     */\n\n  }], [{\n    key: \"bestTradeExactIn\",\n    value: function () {\n      var _bestTradeExactIn = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(baseURL, currencyAmountIn, currencyOut) {\n        var saveGas,\n            dexes,\n            slippageTolerance,\n            deadline,\n            to,\n            feeConfig,\n            signal,\n            minimumLoadingTime,\n            chainId,\n            amountIn,\n            tokenOut,\n            tokenInAddress,\n            tokenOutAddress,\n            _currencyAmountIn$quo,\n            _slippageTolerance$to,\n            _deadline$toString,\n            _feeConfig$chargeFeeB,\n            _feeConfig$feeReceive,\n            _feeConfig$feeAmount,\n            search,\n            response,\n            result,\n            toCurrencyAmount,\n            outputAmount,\n            priceImpact,\n            encodedSwapData,\n            routerAddress,\n            _e$message,\n            _e$message2,\n            _e,\n            _args = arguments;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                saveGas = _args.length > 3 && _args[3] !== undefined ? _args[3] : false;\n                dexes = _args.length > 4 && _args[4] !== undefined ? _args[4] : '';\n                slippageTolerance = _args.length > 5 ? _args[5] : undefined;\n                deadline = _args.length > 6 ? _args[6] : undefined;\n                to = _args.length > 7 ? _args[7] : undefined;\n                feeConfig = _args.length > 8 ? _args[8] : undefined;\n                signal = _args.length > 9 ? _args[9] : undefined;\n                minimumLoadingTime = _args.length > 10 ? _args[10] : undefined;\n                chainId = currencyAmountIn.currency.chainId || currencyOut.chainId;\n                invariant(chainId !== undefined, 'CHAIN_ID');\n                amountIn = currencyAmountIn;\n                tokenOut = currencyOut.wrapped;\n                tokenInAddress = currencyAmountIn.currency.isNative ? ETHER_ADDRESS : amountIn.currency.wrapped.address;\n                tokenOutAddress = currencyOut.isNative ? ETHER_ADDRESS : tokenOut.address;\n\n                if (!(tokenInAddress && tokenOutAddress)) {\n                  _context.next = 36;\n                  break;\n                }\n\n                search = new URLSearchParams(_objectSpread(_objectSpread({\n                  // Trade config\n                  tokenIn: tokenInAddress.toLowerCase(),\n                  tokenOut: tokenOutAddress.toLowerCase(),\n                  amountIn: (_currencyAmountIn$quo = currencyAmountIn.quotient) === null || _currencyAmountIn$quo === void 0 ? void 0 : _currencyAmountIn$quo.toString(),\n                  saveGas: saveGas ? '1' : '0',\n                  gasInclude: saveGas ? '1' : '0'\n                }, dexes ? {\n                  dexes: dexes\n                } : {}), {}, {\n                  slippageTolerance: (_slippageTolerance$to = slippageTolerance === null || slippageTolerance === void 0 ? void 0 : slippageTolerance.toString()) !== null && _slippageTolerance$to !== void 0 ? _slippageTolerance$to : '',\n                  deadline: (_deadline$toString = deadline === null || deadline === void 0 ? void 0 : deadline.toString()) !== null && _deadline$toString !== void 0 ? _deadline$toString : '',\n                  to: to,\n                  // Fee config\n                  chargeFeeBy: (_feeConfig$chargeFeeB = feeConfig === null || feeConfig === void 0 ? void 0 : feeConfig.chargeFeeBy) !== null && _feeConfig$chargeFeeB !== void 0 ? _feeConfig$chargeFeeB : '',\n                  feeReceiver: (_feeConfig$feeReceive = feeConfig === null || feeConfig === void 0 ? void 0 : feeConfig.feeReceiver) !== null && _feeConfig$feeReceive !== void 0 ? _feeConfig$feeReceive : '',\n                  isInBps: (feeConfig === null || feeConfig === void 0 ? void 0 : feeConfig.isInBps) !== undefined ? feeConfig.isInBps ? '1' : '0' : '',\n                  feeAmount: (_feeConfig$feeAmount = feeConfig === null || feeConfig === void 0 ? void 0 : feeConfig.feeAmount) !== null && _feeConfig$feeAmount !== void 0 ? _feeConfig$feeAmount : '',\n                  // Client data\n                  clientData: KYBERSWAP_SOURCE\n                }));\n                _context.prev = 16;\n                console.log(\"ddddd\", \"\".concat(baseURL, \"?\").concat(search));\n                _context.next = 20;\n                return fetchWaiting(\"\".concat(baseURL, \"?\").concat(search), {\n                  signal: signal,\n                  headers: {\n                    'X-Request-Id': sentryRequestId,\n                    'Accept-Version': 'Latest'\n                  }\n                }, minimumLoadingTime);\n\n              case 20:\n                response = _context.sent;\n                _context.next = 23;\n                return response.json();\n\n              case 23:\n                result = _context.sent;\n\n                if (!(!(result !== null && result !== void 0 && result.inputAmount) || !(result !== null && result !== void 0 && result.outputAmount) || result.inputAmount === '0' || result.outputAmount === '0')) {\n                  _context.next = 26;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", null);\n\n              case 26:\n                toCurrencyAmount = function toCurrencyAmount(value, currency) {\n                  return TokenAmount.fromRawAmount(currency, JSBI.BigInt(value));\n                };\n\n                outputAmount = toCurrencyAmount(result.outputAmount, currencyOut);\n                priceImpact = !result.amountOutUsd ? -1 : (-result.amountOutUsd + result.amountInUsd) * 100 / result.amountInUsd;\n                encodedSwapData = result.encodedSwapData, routerAddress = result.routerAddress;\n                return _context.abrupt(\"return\", new Aggregator(currencyAmountIn, outputAmount, result.amountInUsd, result.amountOutUsd, result.receivedUsd, result.swaps || [], result.tokens || {}, TradeType.EXACT_INPUT, result.gasUsd, priceImpact, encodedSwapData, routerAddress));\n\n              case 33:\n                _context.prev = 33;\n                _context.t0 = _context[\"catch\"](16);\n\n                // ignore aborted request error\n                if (!(_context.t0 !== null && _context.t0 !== void 0 && (_e$message = _context.t0.message) !== null && _e$message !== void 0 && _e$message.includes('Fetch is aborted')) && !(_context.t0 !== null && _context.t0 !== void 0 && (_e$message2 = _context.t0.message) !== null && _e$message2 !== void 0 && _e$message2.includes('The user aborted a request'))) {\n                  _e = new Error('Aggregator API call failed');\n                  _e.name = 'AggregatorAPIError';\n                  captureException(_e, {\n                    level: 'error'\n                  });\n                }\n\n              case 36:\n                return _context.abrupt(\"return\", null);\n\n              case 37:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[16, 33]]);\n      }));\n\n      function bestTradeExactIn(_x, _x2, _x3) {\n        return _bestTradeExactIn.apply(this, arguments);\n      }\n\n      return bestTradeExactIn;\n    }()\n    /**\n     * @param baseURL\n     * @param currencyAmountIn exact amount of input currency to spend\n     * @param currencyOut the desired currency out\n     * @param slippageTolerance\n     * @param deadline\n     * @param to\n     * @param feeConfig\n     * @param signal\n     * @param minimumLoadingTime\n     */\n\n  }, {\n    key: \"compareDex\",\n    value: function () {\n      var _compareDex = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(baseURL, currencyAmountIn, currencyOut, slippageTolerance, deadline, to, feeConfig, signal, minimumLoadingTime) {\n        var chainId, amountIn, tokenOut, tokenInAddress, tokenOutAddress, comparedDex, _currencyAmountIn$quo2, _slippageTolerance$to2, _deadline$toString2, _feeConfig$chargeFeeB2, _feeConfig$feeReceive2, _feeConfig$feeAmount2, search, response, swapData, toCurrencyAmount, inputAmount, outputAmount, amountInUsd, amountOutUsd, receivedUsd, _e$message3, _e$message4, _e2;\n\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                chainId = currencyAmountIn.currency.chainId || currencyOut.chainId;\n                invariant(chainId !== undefined, 'CHAIN_ID');\n                amountIn = currencyAmountIn;\n                tokenOut = currencyOut.wrapped;\n                tokenInAddress = currencyAmountIn.currency.isNative ? ETHER_ADDRESS : amountIn.currency.wrapped.address;\n                tokenOutAddress = currencyOut.isNative ? ETHER_ADDRESS : tokenOut.address;\n                comparedDex = DEX_TO_COMPARE[chainId];\n\n                if (!(tokenInAddress && tokenOutAddress && comparedDex)) {\n                  _context2.next = 30;\n                  break;\n                }\n\n                search = new URLSearchParams({\n                  // Trade config\n                  tokenIn: tokenInAddress.toLowerCase(),\n                  tokenOut: tokenOutAddress.toLowerCase(),\n                  amountIn: (_currencyAmountIn$quo2 = currencyAmountIn.quotient) === null || _currencyAmountIn$quo2 === void 0 ? void 0 : _currencyAmountIn$quo2.toString(),\n                  saveGas: '0',\n                  gasInclude: '1',\n                  dexes: comparedDex,\n                  slippageTolerance: (_slippageTolerance$to2 = slippageTolerance === null || slippageTolerance === void 0 ? void 0 : slippageTolerance.toString()) !== null && _slippageTolerance$to2 !== void 0 ? _slippageTolerance$to2 : '',\n                  deadline: (_deadline$toString2 = deadline === null || deadline === void 0 ? void 0 : deadline.toString()) !== null && _deadline$toString2 !== void 0 ? _deadline$toString2 : '',\n                  to: to,\n                  // Fee config\n                  chargeFeeBy: (_feeConfig$chargeFeeB2 = feeConfig === null || feeConfig === void 0 ? void 0 : feeConfig.chargeFeeBy) !== null && _feeConfig$chargeFeeB2 !== void 0 ? _feeConfig$chargeFeeB2 : '',\n                  feeReceiver: (_feeConfig$feeReceive2 = feeConfig === null || feeConfig === void 0 ? void 0 : feeConfig.feeReceiver) !== null && _feeConfig$feeReceive2 !== void 0 ? _feeConfig$feeReceive2 : '',\n                  isInBps: (feeConfig === null || feeConfig === void 0 ? void 0 : feeConfig.isInBps) !== undefined ? feeConfig.isInBps ? '1' : '0' : '',\n                  feeAmount: (_feeConfig$feeAmount2 = feeConfig === null || feeConfig === void 0 ? void 0 : feeConfig.feeAmount) !== null && _feeConfig$feeAmount2 !== void 0 ? _feeConfig$feeAmount2 : '',\n                  // Client data\n                  clientData: KYBERSWAP_SOURCE\n                });\n                _context2.prev = 9;\n                _context2.next = 12;\n                return fetchWaiting(\"\".concat(baseURL, \"?\").concat(search), {\n                  signal: signal,\n                  headers: {\n                    'X-Request-Id': sentryRequestId,\n                    'Accept-Version': 'Latest'\n                  }\n                }, minimumLoadingTime);\n\n              case 12:\n                response = _context2.sent;\n                _context2.next = 15;\n                return response.json();\n\n              case 15:\n                swapData = _context2.sent;\n\n                if (!(!(swapData !== null && swapData !== void 0 && swapData.inputAmount) || !(swapData !== null && swapData !== void 0 && swapData.outputAmount))) {\n                  _context2.next = 18;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", null);\n\n              case 18:\n                toCurrencyAmount = function toCurrencyAmount(value, currency) {\n                  return TokenAmount.fromRawAmount(currency, JSBI.BigInt(value));\n                };\n\n                inputAmount = toCurrencyAmount(swapData.inputAmount, currencyAmountIn.currency);\n                outputAmount = toCurrencyAmount(swapData.outputAmount, currencyOut);\n                amountInUsd = swapData.amountInUsd;\n                amountOutUsd = swapData.amountOutUsd;\n                receivedUsd = swapData.receivedUsd; // const outputPriceUSD = priceData.data[tokenOutAddress] || Object.values(priceData.data[0]) || '0'\n\n                return _context2.abrupt(\"return\", {\n                  inputAmount: inputAmount,\n                  outputAmount: outputAmount,\n                  amountInUsd: amountInUsd,\n                  amountOutUsd: amountOutUsd,\n                  receivedUsd: receivedUsd,\n                  // outputPriceUSD: parseFloat(outputPriceUSD),\n                  comparedDex: comparedDex\n                });\n\n              case 27:\n                _context2.prev = 27;\n                _context2.t0 = _context2[\"catch\"](9);\n\n                // ignore aborted request error\n                if (!(_context2.t0 !== null && _context2.t0 !== void 0 && (_e$message3 = _context2.t0.message) !== null && _e$message3 !== void 0 && _e$message3.includes('Fetch is aborted')) && !(_context2.t0 !== null && _context2.t0 !== void 0 && (_e$message4 = _context2.t0.message) !== null && _e$message4 !== void 0 && _e$message4.includes('The user aborted a request'))) {\n                  _e2 = new Error('Aggregator API (comparedDex) call failed');\n                  _e2.name = 'AggregatorAPIError';\n                  captureException(_e2, {\n                    level: 'error'\n                  });\n                }\n\n              case 30:\n                return _context2.abrupt(\"return\", null);\n\n              case 31:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[9, 27]]);\n      }));\n\n      function compareDex(_x4, _x5, _x6, _x7, _x8, _x9, _x10, _x11, _x12) {\n        return _compareDex.apply(this, arguments);\n      }\n\n      return compareDex;\n    }()\n  }]);\n\n  return Aggregator;\n}();","map":{"version":3,"names":["Fraction","Price","TokenAmount","TradeType","captureException","JSBI","invariant","DEX_TO_COMPARE","ETHER_ADDRESS","KYBERSWAP_SOURCE","sentryRequestId","fetchWaiting","Aggregator","inputAmount","outputAmount","amountInUsd","amountOutUsd","receivedUsd","swaps","tokens","tradeType","gasUsd","priceImpact","encodedSwapData","routerAddress","executionPrice","currency","quotient","slippageTolerance","lessThan","BigInt","EXACT_OUTPUT","slippageAdjustedAmountOut","add","invert","multiply","fromRawAmount","EXACT_INPUT","slippageAdjustedAmountIn","baseURL","currencyAmountIn","currencyOut","saveGas","dexes","deadline","to","feeConfig","signal","minimumLoadingTime","chainId","undefined","amountIn","tokenOut","wrapped","tokenInAddress","isNative","address","tokenOutAddress","search","URLSearchParams","tokenIn","toLowerCase","toString","gasInclude","chargeFeeBy","feeReceiver","isInBps","feeAmount","clientData","console","log","headers","response","json","result","toCurrencyAmount","value","message","includes","e","Error","name","level","comparedDex","swapData"],"sources":["/Applications/XAMPP/voxel-interface/src/utils/aggregator.ts"],"sourcesContent":["import {\n  ChainId,\n  Currency,\n  CurrencyAmount,\n  Fraction,\n  Percent,\n  Price,\n  TokenAmount,\n  TradeType,\n} from '@kyberswap/ks-sdk-core'\nimport { captureException } from '@sentry/react'\nimport JSBI from 'jsbi'\nimport invariant from 'tiny-invariant'\n\nimport { DEX_TO_COMPARE } from 'constants/dexes'\nimport { ETHER_ADDRESS, KYBERSWAP_SOURCE, sentryRequestId } from 'constants/index'\nimport { FeeConfig } from 'hooks/useSwapV2Callback'\nimport { AggregationComparer } from 'state/swap/types'\n\nimport fetchWaiting from './fetchWaiting'\n\n/**\n */\nexport class Aggregator {\n  /**\n   * The type of the trade, either exact in or exact out.\n   */\n  public readonly tradeType: TradeType\n  /**\n   * The input amount for the trade assuming no slippage.\n   */\n  public readonly inputAmount: CurrencyAmount<Currency>\n  /**\n   * The output amount for the trade assuming no slippage.\n   */\n  public readonly outputAmount: CurrencyAmount<Currency>\n  /**\n   */\n  public readonly swaps: any[][]\n  /**\n   */\n  public readonly tokens: any\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public readonly executionPrice: Price<Currency, Currency>\n\n  public readonly amountInUsd: number\n  public readonly amountOutUsd: number\n  public readonly receivedUsd: number\n  public readonly gasUsd: number\n  // -1 mean can not get price of token => can not calculate price impact\n  public readonly priceImpact: number\n  public readonly encodedSwapData: string\n  public readonly routerAddress: string\n\n  public constructor(\n    inputAmount: CurrencyAmount<Currency>,\n    outputAmount: CurrencyAmount<Currency>,\n    amountInUsd: number,\n    amountOutUsd: number,\n    receivedUsd: number,\n    swaps: any[][],\n    tokens: any,\n    tradeType: TradeType,\n    gasUsd: number,\n    priceImpact: number,\n    encodedSwapData: string,\n    routerAddress: string,\n  ) {\n    this.tradeType = tradeType\n    this.inputAmount = inputAmount\n    this.outputAmount = outputAmount\n    this.amountInUsd = amountInUsd\n    this.amountOutUsd = amountOutUsd\n    this.receivedUsd = receivedUsd\n    this.executionPrice = new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.inputAmount.quotient,\n      this.outputAmount.quotient,\n    )\n    this.swaps = swaps\n    this.tokens = tokens\n    this.gasUsd = gasUsd\n    this.priceImpact = priceImpact\n    this.encodedSwapData = encodedSwapData\n    this.routerAddress = routerAddress\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public minimumAmountOut(slippageTolerance: Percent): CurrencyAmount<Currency> {\n    invariant(!slippageTolerance.lessThan(JSBI.BigInt(0)), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return this.outputAmount\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(JSBI.BigInt(1))\n        .add(slippageTolerance)\n        .invert()\n        .multiply(this.outputAmount.quotient).quotient\n      return TokenAmount.fromRawAmount(this.outputAmount.currency, slippageAdjustedAmountOut)\n    }\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public maximumAmountIn(slippageTolerance: Percent): CurrencyAmount<Currency> {\n    invariant(!slippageTolerance.lessThan(JSBI.BigInt(0)), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return this.inputAmount\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(JSBI.BigInt(1))\n        .add(slippageTolerance)\n        .multiply(this.inputAmount.quotient).quotient\n      return TokenAmount.fromRawAmount(this.inputAmount.currency, slippageAdjustedAmountIn)\n    }\n  }\n\n  /**\n   * @param baseURL\n   * @param currencyAmountIn exact amount of input currency to spend\n   * @param currencyOut the desired currency out\n   * @param saveGas\n   * @param dexes\n   * @param slippageTolerance\n   * @param deadline\n   * @param to\n   * @param feeConfig\n   * @param signal\n   * @param minimumLoadingTime\n   */\n  public static async bestTradeExactIn(\n    baseURL: string,\n    currencyAmountIn: CurrencyAmount<Currency>,\n    currencyOut: Currency,\n    saveGas = false,\n    dexes = '',\n    slippageTolerance: number,\n    deadline: number | undefined,\n    to: string,\n    feeConfig: FeeConfig | undefined,\n    signal: AbortSignal,\n    minimumLoadingTime: number,\n  ): Promise<Aggregator | null> {\n    const chainId: ChainId | undefined = currencyAmountIn.currency.chainId || currencyOut.chainId\n\n    invariant(chainId !== undefined, 'CHAIN_ID')\n\n    const amountIn = currencyAmountIn\n    const tokenOut = currencyOut.wrapped\n\n    const tokenInAddress = currencyAmountIn.currency.isNative ? ETHER_ADDRESS : amountIn.currency.wrapped.address\n    const tokenOutAddress = currencyOut.isNative ? ETHER_ADDRESS : tokenOut.address\n    if (tokenInAddress && tokenOutAddress) {\n      const search = new URLSearchParams({\n        // Trade config\n        tokenIn: tokenInAddress.toLowerCase(),\n        tokenOut: tokenOutAddress.toLowerCase(),\n        amountIn: currencyAmountIn.quotient?.toString(),\n        saveGas: saveGas ? '1' : '0',\n        gasInclude: saveGas ? '1' : '0',\n        ...(dexes ? { dexes } : {}),\n        slippageTolerance: slippageTolerance?.toString() ?? '',\n        deadline: deadline?.toString() ?? '',\n        to,\n\n        // Fee config\n        chargeFeeBy: feeConfig?.chargeFeeBy ?? '',\n        feeReceiver: feeConfig?.feeReceiver ?? '',\n        isInBps: feeConfig?.isInBps !== undefined ? (feeConfig.isInBps ? '1' : '0') : '',\n        feeAmount: feeConfig?.feeAmount ?? '',\n\n        // Client data\n        clientData: KYBERSWAP_SOURCE,\n      })\n      try {\n\n        console.log(\"ddddd\", `${baseURL}?${search}`)\n        const response = await fetchWaiting(\n          `${baseURL}?${search}`,\n          {\n            signal,\n            headers: {\n              'X-Request-Id': sentryRequestId,\n              'Accept-Version': 'Latest',\n            },\n          },\n          minimumLoadingTime,\n        )\n        const result = await response.json()\n        if (\n          !result?.inputAmount ||\n          !result?.outputAmount ||\n          result.inputAmount === '0' ||\n          result.outputAmount === '0'\n        ) {\n          return null\n        }\n\n        const toCurrencyAmount = function (value: string, currency: Currency): CurrencyAmount<Currency> {\n          return TokenAmount.fromRawAmount(currency, JSBI.BigInt(value))\n        }\n\n        const outputAmount = toCurrencyAmount(result.outputAmount, currencyOut)\n\n        const priceImpact = !result.amountOutUsd\n          ? -1\n          : ((-result.amountOutUsd + result.amountInUsd) * 100) / result.amountInUsd\n\n        const { encodedSwapData, routerAddress } = result\n\n        return new Aggregator(\n          currencyAmountIn,\n          outputAmount,\n          result.amountInUsd,\n          result.amountOutUsd,\n          result.receivedUsd,\n          result.swaps || [],\n          result.tokens || {},\n          TradeType.EXACT_INPUT,\n          result.gasUsd,\n          priceImpact,\n          encodedSwapData,\n          routerAddress,\n        )\n      } catch (e) {\n        // ignore aborted request error\n        if (!e?.message?.includes('Fetch is aborted') && !e?.message?.includes('The user aborted a request')) {\n          const e = new Error('Aggregator API call failed')\n          e.name = 'AggregatorAPIError'\n          captureException(e, { level: 'error' })\n        }\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * @param baseURL\n   * @param currencyAmountIn exact amount of input currency to spend\n   * @param currencyOut the desired currency out\n   * @param slippageTolerance\n   * @param deadline\n   * @param to\n   * @param feeConfig\n   * @param signal\n   * @param minimumLoadingTime\n   */\n  public static async compareDex(\n    baseURL: string,\n    currencyAmountIn: CurrencyAmount<Currency>,\n    currencyOut: Currency,\n    slippageTolerance: number,\n    deadline: number | undefined,\n    to: string,\n    feeConfig: FeeConfig | undefined,\n    signal: AbortSignal,\n    minimumLoadingTime: number,\n  ): Promise<AggregationComparer | null> {\n    const chainId: ChainId | undefined = currencyAmountIn.currency.chainId || currencyOut.chainId\n    invariant(chainId !== undefined, 'CHAIN_ID')\n\n    const amountIn = currencyAmountIn\n    const tokenOut = currencyOut.wrapped\n\n    const tokenInAddress = currencyAmountIn.currency.isNative ? ETHER_ADDRESS : amountIn.currency.wrapped.address\n    const tokenOutAddress = currencyOut.isNative ? ETHER_ADDRESS : tokenOut.address\n    const comparedDex = DEX_TO_COMPARE[chainId]\n\n    if (tokenInAddress && tokenOutAddress && comparedDex) {\n      const search = new URLSearchParams({\n        // Trade config\n        tokenIn: tokenInAddress.toLowerCase(),\n        tokenOut: tokenOutAddress.toLowerCase(),\n        amountIn: currencyAmountIn.quotient?.toString(),\n        saveGas: '0',\n        gasInclude: '1',\n        dexes: comparedDex,\n        slippageTolerance: slippageTolerance?.toString() ?? '',\n        deadline: deadline?.toString() ?? '',\n        to,\n\n        // Fee config\n        chargeFeeBy: feeConfig?.chargeFeeBy ?? '',\n        feeReceiver: feeConfig?.feeReceiver ?? '',\n        isInBps: feeConfig?.isInBps !== undefined ? (feeConfig.isInBps ? '1' : '0') : '',\n        feeAmount: feeConfig?.feeAmount ?? '',\n\n        // Client data\n        clientData: KYBERSWAP_SOURCE,\n      })\n      try {\n        const response = await fetchWaiting(\n          `${baseURL}?${search}`,\n          {\n            signal,\n            headers: {\n              'X-Request-Id': sentryRequestId,\n              'Accept-Version': 'Latest',\n            },\n          },\n          minimumLoadingTime,\n        )\n        const swapData = await response.json()\n\n        if (!swapData?.inputAmount || !swapData?.outputAmount) {\n          return null\n        }\n\n        const toCurrencyAmount = function (value: string, currency: Currency): CurrencyAmount<Currency> {\n          return TokenAmount.fromRawAmount(currency, JSBI.BigInt(value))\n        }\n\n        const inputAmount = toCurrencyAmount(swapData.inputAmount, currencyAmountIn.currency)\n        const outputAmount = toCurrencyAmount(swapData.outputAmount, currencyOut)\n        const amountInUsd = swapData.amountInUsd\n        const amountOutUsd = swapData.amountOutUsd\n        const receivedUsd = swapData.receivedUsd\n\n        // const outputPriceUSD = priceData.data[tokenOutAddress] || Object.values(priceData.data[0]) || '0'\n        return {\n          inputAmount,\n          outputAmount,\n          amountInUsd,\n          amountOutUsd,\n          receivedUsd,\n          // outputPriceUSD: parseFloat(outputPriceUSD),\n          comparedDex,\n        }\n      } catch (e) {\n        // ignore aborted request error\n        if (!e?.message?.includes('Fetch is aborted') && !e?.message?.includes('The user aborted a request')) {\n          const e = new Error('Aggregator API (comparedDex) call failed')\n          e.name = 'AggregatorAPIError'\n          captureException(e, { level: 'error' })\n        }\n      }\n    }\n\n    return null\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}