{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethereum_types_1 = require(\"ethereum-types\");\n\nvar ethUtil = require(\"ethereumjs-util\");\n\nvar configured_bignumber_1 = require(\"../../configured_bignumber\");\n\nvar blob_1 = require(\"../abstract_data_types/types/blob\");\n\nvar constants_1 = require(\"../utils/constants\");\n\nvar BoolDataType =\n/** @class */\nfunction (_super) {\n  __extends(BoolDataType, _super);\n\n  function BoolDataType(dataItem, dataTypeFactory) {\n    var _this = _super.call(this, dataItem, dataTypeFactory, BoolDataType._SIZE_KNOWN_AT_COMPILE_TIME) || this;\n\n    if (!BoolDataType.matchType(dataItem.type)) {\n      throw new Error(\"Tried to instantiate Bool with bad input: \" + dataItem);\n    }\n\n    return _this;\n  }\n\n  BoolDataType.matchType = function (type) {\n    return type === ethereum_types_1.SolidityTypes.Bool;\n  }; // Disable prefer-function-over-method for inherited abstract methods.\n\n  /* tslint:disable prefer-function-over-method */\n\n\n  BoolDataType.prototype.encodeValue = function (value) {\n    var encodedValue = value ? '0x1' : '0x0';\n    var encodedValueBuf = ethUtil.setLengthLeft(ethUtil.toBuffer(encodedValue), constants_1.constants.EVM_WORD_WIDTH_IN_BYTES);\n    return encodedValueBuf;\n  };\n\n  BoolDataType.prototype.decodeValue = function (calldata) {\n    var valueBuf = calldata.popWord();\n    var valueHex = ethUtil.bufferToHex(valueBuf); // Hack @hysz: there are some cases where `false` is encoded as 0x instead of 0x0.\n\n    var valueNumber = valueHex === '0x' ? new configured_bignumber_1.BigNumber(0) : new configured_bignumber_1.BigNumber(valueHex, constants_1.constants.HEX_BASE);\n\n    if (!(valueNumber.isEqualTo(0) || valueNumber.isEqualTo(1))) {\n      throw new Error(\"Failed to decode boolean. Expected 0x0 or 0x1, got \" + valueHex);\n    }\n    /* tslint:disable boolean-naming */\n\n\n    var value = !valueNumber.isEqualTo(0);\n    /* tslint:enable boolean-naming */\n\n    return value;\n  };\n\n  BoolDataType.prototype.getDefaultValue = function () {\n    return BoolDataType._DEFAULT_VALUE;\n  };\n\n  BoolDataType.prototype.getSignatureType = function () {\n    return ethereum_types_1.SolidityTypes.Bool;\n  };\n\n  BoolDataType._SIZE_KNOWN_AT_COMPILE_TIME = true;\n  BoolDataType._DEFAULT_VALUE = false;\n  return BoolDataType;\n}(blob_1.AbstractBlobDataType);\n\nexports.BoolDataType = BoolDataType;","map":null,"metadata":{},"sourceType":"script"}