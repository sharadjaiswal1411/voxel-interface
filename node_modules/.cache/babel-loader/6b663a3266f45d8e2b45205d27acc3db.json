{"ast":null,"code":"import React from 'react';\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar GestureFlag;\n\n(function (GestureFlag) {\n  GestureFlag[\"OnStart\"] = \"start\";\n  GestureFlag[\"OnChange\"] = \"change\";\n  GestureFlag[\"OnEnd\"] = \"end\";\n})(GestureFlag || (GestureFlag = {})); // blank function\n\n\nvar noop = function noop() {}; // returns a function that chains all functions given as parameters\n\n\nvar chainFns = function chainFns() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return fns.forEach(function (fn) {\n      return fn.apply(void 0, args);\n    });\n  };\n}; // vector add\n\n\nvar addV = function addV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v + v2[i];\n  });\n}; // vector substract\n\n\nvar subV = function subV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v - v2[i];\n  });\n};\n\nvar setListeners = function setListeners(add) {\n  return function (el, listeners, options) {\n    var action = add ? 'addEventListener' : 'removeEventListener';\n    listeners.forEach(function (_ref) {\n      var type = _ref[0],\n          fn = _ref[1];\n      return el[action](type, fn, options);\n    });\n  };\n};\n\nvar addListeners = /*#__PURE__*/setListeners(true);\nvar removeListeners = /*#__PURE__*/setListeners(false);\n/**\r\n * Gets modifier keys from event\r\n * @param event\r\n * @returns modifier keys\r\n */\n\nfunction getModifierKeys(event) {\n  var shiftKey = event.shiftKey,\n      altKey = event.altKey,\n      metaKey = event.metaKey,\n      ctrlKey = event.ctrlKey;\n  return {\n    shiftKey: shiftKey,\n    altKey: altKey,\n    metaKey: metaKey,\n    ctrlKey: ctrlKey\n  };\n}\n/**\r\n * Gets scroll event data\r\n * @param event\r\n * @returns scroll event data\r\n */\n\n\nfunction getScrollEventData(event) {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  var _event$currentTarget = event.currentTarget,\n      scrollX = _event$currentTarget.scrollX,\n      scrollY = _event$currentTarget.scrollY,\n      scrollLeft = _event$currentTarget.scrollLeft,\n      scrollTop = _event$currentTarget.scrollTop;\n  return _extends({\n    xy: [scrollX || scrollLeft || 0, scrollY || scrollTop || 0]\n  }, getModifierKeys(event));\n}\n/**\r\n * Gets wheel event data\r\n * @param event\r\n * @returns wheel event data\r\n */\n\n\nfunction getWheelEventData(event) {\n  var deltaX = event.deltaX,\n      deltaY = event.deltaY; //TODO implement polyfill ?\n  // https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Polyfill\n\n  return _extends({\n    xy: [deltaX, deltaY]\n  }, getModifierKeys(event));\n}\n/**\r\n * Gets pointer event data\r\n * @param event\r\n * @returns pointer event data\r\n */\n\n\nfunction getPointerEventData(event) {\n  var touches = event.touches,\n      buttons = event.buttons,\n      changedTouches = event.changedTouches;\n  var touchEvents = touches && touches.length > 0 ? touches : changedTouches && changedTouches.length > 0 ? changedTouches : null;\n\n  var _ref2 = touchEvents ? touchEvents[0] : event,\n      clientX = _ref2.clientX,\n      clientY = _ref2.clientY;\n\n  var down = touchEvents && touchEvents.length > 0 || buttons > 0;\n  return _extends({\n    xy: [clientX, clientY],\n    touches: touchEvents && touchEvents.length || 0,\n    down: down,\n    buttons: buttons\n  }, getModifierKeys(event));\n}\n/**\r\n * Gets two touches event data\r\n * @param event\r\n * @returns two touches event data\r\n */\n\n\nfunction getTwoTouchesEventData(event) {\n  var touches = event.touches;\n  var dx = touches[1].clientX - touches[0].clientX;\n  var dy = touches[1].clientY - touches[0].clientY;\n  var da = [Math.hypot(dx, dy), -(Math.atan2(dx, dy) * 180) / Math.PI];\n  var origin = [(touches[1].clientX + touches[0].clientX) / 2, (touches[1].clientY + touches[0].clientY) / 2];\n  return _extends({\n    da: da,\n    origin: origin,\n    touches: 2,\n    down: touches.length > 0\n  }, getModifierKeys(event));\n}\n/**\r\n * Calculates velocity\r\n * @param delta the difference between current and previous vectors\r\n * @param delta_t the time offset\r\n * @param len the length of the delta vector\r\n * @returns velocity\r\n */\n\n\nfunction calculateVelocity(delta, delta_t, len) {\n  len = len || Math.hypot.apply(Math, delta);\n  return delta_t ? len / delta_t : 0;\n}\n/**\r\n * Calculates velocities vector\r\n * @template T the expected vector type\r\n * @param delta the difference between current and previous vectors\r\n * @param delta_t the time offset\r\n * @returns velocities vector\r\n */\n\n\nfunction calculateVelocities(delta, delta_t) {\n  return delta_t ? delta.map(function (v) {\n    return v / delta_t;\n  }) : Array(delta.length).fill(0);\n}\n/**\r\n * Calculates distance\r\n * @param movement the difference between current and initial vectors\r\n * @returns distance\r\n */\n\n\nfunction calculateDistance(movement) {\n  return Math.hypot.apply(Math, movement);\n}\n/**\r\n * Calculates direction\r\n * @template T the expected vector type\r\n * @param delta\r\n * @param len\r\n * @returns direction\r\n */\n\n\nfunction calculateDirection(delta, len) {\n  len = len || Math.hypot.apply(Math, delta) || 1;\n  return delta.map(function (v) {\n    return v / len;\n  });\n}\n/**\r\n * Calculates all kinematics\r\n * @template T the expected vector type\r\n * @param movement the difference between current and initial vectors\r\n * @param delta the difference between current and previous vectors\r\n * @param delta_t the time difference between current and previous timestamps\r\n * @returns all kinematics\r\n */\n\n\nfunction calculateAllKinematics(movement, delta, delta_t) {\n  var len = Math.hypot.apply(Math, delta);\n  return {\n    velocities: calculateVelocities(delta, delta_t),\n    velocity: calculateVelocity(delta, delta_t, len),\n    distance: calculateDistance(movement),\n    direction: calculateDirection(delta, len)\n  };\n}\n/**\r\n * Whether the browser supports GestureEvent (ie Safari)\r\n * @returns true if the browser supports gesture event\r\n */\n\n\nfunction gestureEventSupported() {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: Unreachable code error\n    return 'constructor' in GestureEvent;\n  } catch (e) {\n    return false;\n  }\n}\n/**\r\n * Some gestures might use the state key from another gesture (i.e. hover)\r\n * so mappedKeys is a commodity object to get the state key and handler key\r\n * for every gesture\r\n */\n\n\nvar mappedKeys = {\n  drag: {\n    stateKey: 'drag',\n    handlerKey: 'onDrag'\n  },\n  pinch: {\n    stateKey: 'pinch',\n    handlerKey: 'onPinch'\n  },\n  move: {\n    stateKey: 'move',\n    handlerKey: 'onMove'\n  },\n  scroll: {\n    stateKey: 'scroll',\n    handlerKey: 'onScroll'\n  },\n  wheel: {\n    stateKey: 'wheel',\n    handlerKey: 'onWheel'\n  },\n  hover: {\n    stateKey: 'move',\n    handlerKey: 'onHover'\n  }\n}; // default config (will extend user config)\n\nvar defaultConfig = {\n  domTarget: undefined,\n  event: {\n    passive: true,\n    capture: false\n  },\n  window: typeof window !== 'undefined' ? window : undefined,\n  dragDelay: false,\n  passiveEvents: true,\n  pointerEvents: false,\n  enabled: true,\n  drag: true,\n  pinch: true,\n  scroll: true,\n  wheel: true,\n  hover: true,\n  move: true\n}; // common initial state for all gestures\n\nvar initialCommon = {\n  event: undefined,\n  currentTarget: undefined,\n  pointerId: undefined,\n  values: [0, 0],\n  delta: [0, 0],\n  movement: [0, 0],\n  offset: [0, 0],\n  direction: [0, 0],\n  initial: [0, 0],\n  previous: [0, 0],\n  first: false,\n  last: false,\n  active: false,\n  time: undefined,\n  cancel: noop,\n  canceled: false,\n  memo: undefined,\n  args: undefined\n}; // initial state for coordinates-based gestures\n\nvar initialCoordinates = {\n  xy: [0, 0],\n  vxvy: [0, 0],\n  velocity: 0,\n  distance: 0\n}; // xy coordinates\n// initial state for distance and angle-based gestures (pinch)\n\nvar initialDistanceAngle = {\n  da: [0, 0],\n  vdva: [0, 0],\n  origin: undefined,\n  turns: 0\n}; // distance and angle\n// initial state object (used by the gesture controller)\n\nvar initialState = {\n  shared: {\n    hovering: false,\n    scrolling: false,\n    wheeling: false,\n    dragging: false,\n    moving: false,\n    pinching: false,\n    touches: 0,\n    buttons: 0,\n    down: false,\n    shiftKey: false,\n    altKey: false,\n    metaKey: false,\n    ctrlKey: false\n  },\n  move: /*#__PURE__*/_extends({}, initialCommon, {}, initialCoordinates),\n  drag: /*#__PURE__*/_extends({}, initialCommon, {}, initialCoordinates),\n  scroll: /*#__PURE__*/_extends({}, initialCommon, {}, initialCoordinates),\n  wheel: /*#__PURE__*/_extends({}, initialCommon, {}, initialCoordinates),\n  pinch: /*#__PURE__*/_extends({}, initialCommon, {}, initialDistanceAngle)\n}; // generic end state for all gestures\n\nvar genericEndState = {\n  first: false,\n  last: true,\n  active: false\n};\n/**\r\n * Recognizer abstract class\r\n * @template GestureType whether the Recognizer should deal with coordinates or distance / angle\r\n */\n\nvar Recognizer = /*#__PURE__*/function () {\n  /**\r\n   * Creates an instance of a gesture recognizer.\r\n   * @param gestureKey drag, move, hover, pinch, etc.\r\n   * @param controller the controller attached to the gesture\r\n   * @param [args] the args that should be passed to the gesture handler\r\n   */\n  function Recognizer(gestureKey, controller, args) {\n    var _this = this;\n\n    if (args === void 0) {\n      args = [];\n    }\n\n    this.gestureKey = gestureKey;\n    this.controller = controller;\n    this.args = args;\n    /**\r\n     * Continuous gestures are scroll or wheel, where the next gesture continues the previous one.\r\n     * In other words, these gestures also start with a delta.\r\n     */\n\n    this.continuousGesture = false; // convenience method to set a timeout for a given gesture\n\n    this.setTimeout = function (callback, ms) {\n      var _window;\n\n      if (ms === void 0) {\n        ms = 140;\n      }\n\n      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n\n      _this.controller.timeouts[_this.stateKey] = (_window = window).setTimeout.apply(_window, [callback, ms].concat(args));\n    }; // convenience method to clear a timeout for a given gesture\n\n\n    this.clearTimeout = function () {\n      clearTimeout(_this.controller.timeouts[_this.stateKey]);\n    }; // convenience method to add window listeners for a given gesture\n\n\n    this.addWindowListeners = function (listeners) {\n      _this.controller.addWindowListeners(_this.stateKey, listeners);\n    }; // convenience method to remove window listeners for a given gesture\n\n\n    this.removeWindowListeners = function () {\n      _this.controller.removeWindowListeners(_this.stateKey);\n    };\n    /**\r\n     * convenience method to update the controller state for a given gesture\r\n     * @param sharedState shared partial state object\r\n     * @param gestureState partial state object for the gesture handled by the recognizer\r\n     * @param [gestureFlag] if set, will also fire the gesture handler set by the user\r\n     */\n\n\n    this.updateState = function (sharedState, gestureState) {\n      _this.controller.updateState(sharedState, gestureState, _this.stateKey);\n    };\n\n    this.fireGestureHandler = function (gestureFlag) {\n      _this.controller.fireGestureHandler(_this.gestureKey, gestureFlag);\n    }; // generic onStart function\n\n\n    this.onStart = function (event, payload) {\n      var _this$getPayloadFromE = _this.getPayloadFromEvent(event),\n          values = _this$getPayloadFromE.values,\n          gesturePayload = _this$getPayloadFromE.gesturePayload,\n          sharedPayload = _this$getPayloadFromE.sharedPayload; // TODO probably needs some rework, initialState and resetState should be different\n\n\n      var startState = _extends({}, initialState[_this.stateKey], {\n        values: values,\n        event: event,\n        first: true,\n        active: true,\n        time: event.timeStamp,\n        args: _this.args\n      });\n\n      var _this$state = _this.state,\n          prevValues = _this$state.values,\n          offset = _this$state.offset;\n\n      if (_this.continuousGesture) {\n        startState.initial = startState.previous = prevValues;\n        startState.delta = startState.movement = subV(values, prevValues);\n        startState.offset = values;\n        Object.assign(startState, calculateAllKinematics(startState.movement, startState.delta, 0));\n      } else {\n        startState.initial = startState.previous = values;\n        startState.offset = offset;\n      }\n\n      _this.updateState(_extends({}, _this.sharedStartState, {}, sharedPayload), _extends({}, startState, {}, gesturePayload, {}, payload));\n\n      _this.fireGestureHandler(GestureFlag.OnStart);\n    }; // generic onChange function\n\n\n    this.onChange = function (event, payload) {\n      var _this$getPayloadFromE2 = _this.getPayloadFromEvent(event),\n          values = _this$getPayloadFromE2.values,\n          gesturePayload = _this$getPayloadFromE2.gesturePayload,\n          sharedPayload = _this$getPayloadFromE2.sharedPayload;\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateState(_extends({}, sharedPayload), _extends({\n        first: false\n      }, kinematics, {}, gesturePayload, {}, payload));\n\n      _this.fireGestureHandler(GestureFlag.OnChange);\n    }; // generic onEnd function\n\n\n    this.onEnd = function (event, payload) {\n      if (!_this.state.active) return;\n\n      _this.removeWindowListeners();\n\n      _this.updateState(_this.sharedEndState, _extends({\n        event: event\n      }, genericEndState, {}, payload));\n\n      _this.fireGestureHandler(GestureFlag.OnEnd);\n    }; // generic cancel function\n\n\n    this.onCancel = function (event) {\n      _this.updateState(null, {\n        canceled: true,\n        cancel: noop\n      });\n\n      requestAnimationFrame(function () {\n        return _this.onEnd(event);\n      });\n    }; // generic gesture handler for timeout-based gestures\n\n\n    this.timeoutHandler = function (event) {\n      if (!_this.enabled) return;\n\n      _this.clearTimeout();\n\n      _this.setTimeout(_this.onEnd);\n\n      if (!_this.state.active) _this.onStart(event);else _this.onChange(event);\n    }; // mapping this.stateKey to the state key the gesture handles\n    // (ie hover actually deals with the move gesture state)\n\n\n    this.stateKey = mappedKeys[gestureKey].stateKey;\n  } // is the gesture enabled\n\n\n  _createClass(Recognizer, [{\n    key: \"enabled\",\n    get: function get() {\n      return this.controller.config.enabled && this.controller.config[this.gestureKey];\n    } // get the controller state for a given gesture\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this.controller.state[this.stateKey];\n    }\n  }]);\n\n  return Recognizer;\n}();\n/**\r\n * Abstract class for coordinates-based gesture recongizers\r\n */\n\n\nvar CoordinatesRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(CoordinatesRecognizer, _Recognizer);\n\n  function CoordinatesRecognizer() {\n    return _Recognizer.apply(this, arguments) || this;\n  }\n\n  var _proto = CoordinatesRecognizer.prototype;\n\n  _proto.getKinematics = function getKinematics(values, event) {\n    // we get the gesture specific state\n    var _this$state = this.state,\n        xy = _this$state.values,\n        initial = _this$state.initial,\n        offset = _this$state.offset,\n        time = _this$state.time; // offset is the difference between the current and initial value vectors\n\n    var movement = subV(values, initial); // delta is the difference between the current and previous value vectors\n\n    var delta = subV(values, xy);\n    var delta_t = event.timeStamp - time;\n\n    var _calculateAllKinemati = calculateAllKinematics(movement, delta, delta_t),\n        velocity = _calculateAllKinemati.velocity,\n        velocities = _calculateAllKinemati.velocities,\n        distance = _calculateAllKinemati.distance,\n        direction = _calculateAllKinemati.direction;\n\n    return {\n      event: event,\n      values: values,\n      movement: movement,\n      offset: addV(offset, delta),\n      delta: delta,\n      velocity: velocity,\n      vxvy: velocities,\n      distance: distance,\n      direction: direction,\n      previous: xy,\n      time: event.timeStamp\n    };\n  };\n\n  return CoordinatesRecognizer;\n}(Recognizer);\n\nvar DEFAULT_DRAG_DELAY = 180;\n\nvar DragRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(DragRecognizer, _CoordinatesRecognize);\n\n  function DragRecognizer(controller, args) {\n    var _this;\n\n    _this = _CoordinatesRecognize.call(this, 'drag', controller, args) || this;\n    _this.sharedStartState = {\n      dragging: true,\n      down: true\n    };\n    _this.sharedEndState = {\n      dragging: false,\n      down: false,\n      buttons: 0,\n      touches: 0\n    };\n    _this.delayedEvent = false;\n\n    _this.onDragStart = function (event) {\n      if (!_this.enabled) return; // making sure we're not dragging the element when more than one finger press the screen\n\n      var _getPointerEventData = getPointerEventData(event),\n          touches = _getPointerEventData.touches;\n\n      if (touches > 1) return;\n      var currentTarget = event.currentTarget,\n          pointerId = event.pointerId;\n\n      if (_this.controller.config.pointerEvents) {\n        // if pointers events\n        currentTarget && currentTarget.setPointerCapture(pointerId);\n      } else {\n        _this.removeWindowListeners();\n\n        var dragListeners = [['mousemove', _this.onDragChange], ['touchmove', _this.onDragChange], ['mouseup', _this.onDragEnd], ['touchend', _this.onDragEnd], ['touchcancel', _this.onDragEnd]];\n\n        _this.addWindowListeners(dragListeners);\n      }\n\n      if (_this.controller.config.dragDelay) {\n        var dragDelay = typeof _this.controller.config.dragDelay === 'number' ? _this.controller.config.dragDelay : DEFAULT_DRAG_DELAY;\n        if (typeof event.persist === 'function') event.persist();\n        _this.delayedEvent = true;\n\n        _this.setTimeout(function () {\n          return _this.startDrag(event);\n        }, dragDelay);\n      } else {\n        _this.startDrag(event);\n      }\n    };\n\n    _this.startDrag = function (event) {\n      var currentTarget = event.currentTarget,\n          pointerId = event.pointerId;\n\n      _this.onStart(event, {\n        currentTarget: currentTarget,\n        pointerId: pointerId,\n        cancel: function cancel() {\n          return _this.onCancel(event);\n        }\n      });\n\n      _this.delayedEvent = false;\n    };\n\n    _this.onDragChange = function (event) {\n      var _this$state = _this.state,\n          canceled = _this$state.canceled,\n          active = _this$state.active;\n      if (canceled) return;\n\n      if (!active) {\n        if (_this.delayedEvent) {\n          _this.clearTimeout();\n\n          _this.startDrag(event);\n        }\n\n        return;\n      }\n\n      var _getPointerEventData2 = getPointerEventData(event),\n          buttons = _getPointerEventData2.buttons,\n          touches = _getPointerEventData2.touches;\n\n      if (buttons === 0 && touches === 0) {\n        _this.onEnd(event);\n\n        return;\n      }\n\n      _this.onChange(event, {\n        cancel: function cancel() {\n          return _this.onCancel(event);\n        }\n      });\n    };\n\n    _this.onDragEnd = function (event) {\n      _this.clearTimeout();\n\n      _this.delayedEvent = false;\n      if (!_this.state.active) return;\n      var _this$state2 = _this.state,\n          currentTarget = _this$state2.currentTarget,\n          pointerId = _this$state2.pointerId;\n      if (currentTarget && _this.controller.config.pointerEvents) currentTarget.releasePointerCapture(pointerId);\n\n      _this.onEnd(event);\n    };\n\n    return _this;\n  }\n\n  var _proto = DragRecognizer.prototype;\n\n  _proto.getPayloadFromEvent = function getPayloadFromEvent(event) {\n    var _getPointerEventData3 = getPointerEventData(event),\n        xy = _getPointerEventData3.xy,\n        sharedPayload = _objectWithoutPropertiesLoose(_getPointerEventData3, [\"xy\"]);\n\n    return {\n      values: xy,\n      sharedPayload: sharedPayload\n    };\n  };\n\n  _proto.getEventBindings = function getEventBindings() {\n    if (this.controller.config.pointerEvents) {\n      return [['onPointerDown', this.onDragStart], ['onPointerMove', this.onDragChange], [['onPointerUp'], this.onDragEnd]];\n    }\n\n    return [[['onMouseDown', 'onTouchStart'], this.onDragStart]];\n  };\n\n  return DragRecognizer;\n}(CoordinatesRecognizer);\n\nvar ScrollRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(ScrollRecognizer, _CoordinatesRecognize);\n\n  function ScrollRecognizer(controller, args) {\n    var _this;\n\n    _this = _CoordinatesRecognize.call(this, 'scroll', controller, args) || this;\n    _this.sharedStartState = {\n      scrolling: true\n    };\n    _this.sharedEndState = {\n      scrolling: false,\n      velocity: 0,\n      vxvy: [0, 0]\n    };\n    _this.continuousGesture = true;\n    return _this;\n  }\n\n  var _proto = ScrollRecognizer.prototype;\n\n  _proto.getPayloadFromEvent = function getPayloadFromEvent(event) {\n    var _getScrollEventData = getScrollEventData(event),\n        xy = _getScrollEventData.xy,\n        sharedPayload = _objectWithoutPropertiesLoose(_getScrollEventData, [\"xy\"]);\n\n    return {\n      values: xy,\n      sharedPayload: sharedPayload\n    };\n  };\n\n  _proto.getEventBindings = function getEventBindings() {\n    return [['onScroll', this.timeoutHandler]];\n  };\n\n  return ScrollRecognizer;\n}(CoordinatesRecognizer);\n\nvar WheelRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(WheelRecognizer, _CoordinatesRecognize);\n\n  function WheelRecognizer(controller, args) {\n    var _this;\n\n    _this = _CoordinatesRecognize.call(this, 'wheel', controller, args) || this;\n    _this.sharedStartState = {\n      wheeling: true\n    };\n    _this.sharedEndState = {\n      wheeling: false,\n      velocity: 0,\n      vxvy: [0, 0]\n    };\n    _this.continuousGesture = true;\n\n    _this.onWheel = function (event) {\n      if (event.ctrlKey && _this.controller.actions.has('onPinch')) return;\n\n      _this.timeoutHandler(event);\n    };\n\n    return _this;\n  }\n\n  var _proto = WheelRecognizer.prototype;\n\n  _proto.getPayloadFromEvent = function getPayloadFromEvent(event) {\n    var prevXY = this.state.xy;\n\n    var _getWheelEventData = getWheelEventData(event),\n        xy = _getWheelEventData.xy,\n        sharedPayload = _objectWithoutPropertiesLoose(_getWheelEventData, [\"xy\"]);\n\n    var values = addV(xy, prevXY);\n    return {\n      values: values,\n      sharedPayload: sharedPayload\n    };\n  };\n\n  _proto.getEventBindings = function getEventBindings() {\n    return [['onWheel', this.onWheel]];\n  };\n\n  return WheelRecognizer;\n}(CoordinatesRecognizer);\n\nvar MoveRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(MoveRecognizer, _CoordinatesRecognize);\n\n  function MoveRecognizer(controller, args) {\n    var _this;\n\n    _this = _CoordinatesRecognize.call(this, 'move', controller, args) || this;\n    _this.sharedStartState = {\n      moving: true\n    };\n    _this.sharedEndState = {\n      moving: false,\n      velocity: 0,\n      vxvy: [0, 0]\n    };\n    return _this;\n  }\n\n  var _proto = MoveRecognizer.prototype;\n\n  _proto.getPayloadFromEvent = function getPayloadFromEvent(event) {\n    var _getPointerEventData = getPointerEventData(event),\n        xy = _getPointerEventData.xy,\n        sharedPayload = _objectWithoutPropertiesLoose(_getPointerEventData, [\"xy\"]);\n\n    return {\n      values: xy,\n      sharedPayload: sharedPayload\n    };\n  };\n\n  _proto.getEventBindings = function getEventBindings() {\n    if (this.controller.config.pointerEvents) {\n      return [['onPointerMove', this.timeoutHandler]];\n    }\n\n    return [['onMouseMove', this.timeoutHandler]];\n  };\n\n  return MoveRecognizer;\n}(CoordinatesRecognizer);\n\nvar HoverRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(HoverRecognizer, _CoordinatesRecognize);\n\n  function HoverRecognizer(controller, args) {\n    var _this;\n\n    _this = _CoordinatesRecognize.call(this, 'hover', controller, args) || this;\n\n    _this.onPointerEnter = function (event) {\n      if (!_this.enabled) return;\n\n      var _this$getPayloadFromE = _this.getPayloadFromEvent(event),\n          values = _this$getPayloadFromE.values,\n          sharedPayload = _this$getPayloadFromE.sharedPayload;\n\n      _this.updateState(_extends({\n        hovering: true\n      }, sharedPayload), {\n        values: values,\n        event: event,\n        args: _this.args\n      });\n\n      _this.fireGestureHandler(GestureFlag.OnChange);\n    };\n\n    _this.onPointerLeave = function (event) {\n      if (!_this.enabled) return;\n\n      var _this$getPayloadFromE2 = _this.getPayloadFromEvent(event),\n          values = _this$getPayloadFromE2.values,\n          sharedPayload = _this$getPayloadFromE2.sharedPayload;\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateState(_extends({\n        hovering: false,\n        moving: false\n      }, sharedPayload), _extends({}, kinematics, {}, genericEndState, {\n        velocity: 0,\n        vxvy: [0, 0]\n      })); // when the mouse leaves the element, we also fire the move handler\n      // without waiting for move to end with debounce\n\n\n      _this.controller.fireGestureHandler('move', GestureFlag.OnEnd);\n\n      _this.controller.fireGestureHandler('hover', GestureFlag.OnChange);\n    };\n\n    return _this;\n  }\n\n  var _proto = HoverRecognizer.prototype;\n\n  _proto.getPayloadFromEvent = function getPayloadFromEvent(event) {\n    var _getPointerEventData = getPointerEventData(event),\n        xy = _getPointerEventData.xy,\n        sharedPayload = _objectWithoutPropertiesLoose(_getPointerEventData, [\"xy\"]);\n\n    return {\n      values: xy,\n      sharedPayload: sharedPayload\n    };\n  };\n\n  _proto.getEventBindings = function getEventBindings() {\n    if (this.controller.config.pointerEvents) {\n      return [['onPointerEnter', this.onPointerEnter], ['onPointerLeave', this.onPointerLeave]];\n    }\n\n    return [['onMouseEnter', this.onPointerEnter], ['onMouseLeave', this.onPointerLeave]];\n  };\n\n  return HoverRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * Abstract class for distance/angle-based gesture recongizers\r\n */\n\n\nvar DistanceAngleRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(DistanceAngleRecognizer, _Recognizer);\n\n  function DistanceAngleRecognizer(gestureKey, controller, args) {\n    if (args === void 0) {\n      args = [];\n    }\n\n    return _Recognizer.call(this, gestureKey, controller, args) || this;\n  }\n\n  var _proto = DistanceAngleRecognizer.prototype;\n\n  _proto.getKinematics = function getKinematics(_ref, event) {\n    var d = _ref[0],\n        a = _ref[1];\n    var _this$state = this.state,\n        da = _this$state.values,\n        turns = _this$state.turns,\n        initial = _this$state.initial,\n        offset = _this$state.offset,\n        time = _this$state.time; // angle might not be defined when ctrl wheel is used for zoom only\n    // in that case we set it to the previous angle value\n\n    a = a !== void 0 ? a : da[1];\n    var delta_d = d - da[0];\n    var delta_a = a - da[1];\n    /**\r\n     * The angle value might jump from 179deg to -179deg when we actually want to\r\n     * read 181deg to ensure continuity. To make that happen, we detect when the jump\r\n     * is supsiciously high (ie > 270deg) and increase the `turns` value\r\n     */\n\n    var newTurns = Math.abs(delta_a) > 270 ? turns + Math.sign(delta_a) : turns; // we update the angle difference to its corrected value\n\n    delta_a -= 360 * (newTurns - turns);\n    var delta = [delta_d, delta_a];\n    var movement_d = d - initial[0];\n    var movement_a = a - 360 * newTurns - initial[1];\n    var movement = [movement_d, movement_a];\n    var delta_t = event.timeStamp - time;\n    var vdva = calculateVelocities(delta, delta_t);\n    var direction = calculateDirection(delta);\n    return {\n      event: event,\n      values: [d, a],\n      movement: movement,\n      delta: delta,\n      offset: addV(offset, delta),\n      vdva: vdva,\n      direction: direction,\n      turns: newTurns,\n      previous: da,\n      time: event.timeStamp\n    };\n  };\n\n  return DistanceAngleRecognizer;\n}(Recognizer);\n\nvar PinchRecognizer = /*#__PURE__*/function (_DistanceAngleRecogni) {\n  _inheritsLoose(PinchRecognizer, _DistanceAngleRecogni);\n\n  function PinchRecognizer(controller, args) {\n    var _this;\n\n    _this = _DistanceAngleRecogni.call(this, 'pinch', controller, args) || this;\n    _this.sharedStartState = {\n      pinching: true\n    };\n    _this.sharedEndState = {\n      pinching: false,\n      down: false,\n      touches: 0\n    };\n\n    _this.onPinchStart = function (event) {\n      if (!_this.enabled || event.touches.length !== 2) return;\n\n      _this.onStart(event, {\n        cancel: function cancel() {\n          return _this.onCancel(event);\n        }\n      });\n    };\n\n    _this.onPinchChange = function (event) {\n      var _this$state = _this.state,\n          canceled = _this$state.canceled,\n          active = _this$state.active,\n          time = _this$state.time;\n      if (canceled || !active || event.touches.length !== 2 || event.timeStamp === time) return;\n\n      _this.onChange(event, {\n        cancel: function cancel() {\n          return _this.onCancel(event);\n        }\n      });\n    };\n\n    return _this;\n  }\n\n  var _proto = PinchRecognizer.prototype;\n\n  _proto.getPayloadFromEvent = function getPayloadFromEvent(event) {\n    var _getTwoTouchesEventDa = getTwoTouchesEventData(event),\n        da = _getTwoTouchesEventDa.da,\n        origin = _getTwoTouchesEventDa.origin,\n        sharedPayload = _objectWithoutPropertiesLoose(_getTwoTouchesEventDa, [\"da\", \"origin\"]);\n\n    return {\n      values: da,\n      gesturePayload: {\n        origin: origin\n      },\n      sharedPayload: sharedPayload\n    };\n  };\n\n  _proto.getEventBindings = function getEventBindings() {\n    return [['onTouchStart', this.onPinchStart], ['onTouchMove', this.onPinchChange], [['onTouchEnd', 'onTouchCancel'], this.onEnd]];\n  };\n\n  return PinchRecognizer;\n}(DistanceAngleRecognizer);\n\nvar PinchWheelRecognizer = /*#__PURE__*/function (_DistanceAngleRecogni) {\n  _inheritsLoose(PinchWheelRecognizer, _DistanceAngleRecogni);\n\n  function PinchWheelRecognizer(controller, args) {\n    var _this;\n\n    _this = _DistanceAngleRecogni.call(this, 'pinch', controller, args) || this;\n    _this.sharedStartState = {\n      pinching: true\n    };\n    _this.sharedEndState = {\n      pinching: false\n    };\n\n    _this.onWheel = function (event) {\n      if (!event.ctrlKey) return;\n      if (!_this.controller.config.passiveEvents) event.preventDefault();else if (process.env.NODE_ENV === 'development') console.warn('To support zoom on trackpads, try using the `domTarget` option and `config.event.passive` set to `false`. This message will only appear in development mode.');\n\n      _this.timeoutHandler(event);\n    };\n\n    return _this;\n  }\n\n  var _proto = PinchWheelRecognizer.prototype;\n\n  _proto.getPayloadFromEvent = function getPayloadFromEvent(event) {\n    var _getWheelEventData = getWheelEventData(event),\n        _getWheelEventData$xy = _getWheelEventData.xy,\n        delta_d = _getWheelEventData$xy[1],\n        sharedPayload = _objectWithoutPropertiesLoose(_getWheelEventData, [\"xy\"]);\n\n    var _this$state$da = this.state.da,\n        prev_d = _this$state$da[0],\n        prev_a = _this$state$da[1];\n    var d = prev_d - delta_d;\n    var a = prev_a !== void 0 ? prev_a : 0;\n    var origin = [event.clientX, event.clientY];\n    return {\n      values: [d, a],\n      gesturePayload: {\n        origin: origin\n      },\n      sharedPayload: sharedPayload\n    };\n  };\n\n  _proto.getEventBindings = function getEventBindings() {\n    return [['onWheel', this.onWheel]];\n  };\n\n  return PinchWheelRecognizer;\n}(DistanceAngleRecognizer);\n\nvar SCALE_FACTOR = 260;\n\nvar PinchWebKitGestureRecognizer = /*#__PURE__*/function (_DistanceAngleRecogni) {\n  _inheritsLoose(PinchWebKitGestureRecognizer, _DistanceAngleRecogni);\n\n  function PinchWebKitGestureRecognizer(controller, args) {\n    var _this;\n\n    _this = _DistanceAngleRecogni.call(this, 'pinch', controller, args) || this;\n    _this.sharedStartState = {\n      pinching: true,\n      down: true,\n      touches: 2\n    };\n    _this.sharedEndState = {\n      pinching: false,\n      down: false,\n      touches: 0\n    };\n\n    _this.onPinchStart = function (event) {\n      if (!_this.enabled) return;\n      event.preventDefault();\n      var origin = _this.origin ? _this.origin : [event.clientX, event.clientY];\n\n      _this.onStart(event, {\n        origin: origin,\n        cancel: function cancel() {\n          return _this.onCancel(event);\n        }\n      });\n    };\n\n    _this.onPinchChange = function (event) {\n      var _this$state = _this.state,\n          canceled = _this$state.canceled,\n          active = _this$state.active;\n      if (canceled || !active) return;\n      event.preventDefault();\n\n      _this.onChange(event, {\n        cancel: function cancel() {\n          return _this.onCancel(event);\n        }\n      });\n    };\n\n    _this.onGestureEnd = function (event) {\n      _this.onEnd(event);\n\n      event.preventDefault();\n      _this.origin = undefined;\n    };\n\n    _this.updateTouchData = function (event) {\n      if (!_this.enabled || event.touches.length !== 2) return;\n\n      var _getTwoTouchesEventDa = getTwoTouchesEventData(event),\n          origin = _getTwoTouchesEventDa.origin;\n\n      _this.origin = origin;\n    };\n\n    return _this;\n  }\n\n  var _proto = PinchWebKitGestureRecognizer.prototype;\n\n  _proto.getPayloadFromEvent = function getPayloadFromEvent(event) {\n    return {\n      values: [event.scale * SCALE_FACTOR, event.rotation]\n    };\n  };\n\n  _proto.getEventBindings = function getEventBindings() {\n    return [['onGestureStart', this.onPinchStart], ['onGestureChange', this.onPinchChange], [['onGestureEnd', 'onTouchCancel'], this.onGestureEnd], [['onTouchStart', 'onTouchMove'], this.updateTouchData]];\n  };\n\n  return PinchWebKitGestureRecognizer;\n}(DistanceAngleRecognizer);\n/**\r\n * Gesture controller will create gesture recognizers (which handle the gesture logic)\r\n * and keep track of the state for all gestures\r\n *\r\n * @template BinderType the type the bind function should return\r\n */\n\n\nvar GestureController = function GestureController(handlers, config) {\n  var _this = this;\n\n  this.handlers = handlers;\n  this.config = config;\n  this.state = initialState; // state for all gestures\n\n  this.timeouts = {}; // keeping track of timeouts for debounced gestures (such as move, scroll, wheel)\n\n  this.bindings = {}; // an object holding the handlers associated to the gestures\n\n  this.domListeners = []; // when config.domTarget is set, we attach events directly to the dom\n\n  this.windowListeners = {}; // keeps track of window listeners added by gestures (drag only at the moment)\n\n  /**\r\n   * Function run on component unmount\r\n   * Cleans timeouts and removes dom listeners set by the bind function\r\n   */\n\n  this.clean = function () {\n    _this.cleanOnBind();\n\n    Object.values(_this.timeouts).forEach(clearTimeout);\n    Object.keys(_this.windowListeners).forEach(function (stateKey) {\n      return _this.removeWindowListeners(stateKey);\n    });\n  };\n  /**\r\n   * Function run every time the bind function is run (ie on every render)\r\n   * Reset the binding object and remove dom listeners attached to config.domTarget\r\n   */\n\n\n  this.cleanOnBind = function () {\n    _this.bindings = {};\n    var domTarget = _this.config.domTarget;\n\n    if (domTarget) {\n      removeListeners(domTarget, _this.domListeners, _this.config.event);\n      _this.domListeners = [];\n    }\n  };\n  /**\r\n   * Commodity function to let gesture recognizer update global state\r\n   * @param sharedState shared partial state object\r\n   * @param gestureState partial gesture specific state object\r\n   * @param stateKey the state key ('drag', 'move'...)\r\n   */\n\n\n  this.updateState = function (sharedState, gestureState, stateKey) {\n    var _extends2;\n\n    var newGestureState = _extends({}, _this.state[stateKey], {}, gestureState);\n\n    if ('da' in newGestureState) newGestureState.da = newGestureState.values;else if ('xy' in newGestureState) newGestureState.xy = newGestureState.values;\n    _this.state = _extends({}, _this.state, (_extends2 = {\n      shared: _extends({}, _this.state.shared, {}, sharedState)\n    }, _extends2[stateKey] = newGestureState, _extends2));\n  }; // fire the gesture handler defined by the user\n\n\n  this.fireGestureHandler = function (gestureKey, gestureFlag) {\n    // gets the state key and handler key from the gesture key\n    // gestureKey: 'hover' -> stateKey: 'move', handlerKey: 'onHover'\n    var _mappedKeys$gestureKe = mappedKeys[gestureKey],\n        stateKey = _mappedKeys$gestureKe.stateKey,\n        handlerKey = _mappedKeys$gestureKe.handlerKey;\n\n    var state = _extends({}, _this.state.shared, {}, _this.state[stateKey]);\n\n    if (state.event) state.event.gesture = gestureKey;\n\n    if (gestureFlag === GestureFlag.OnStart) {\n      var handlerStart = handlerKey + \"Start\";\n      var _handler = _this.handlers[handlerStart];\n      _handler && _handler(state);\n    } // whenever a flag is set, we run the default on[Gesture] function\n    // i.e. GestureFlag.OnStart would trigger both onDragStart and onDrag\n\n\n    var handler = _this.handlers[handlerKey];\n\n    if (handler) {\n      var newMemo = handler(state);\n      _this.state[stateKey].memo = newMemo !== void 0 ? newMemo : _this.state[stateKey].memo;\n    }\n\n    if (gestureFlag === GestureFlag.OnEnd) {\n      var handlerEnd = handlerKey + \"End\";\n      var _handler2 = _this.handlers[handlerEnd];\n      _handler2 && _handler2(state);\n    }\n  };\n  /**\r\n   * Commodity function to let recognizers simply add listeners to config.window\r\n   * @param stateKey\r\n   * @param listeners\r\n   */\n\n\n  this.addWindowListeners = function (stateKey, listeners) {\n    if (!_this.config.window) return; // we use this.windowListeners to keep track of the listeners we add\n\n    _this.windowListeners[stateKey] = listeners;\n    addListeners(_this.config.window, listeners, _this.config.event);\n  }; // commodity function to let recognizers simply remove listeners from config.window\n\n\n  this.removeWindowListeners = function (stateKey) {\n    if (!_this.config.window) return;\n    var listeners = _this.windowListeners[stateKey];\n\n    if (listeners) {\n      removeListeners(_this.config.window, listeners, _this.config.event);\n      delete _this.windowListeners[stateKey];\n    }\n  };\n  /**\r\n   * Adds a recognizer to this.bindings\r\n   * @param recognizer\r\n   */\n\n\n  this.addRecognizer = function (recognizer) {\n    recognizer.getEventBindings().map(_this.addEventBindings);\n  };\n  /**\r\n   * this.bindings is an object which keys match ReactEventHandlerKeys (onMouseMove, onTouchStart...).\r\n   * Since a recognizer might want to bind a handler function to an event key already used by a previously\r\n   * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\r\n   * that key.\r\n   */\n\n\n  this.addEventBindings = function (_ref) {\n    var eventNames = _ref[0],\n        fn = _ref[1];\n    var eventNamesArray = !Array.isArray(eventNames) ? [eventNames] : eventNames;\n    eventNamesArray.forEach(function (eventName) {\n      _this.bindings[eventName] = _this.bindings[eventName] ? [].concat(_this.bindings[eventName], [fn]) : [fn];\n    });\n  };\n  /**\r\n   * When config.domTarget is set, this function will add dom listeners to it\r\n   */\n\n\n  this.addDomTargetListeners = function () {\n    var domTarget = _this.config.domTarget; // we iterate on the entries of this.binding\n    // for each event, we chain the array of functions mapped to it\n    // and push it to this.domListeners\n\n    Object.entries(_this.bindings).forEach(function (_ref2) {\n      var event = _ref2[0],\n          fns = _ref2[1];\n\n      _this.domListeners.push([event.substr(2).toLowerCase(), chainFns.apply(void 0, fns)]);\n    });\n    addListeners(domTarget, _this.domListeners, _this.config.event);\n  };\n  /**\r\n   * getBindings will return an object that will be bound by users\r\n   * to the react component they want to interact with\r\n   */\n\n\n  this.getBindings = function () {\n    var output = {};\n    var captureString = _this.config.event.capture ? 'Capture' : '';\n    Object.entries(_this.bindings).forEach(function (_ref3) {\n      var event = _ref3[0],\n          fns = _ref3[1];\n      var fnsArray = Array.isArray(fns) ? fns : [fns];\n      var key = event + captureString;\n      output[key] = chainFns.apply(void 0, fnsArray);\n    });\n    return output;\n  };\n\n  this.bind = function () {\n    var domTarget = _this.config.domTarget;\n\n    var genuineHandlers = _extends({}, _this.handlers); // cleaning before adding\n\n\n    _this.cleanOnBind();\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (_this.actions.has('onDrag')) {\n      _this.addRecognizer(new DragRecognizer(_this, args));\n\n      delete genuineHandlers.onDrag;\n      delete genuineHandlers.onDragStart;\n      delete genuineHandlers.onDragEnd;\n    }\n\n    if (_this.actions.has('onScroll')) {\n      _this.addRecognizer(new ScrollRecognizer(_this, args));\n\n      delete genuineHandlers.onScroll;\n      delete genuineHandlers.onScrollStart;\n      delete genuineHandlers.onScrollEnd;\n    }\n\n    if (_this.actions.has('onWheel')) {\n      _this.addRecognizer(new WheelRecognizer(_this, args));\n\n      delete genuineHandlers.onWheel;\n      delete genuineHandlers.onWheelStart;\n      delete genuineHandlers.onWheelEnd;\n    }\n\n    if (_this.actions.has('onMove')) {\n      _this.addRecognizer(new MoveRecognizer(_this, args));\n\n      delete genuineHandlers.onMove;\n      delete genuineHandlers.onMoveStart;\n      delete genuineHandlers.onMoveEnd;\n    }\n\n    if (_this.actions.has('onHover')) {\n      _this.addRecognizer(new HoverRecognizer(_this, args));\n\n      delete genuineHandlers.onHover;\n    }\n\n    if (_this.actions.has('onPinch')) {\n      // since react doesn't have handlers for gesture events we can only use them\n      // domTarget is set (and when the browser supprots them).\n      if (domTarget && gestureEventSupported()) {\n        _this.addRecognizer(new PinchWebKitGestureRecognizer(_this, args));\n      } else {\n        _this.addRecognizer(new PinchRecognizer(_this, args));\n\n        _this.addRecognizer(new PinchWheelRecognizer(_this, args));\n      }\n\n      delete genuineHandlers.onPinch;\n      delete genuineHandlers.onPinchStart;\n      delete genuineHandlers.onPinchEnd;\n    } // we also add event bindings for genuine handlers\n\n\n    Object.entries(genuineHandlers).map(function (_ref4) {\n      var event = _ref4[0],\n          fn = _ref4[1]; // we're cheating when it comes to event type :(\n\n      _this.addEventBindings([event, fn]);\n    }); // if config.domTarget is set we add event listeners to it and return the clean function\n\n    if (domTarget) {\n      _this.addDomTargetListeners();\n\n      return _this.clean;\n    } // if not, we return an object that contains gesture handlers mapped to react handler event keys\n\n\n    return _this.getBindings();\n  }; // if handlers contains {onDragStart, onDrag, onDragEnd, onMoveStart, onMove}\n  // actions will include 'onDrag' and 'onMove'\n\n\n  this.actions = new Set(Object.keys(this.handlers).map(function (k) {\n    return k.replace(/End|Start/, '');\n  }));\n};\n\nfunction useGesture(handlers, config) {\n  // the gesture controller will keep track of all gesture states\n  var gestureController = React.useRef();\n\n  if (!gestureController.current) {\n    // we initialize the gesture controller once\n    gestureController.current = new GestureController(handlers, getDerivedConfig(config));\n  }\n\n  React.useEffect(function () {\n    // every time handlers or config change, we let the gesture controller compute\n    // them so that the gesture handlers functions are aware of the changes\n    gestureController.current.config = getDerivedConfig(config);\n    gestureController.current.handlers = handlers;\n  }, [handlers, config]); // when the user component unmounts, we run our gesture controller clean function\n\n  React.useEffect(function () {\n    return gestureController.current.clean;\n  }, []); // we return the bind function of our controller, which returns an binding object or\n  // a cleaning function depending on whether config.domTarget is set\n\n  return gestureController.current.bind;\n}\n/* SHORTHAND HANDLERS */\n\n\nvar useDrag = function useDrag(handler, config) {\n  return useGesture({\n    onDrag: handler\n  }, config);\n};\n\nvar useMove = function useMove(handler, config) {\n  return useGesture({\n    onMove: handler\n  }, config);\n};\n\nvar useHover = function useHover(handler, config) {\n  return useGesture({\n    onHover: handler\n  }, config);\n};\n\nvar useScroll = function useScroll(handler, config) {\n  return useGesture({\n    onScroll: handler\n  }, config);\n};\n\nvar useWheel = function useWheel(handler, config) {\n  return useGesture({\n    onWheel: handler\n  }, config);\n};\n\nvar usePinch = function usePinch(handler, config) {\n  return useGesture({\n    onPinch: handler\n  }, config);\n};\n\nfunction getDerivedConfig(config) {\n  var derivedConfig = _extends({}, defaultConfig, {}, config);\n\n  var domTarget = derivedConfig.domTarget;\n  var realDomTarget = domTarget && 'current' in domTarget ? domTarget.current : domTarget;\n  derivedConfig.domTarget = realDomTarget;\n  var passive = derivedConfig.event.passive !== void 0 ? derivedConfig.event.passive : true; // TODO make test to check if passive is correctly passed to config\n  // if there isn't a domtarget or if event.passive is true, then passiveEvents is true\n\n  derivedConfig.passiveEvents = !derivedConfig.domTarget || passive;\n  return derivedConfig;\n}\n\nexport { addV, subV, useDrag, useGesture, useHover, useMove, usePinch, useScroll, useWheel };","map":null,"metadata":{},"sourceType":"module"}