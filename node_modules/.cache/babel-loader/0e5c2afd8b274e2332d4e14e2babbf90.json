{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ = require(\"lodash\");\n\nfunction parseNode(node) {\n  var components = [];\n\n  _.each(node.children, function (child) {\n    var component = parseNode(child);\n    components.push(component);\n  });\n\n  var dataItem = {\n    name: node.name,\n    type: node.value\n  };\n\n  if (!_.isEmpty(components)) {\n    dataItem.components = components;\n  }\n\n  return dataItem;\n}\n/**\n * Returns a DataItem corresponding to the input signature.\n * A signature can be in two forms: `type` or `(type_1,type_2,...,type_n)`\n * An example of the first form would be 'address' or 'uint256[]' or 'bytes[5][]'\n * An example of the second form would be '(address,uint256)' or '(address,uint256)[]'\n * @param signature of input DataItem.\n * @return DataItem derived from input signature.\n */\n\n\nfunction generateDataItemFromSignature(signature) {\n  var e_1, _a; // No data item corresponds to an empty signature\n\n\n  if (_.isEmpty(signature)) {\n    throw new Error(\"Cannot parse data item from empty signature, ''\");\n  } // Create a parse tree for data item\n\n\n  var node = {\n    name: '',\n    value: '',\n    children: []\n  };\n\n  try {\n    for (var signature_1 = __values(signature), signature_1_1 = signature_1.next(); !signature_1_1.done; signature_1_1 = signature_1.next()) {\n      var char = signature_1_1.value;\n\n      switch (char) {\n        case '(':\n          var child = {\n            name: '',\n            value: '',\n            children: [],\n            parent: node\n          };\n          node.value = 'tuple';\n          node.children.push(child);\n          node = child;\n          break;\n\n        case ')':\n          node = node.parent;\n          break;\n\n        case ',':\n          var sibling = {\n            name: '',\n            value: '',\n            children: [],\n            parent: node.parent\n          };\n          node.parent.children.push(sibling);\n          node = sibling;\n          break;\n\n        case ' ':\n          node.name = node.value;\n          node.value = '';\n          break;\n\n        default:\n          node.value += char;\n          break;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (signature_1_1 && !signature_1_1.done && (_a = signature_1.return)) _a.call(signature_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  } // Interpret data item from parse tree\n\n\n  var dataItem = parseNode(node);\n  return dataItem;\n}\n\nexports.generateDataItemFromSignature = generateDataItemFromSignature;","map":null,"metadata":{},"sourceType":"script"}