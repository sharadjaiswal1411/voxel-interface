{"ast":null,"code":"import _defineProperty from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _slicedToArray from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { isString } from './is.js';\nimport { logger } from './logger.js';\nvar BAGGAGE_HEADER_NAME = 'baggage';\nvar SENTRY_BAGGAGE_KEY_PREFIX = 'sentry-';\nvar SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;\n/**\n * Max length of a serialized baggage string\n *\n * https://www.w3.org/TR/baggage/#limits\n */\n\nvar MAX_BAGGAGE_STRING_LENGTH = 8192;\n/** Create an instance of Baggage */\n\nfunction createBaggage(initItems) {\n  var baggageString = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var mutable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  return [_objectSpread({}, initItems), baggageString, mutable];\n}\n/** Get a value from baggage */\n\n\nfunction getBaggageValue(baggage, key) {\n  return baggage[0][key];\n}\n/** Add a value to baggage */\n\n\nfunction setBaggageValue(baggage, key, value) {\n  if (isBaggageMutable(baggage)) {\n    baggage[0][key] = value;\n  }\n}\n/** Check if the Sentry part of the passed baggage (i.e. the first element in the tuple) is empty */\n\n\nfunction isSentryBaggageEmpty(baggage) {\n  return Object.keys(baggage[0]).length === 0;\n}\n/** Returns Sentry specific baggage values */\n\n\nfunction getSentryBaggageItems(baggage) {\n  return baggage[0];\n}\n/**\n * Returns 3rd party baggage string of @param baggage\n * @param baggage\n */\n\n\nfunction getThirdPartyBaggage(baggage) {\n  return baggage[1];\n}\n/**\n * Checks if baggage is mutable\n * @param baggage\n * @returns true if baggage is mutable, else false\n */\n\n\nfunction isBaggageMutable(baggage) {\n  return baggage[2];\n}\n/**\n * Sets the passed baggage immutable\n * @param baggage\n */\n\n\nfunction setBaggageImmutable(baggage) {\n  baggage[2] = false;\n}\n/** Serialize a baggage object */\n\n\nfunction serializeBaggage(baggage) {\n  return Object.keys(baggage[0]).reduce(function (prev, key) {\n    var val = baggage[0][key];\n    var baggageEntry = \"\".concat(SENTRY_BAGGAGE_KEY_PREFIX).concat(encodeURIComponent(key), \"=\").concat(encodeURIComponent(val));\n    var newVal = prev === '' ? baggageEntry : \"\".concat(prev, \",\").concat(baggageEntry);\n\n    if (newVal.length > MAX_BAGGAGE_STRING_LENGTH) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(\"Not adding key: \".concat(key, \" with val: \").concat(val, \" to baggage due to exceeding baggage size limits.\"));\n      return prev;\n    } else {\n      return newVal;\n    }\n  }, baggage[1]);\n}\n/**\n * Parse a baggage header from a string or a string array and return a Baggage object\n *\n * If @param includeThirdPartyEntries is set to true, third party baggage entries are added to the Baggage object\n * (This is necessary for merging potentially pre-existing baggage headers in outgoing requests with\n * our `sentry-` values)\n */\n\n\nfunction parseBaggageHeader(inputBaggageValue) {\n  var includeThirdPartyEntries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  // Adding this check here because we got reports of this function failing due to the input value\n  // not being a string. This debug log might help us determine what's going on here.\n  if (!Array.isArray(inputBaggageValue) && !isString(inputBaggageValue) || typeof inputBaggageValue === 'number') {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('[parseBaggageHeader] Received input value of incompatible type: ', typeof inputBaggageValue, inputBaggageValue); // Gonna early-return an empty baggage object so that we don't fail later on\n\n    return createBaggage({}, '');\n  }\n\n  var baggageEntries = (isString(inputBaggageValue) ? inputBaggageValue : inputBaggageValue.join(',')).split(',').map(function (entry) {\n    return entry.trim();\n  }).filter(function (entry) {\n    return entry !== '' && (includeThirdPartyEntries || SENTRY_BAGGAGE_KEY_PREFIX_REGEX.test(entry));\n  });\n  return baggageEntries.reduce(function (_ref, curr) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        baggageObj = _ref2[0],\n        baggageString = _ref2[1];\n\n    var _curr$split = curr.split('='),\n        _curr$split2 = _slicedToArray(_curr$split, 2),\n        key = _curr$split2[0],\n        val = _curr$split2[1];\n\n    if (SENTRY_BAGGAGE_KEY_PREFIX_REGEX.test(key)) {\n      var baggageKey = decodeURIComponent(key.split('-')[1]);\n      return [_objectSpread(_objectSpread({}, baggageObj), {}, _defineProperty({}, baggageKey, decodeURIComponent(val))), baggageString, true];\n    } else {\n      return [baggageObj, baggageString === '' ? curr : \"\".concat(baggageString, \",\").concat(curr), true];\n    }\n  }, [{}, '', true]);\n}\n/**\n * Merges the baggage header we saved from the incoming request (or meta tag) with\n * a possibly created or modified baggage header by a third party that's been added\n * to the outgoing request header.\n *\n * In case @param headerBaggageString exists, we can safely add the the 3rd party part of @param headerBaggage\n * with our @param incomingBaggage. This is possible because if we modified anything beforehand,\n * it would only affect parts of the sentry baggage (@see Baggage interface).\n *\n * @param incomingBaggage the baggage header of the incoming request that might contain sentry entries\n * @param thirdPartyBaggageHeader possibly existing baggage header string or string[] added from a third\n *        party to the request headers\n *\n * @return a merged and serialized baggage string to be propagated with the outgoing request\n */\n\n\nfunction mergeAndSerializeBaggage(incomingBaggage, thirdPartyBaggageHeader) {\n  if (!incomingBaggage && !thirdPartyBaggageHeader) {\n    return '';\n  }\n\n  var headerBaggage = thirdPartyBaggageHeader && parseBaggageHeader(thirdPartyBaggageHeader, true) || undefined;\n  var thirdPartyHeaderBaggage = headerBaggage && getThirdPartyBaggage(headerBaggage);\n  var finalBaggage = createBaggage(incomingBaggage && incomingBaggage[0] || {}, thirdPartyHeaderBaggage || '');\n  return serializeBaggage(finalBaggage);\n}\n/**\n * Helper function that takes a raw baggage string (if available) and the processed sentry-trace header\n * data (if available), parses the baggage string and creates a Baggage object\n * If there is no baggage string, it will create an empty Baggage object.\n * In a second step, this functions determines if the created Baggage object should be set immutable\n * to prevent mutation of the Sentry data.\n *\n * Extracted this logic to a function because it's duplicated in a lot of places.\n *\n * @param rawBaggageValue\n * @param sentryTraceHeader\n */\n\n\nfunction parseBaggageSetMutability(rawBaggageValue, sentryTraceHeader) {\n  var baggage = parseBaggageHeader(rawBaggageValue || ''); // Because we are always creating a Baggage object by calling `parseBaggageHeader` above\n  // (either a filled one or an empty one, even if we didn't get a `baggage` header),\n  // we only need to check if we have a sentry-trace header or not. As soon as we have it,\n  // we set baggage immutable. In case we don't get a sentry-trace header, we can assume that\n  // this SDK is the head of the trace and thus we still permit mutation at this time.\n  // There is one exception though, which is that we get a baggage-header with `sentry-`\n  // items but NO sentry-trace header. In this case we also set the baggage immutable for now\n  // but if smoething like this would ever happen, we should revisit this and determine\n  // what this would actually mean for the trace (i.e. is this SDK the head?, what happened\n  // before that we don't have a sentry-trace header?, etc)\n\n  (sentryTraceHeader || !isSentryBaggageEmpty(baggage)) && setBaggageImmutable(baggage);\n  return baggage;\n}\n\nexport { BAGGAGE_HEADER_NAME, MAX_BAGGAGE_STRING_LENGTH, SENTRY_BAGGAGE_KEY_PREFIX, SENTRY_BAGGAGE_KEY_PREFIX_REGEX, createBaggage, getBaggageValue, getSentryBaggageItems, getThirdPartyBaggage, isBaggageMutable, isSentryBaggageEmpty, mergeAndSerializeBaggage, parseBaggageHeader, parseBaggageSetMutability, serializeBaggage, setBaggageImmutable, setBaggageValue };","map":null,"metadata":{},"sourceType":"module"}