{"ast":null,"code":"import _toConsumableArray from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _regeneratorRuntime from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _defineProperty from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n\nvar _liveDataApi,\n    _s = $RefreshSig$();\n\nimport { ChainId, WETH } from '@kyberswap/ks-sdk-core';\nimport axios from 'axios';\nimport { getUnixTime, subHours } from 'date-fns';\nimport { useMemo } from 'react';\nimport useSWR from 'swr';\nimport { COINGECKO_API_URL } from 'constants/index';\nimport { NETWORKS_INFO } from 'constants/networks';\nimport { useActiveWeb3React } from 'hooks';\nexport var LiveDataTimeframeEnum;\n\n(function (LiveDataTimeframeEnum) {\n  LiveDataTimeframeEnum[\"HOUR\"] = \"1H\";\n  LiveDataTimeframeEnum[\"FOUR_HOURS\"] = \"4H\";\n  LiveDataTimeframeEnum[\"DAY\"] = \"1D\";\n  LiveDataTimeframeEnum[\"WEEK\"] = \"1W\";\n  LiveDataTimeframeEnum[\"MONTH\"] = \"1M\";\n  LiveDataTimeframeEnum[\"SIX_MONTHS\"] = \"6M\";\n})(LiveDataTimeframeEnum || (LiveDataTimeframeEnum = {}));\n\nvar getTimeFrameHours = function getTimeFrameHours(timeFrame) {\n  switch (timeFrame) {\n    case LiveDataTimeframeEnum.HOUR:\n      return 1;\n\n    case LiveDataTimeframeEnum.FOUR_HOURS:\n      return 4;\n\n    case LiveDataTimeframeEnum.DAY:\n      return 24;\n\n    case LiveDataTimeframeEnum.WEEK:\n      return 7 * 24;\n\n    case LiveDataTimeframeEnum.MONTH:\n      return 30 * 24;\n\n    case LiveDataTimeframeEnum.SIX_MONTHS:\n      return 180 * 24;\n\n    default:\n      return 7 * 24;\n  }\n};\n\nvar generateCoingeckoUrl = function generateCoingeckoUrl(chainId, address, timeFrame) {\n  var timeTo = getUnixTime(new Date());\n  var timeFrom = timeFrame === 'live' ? timeTo - 1000 : getUnixTime(subHours(new Date(), getTimeFrameHours(timeFrame)));\n  return \"\".concat(COINGECKO_API_URL, \"/coins/\").concat(NETWORKS_INFO[chainId || ChainId.MAINNET].coingeckoNetworkId, \"/contract/\").concat(address, \"/market_chart/range?vs_currency=usd&from=\").concat(timeFrom, \"&to=\").concat(timeTo);\n};\n\nvar getClosestPrice = function getClosestPrice(prices, time) {\n  var closestIndex = 0;\n  prices.forEach(function (item, index) {\n    if (Math.abs(item[0] - time) < Math.abs(prices[closestIndex][0] - time)) {\n      closestIndex = index;\n    }\n  });\n  return prices[closestIndex][0] - time > 10000000 ? 0 : prices[closestIndex][1];\n};\n\nvar liveDataApi = (_liveDataApi = {}, _defineProperty(_liveDataApi, ChainId.MAINNET, \"\".concat(process.env.REACT_APP_AGGREGATOR_API, \"/ethereum/tokens\")), _defineProperty(_liveDataApi, ChainId.BSCMAINNET, \"\".concat(process.env.REACT_APP_AGGREGATOR_API, \"/bsc/tokens\")), _defineProperty(_liveDataApi, ChainId.MATIC, \"\".concat(process.env.REACT_APP_AGGREGATOR_API, \"/polygon/tokens\")), _defineProperty(_liveDataApi, ChainId.AVAXMAINNET, \"\".concat(process.env.REACT_APP_AGGREGATOR_API, \"/avalanche/tokens\")), _defineProperty(_liveDataApi, ChainId.FANTOM, \"\".concat(process.env.REACT_APP_AGGREGATOR_API, \"/fantom/tokens\")), _defineProperty(_liveDataApi, ChainId.CRONOS, \"\".concat(process.env.REACT_APP_AGGREGATOR_API, \"/cronos/tokens\")), _defineProperty(_liveDataApi, ChainId.ARBITRUM, \"\".concat(process.env.REACT_APP_AGGREGATOR_API, \"/arbitrum/tokens\")), _liveDataApi);\n\nvar fetchKyberDataSWR = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(url) {\n    var res;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return axios.get(url, {\n              timeout: 5000\n            });\n\n          case 2:\n            res = _context.sent;\n\n            if (!(res.status === 204)) {\n              _context.next = 5;\n              break;\n            }\n\n            throw new Error('No content');\n\n          case 5:\n            return _context.abrupt(\"return\", res.data);\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function fetchKyberDataSWR(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar fetchKyberDataSWRWithHeader = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(url) {\n    var res;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return axios.get(url, {\n              timeout: 5000,\n              headers: {\n                'accept-version': 'Latest'\n              }\n            }).catch(function (error) {\n              throw error;\n            });\n\n          case 2:\n            res = _context2.sent;\n\n            if (!(res.status === 204)) {\n              _context2.next = 5;\n              break;\n            }\n\n            throw new Error('No content');\n\n          case 5:\n            return _context2.abrupt(\"return\", res.data);\n\n          case 6:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function fetchKyberDataSWRWithHeader(_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar fetchCoingeckoDataSWR = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(tokenAddresses, chainId, timeFrame) {\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return Promise.all([tokenAddresses[0], tokenAddresses[1]].map(function (address) {\n              return axios.get(generateCoingeckoUrl(chainId, address, timeFrame), {\n                timeout: 5000\n              }).then(function (res) {\n                if (res.status === 204) {\n                  throw new Error('No content');\n                }\n\n                return res.data;\n              }).catch(function (error) {\n                throw error;\n              });\n            }));\n\n          case 2:\n            return _context3.abrupt(\"return\", _context3.sent);\n\n          case 3:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function fetchCoingeckoDataSWR(_x3, _x4, _x5) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nexport default function useBasicChartData(tokens, timeFrame) {\n  _s();\n\n  var _useActiveWeb3React = useActiveWeb3React(),\n      chainId = _useActiveWeb3React.chainId;\n\n  var isReverse = useMemo(function () {\n    if (!tokens || !tokens[0] || !tokens[1] || tokens[0].equals(tokens[1])) return false;\n\n    var _ref4 = tokens[0].sortsBefore(tokens[1]) ? [tokens[0], tokens[1]] : [tokens[1], tokens[0]],\n        _ref5 = _slicedToArray(_ref4, 1),\n        token0 = _ref5[0];\n\n    return token0 !== tokens[0];\n  }, [tokens]);\n  var tokenAddresses = useMemo(function () {\n    return tokens.filter(Boolean).map(function (token) {\n      var _ref6;\n\n      return (_ref6 = token !== null && token !== void 0 && token.isNative ? WETH[chainId || ChainId.MAINNET].address : token === null || token === void 0 ? void 0 : token.address) === null || _ref6 === void 0 ? void 0 : _ref6.toLowerCase();\n    });\n  }, [tokens, chainId]);\n\n  var _useSWR = useSWR(tokenAddresses[0] && tokenAddresses[1] && [tokenAddresses, chainId, timeFrame], fetchCoingeckoDataSWR, {\n    shouldRetryOnError: false,\n    revalidateOnFocus: false,\n    revalidateIfStale: false\n  }),\n      coingeckoData = _useSWR.data,\n      coingeckoError = _useSWR.error,\n      coingeckoLoading = _useSWR.isValidating;\n\n  var _useSWR2 = useSWR(coingeckoError && tokenAddresses[0] && tokenAddresses[1] ? \"\".concat(process.env.REACT_APP_PRICE_CHART_API, \"/price-chart?chainId=\").concat(chainId, \"&timeWindow=\").concat(timeFrame.toLowerCase(), \"&tokenIn=\").concat(tokenAddresses[0], \"&tokenOut=\").concat(tokenAddresses[1]) : null, fetchKyberDataSWR, {\n    shouldRetryOnError: false,\n    revalidateOnFocus: false,\n    revalidateIfStale: false\n  }),\n      kyberData = _useSWR2.data,\n      kyberError = _useSWR2.error,\n      kyberLoading = _useSWR2.isValidating;\n\n  var isKyberDataNotValid = useMemo(function () {\n    if (kyberError || kyberData === null) return true;\n    if (kyberData && kyberData.length === 0) return true;\n    if (kyberData && kyberData.length > 0 && kyberData.every(function (item) {\n      return !item.token0Price || item.token0Price === '0';\n    })) return true;\n    return false;\n  }, [kyberError, kyberData]);\n  var chartData = useMemo(function () {\n    var _coingeckoData$, _coingeckoData$$price, _coingeckoData$2, _coingeckoData$2$pric;\n\n    if (!isKyberDataNotValid && kyberData && kyberData.length > 0) {\n      return kyberData.sort(function (a, b) {\n        return parseInt(a.timestamp) - parseInt(b.timestamp);\n      }).map(function (item) {\n        return {\n          time: parseInt(item.timestamp) * 1000,\n          value: !isReverse ? item.token0Price : item.token1Price || 0\n        };\n      });\n    } else if (coingeckoData && ((_coingeckoData$ = coingeckoData[0]) === null || _coingeckoData$ === void 0 ? void 0 : (_coingeckoData$$price = _coingeckoData$.prices) === null || _coingeckoData$$price === void 0 ? void 0 : _coingeckoData$$price.length) > 0 && ((_coingeckoData$2 = coingeckoData[1]) === null || _coingeckoData$2 === void 0 ? void 0 : (_coingeckoData$2$pric = _coingeckoData$2.prices) === null || _coingeckoData$2$pric === void 0 ? void 0 : _coingeckoData$2$pric.length) > 0) {\n      var _coingeckoData = _slicedToArray(coingeckoData, 2),\n          data1 = _coingeckoData[0],\n          data2 = _coingeckoData[1];\n\n      return data1.prices.map(function (item) {\n        var closestPrice = getClosestPrice(data2.prices, item[0]);\n        return {\n          time: item[0],\n          value: closestPrice > 0 ? parseFloat((item[1] / closestPrice).toPrecision(6)) : 0\n        };\n      });\n    } else return [];\n  }, [kyberData, coingeckoData, isKyberDataNotValid, isReverse]);\n  var error = !!kyberError && !!coingeckoError || chartData.length === 0;\n\n  var _useSWR3 = useSWR(!isKyberDataNotValid && kyberData && chainId ? liveDataApi[chainId] + \"?ids=\".concat(tokenAddresses[0], \",\").concat(tokenAddresses[1]) : null, fetchKyberDataSWRWithHeader, {\n    refreshInterval: 60000,\n    shouldRetryOnError: false,\n    revalidateOnFocus: false,\n    revalidateIfStale: false\n  }),\n      liveKyberData = _useSWR3.data;\n\n  var _useSWR4 = useSWR(isKyberDataNotValid && coingeckoData ? [tokenAddresses, chainId, 'live'] : null, fetchCoingeckoDataSWR, {\n    refreshInterval: 60000,\n    shouldRetryOnError: false,\n    revalidateOnFocus: false,\n    revalidateIfStale: false\n  }),\n      liveCoingeckoData = _useSWR4.data;\n\n  var latestData = useMemo(function () {\n    if (isKyberDataNotValid) {\n      if (liveCoingeckoData) {\n        var _data1$prices, _data2$prices;\n\n        var _liveCoingeckoData = _slicedToArray(liveCoingeckoData, 2),\n            data1 = _liveCoingeckoData[0],\n            data2 = _liveCoingeckoData[1];\n\n        if (((_data1$prices = data1.prices) === null || _data1$prices === void 0 ? void 0 : _data1$prices.length) > 0 && ((_data2$prices = data2.prices) === null || _data2$prices === void 0 ? void 0 : _data2$prices.length) > 0) {\n          var newValue = parseFloat((data1.prices[data1.prices.length - 1][1] / data2.prices[data2.prices.length - 1][1]).toPrecision(6));\n          return {\n            time: new Date().getTime(),\n            value: newValue\n          };\n        }\n      }\n    } else {\n      if (liveKyberData) {\n        var _liveKyberData$tokenA, _liveKyberData$tokenA2;\n\n        var value = liveKyberData && tokenAddresses[0] && tokenAddresses[1] ? ((_liveKyberData$tokenA = liveKyberData[tokenAddresses[0]]) === null || _liveKyberData$tokenA === void 0 ? void 0 : _liveKyberData$tokenA.price) / ((_liveKyberData$tokenA2 = liveKyberData[tokenAddresses[1]]) === null || _liveKyberData$tokenA2 === void 0 ? void 0 : _liveKyberData$tokenA2.price) : 0;\n        if (value) return {\n          time: new Date().getTime(),\n          value: value\n        };\n      }\n    }\n\n    return null;\n  }, [liveKyberData, liveCoingeckoData, isKyberDataNotValid, tokenAddresses]);\n  return {\n    data: useMemo(function () {\n      return latestData ? [].concat(_toConsumableArray(chartData), [latestData]) : chartData;\n    }, [latestData, chartData]),\n    error: error,\n    loading: !tokenAddresses[0] || !tokenAddresses[1] || kyberLoading || coingeckoLoading\n  };\n}\n\n_s(useBasicChartData, \"RSJGopREn3TTZXtl0RgEowdOQtE=\", false, function () {\n  return [useActiveWeb3React, useSWR, useSWR, useSWR, useSWR];\n});","map":{"version":3,"names":["ChainId","WETH","axios","getUnixTime","subHours","useMemo","useSWR","COINGECKO_API_URL","NETWORKS_INFO","useActiveWeb3React","LiveDataTimeframeEnum","getTimeFrameHours","timeFrame","HOUR","FOUR_HOURS","DAY","WEEK","MONTH","SIX_MONTHS","generateCoingeckoUrl","chainId","address","timeTo","Date","timeFrom","MAINNET","coingeckoNetworkId","getClosestPrice","prices","time","closestIndex","forEach","item","index","Math","abs","liveDataApi","process","env","REACT_APP_AGGREGATOR_API","BSCMAINNET","MATIC","AVAXMAINNET","FANTOM","CRONOS","ARBITRUM","fetchKyberDataSWR","url","get","timeout","res","status","Error","data","fetchKyberDataSWRWithHeader","headers","catch","error","fetchCoingeckoDataSWR","tokenAddresses","Promise","all","map","then","useBasicChartData","tokens","isReverse","equals","sortsBefore","token0","filter","Boolean","token","isNative","toLowerCase","shouldRetryOnError","revalidateOnFocus","revalidateIfStale","coingeckoData","coingeckoError","coingeckoLoading","isValidating","REACT_APP_PRICE_CHART_API","kyberData","kyberError","kyberLoading","isKyberDataNotValid","length","every","token0Price","chartData","sort","a","b","parseInt","timestamp","value","token1Price","data1","data2","closestPrice","parseFloat","toPrecision","refreshInterval","liveKyberData","liveCoingeckoData","latestData","newValue","getTime","price","loading"],"sources":["/Applications/XAMPP/voxel-interface/src/hooks/useBasicChartData.ts"],"sourcesContent":["import { ChainId, Token, WETH } from '@kyberswap/ks-sdk-core'\nimport axios from 'axios'\nimport { getUnixTime, subHours } from 'date-fns'\nimport { useMemo } from 'react'\nimport useSWR from 'swr'\n\nimport { COINGECKO_API_URL } from 'constants/index'\nimport { NETWORKS_INFO } from 'constants/networks'\nimport { useActiveWeb3React } from 'hooks'\n\nexport enum LiveDataTimeframeEnum {\n  HOUR = '1H',\n  FOUR_HOURS = '4H',\n  DAY = '1D',\n  WEEK = '1W',\n  MONTH = '1M',\n  SIX_MONTHS = '6M',\n}\n\nconst getTimeFrameHours = (timeFrame: LiveDataTimeframeEnum) => {\n  switch (timeFrame) {\n    case LiveDataTimeframeEnum.HOUR:\n      return 1\n    case LiveDataTimeframeEnum.FOUR_HOURS:\n      return 4\n    case LiveDataTimeframeEnum.DAY:\n      return 24\n    case LiveDataTimeframeEnum.WEEK:\n      return 7 * 24\n    case LiveDataTimeframeEnum.MONTH:\n      return 30 * 24\n    case LiveDataTimeframeEnum.SIX_MONTHS:\n      return 180 * 24\n    default:\n      return 7 * 24\n  }\n}\nconst generateCoingeckoUrl = (\n  chainId: ChainId,\n  address: string | undefined,\n  timeFrame: LiveDataTimeframeEnum | 'live',\n): string => {\n  const timeTo = getUnixTime(new Date())\n  const timeFrom =\n    timeFrame === 'live' ? timeTo - 1000 : getUnixTime(subHours(new Date(), getTimeFrameHours(timeFrame)))\n\n  return `${COINGECKO_API_URL}/coins/${\n    NETWORKS_INFO[chainId || ChainId.MAINNET].coingeckoNetworkId\n  }/contract/${address}/market_chart/range?vs_currency=usd&from=${timeFrom}&to=${timeTo}`\n}\nconst getClosestPrice = (prices: any[], time: number) => {\n  let closestIndex = 0\n  prices.forEach((item, index) => {\n    if (Math.abs(item[0] - time) < Math.abs(prices[closestIndex][0] - time)) {\n      closestIndex = index\n    }\n  })\n  return prices[closestIndex][0] - time > 10000000 ? 0 : prices[closestIndex][1]\n}\n\nexport interface ChartDataInfo {\n  readonly time: number\n  readonly value: number\n}\n\nconst liveDataApi: { [chainId in ChainId]?: string } = {\n  [ChainId.MAINNET]: `${process.env.REACT_APP_AGGREGATOR_API}/ethereum/tokens`,\n  [ChainId.BSCMAINNET]: `${process.env.REACT_APP_AGGREGATOR_API}/bsc/tokens`,\n  [ChainId.MATIC]: `${process.env.REACT_APP_AGGREGATOR_API}/polygon/tokens`,\n  [ChainId.AVAXMAINNET]: `${process.env.REACT_APP_AGGREGATOR_API}/avalanche/tokens`,\n  [ChainId.FANTOM]: `${process.env.REACT_APP_AGGREGATOR_API}/fantom/tokens`,\n  [ChainId.CRONOS]: `${process.env.REACT_APP_AGGREGATOR_API}/cronos/tokens`,\n  [ChainId.ARBITRUM]: `${process.env.REACT_APP_AGGREGATOR_API}/arbitrum/tokens`,\n}\n\nconst fetchKyberDataSWR = async (url: string) => {\n  const res = await axios.get(url, { timeout: 5000 })\n  if (res.status === 204) {\n    throw new Error('No content')\n  }\n  return res.data\n}\n\nconst fetchKyberDataSWRWithHeader = async (url: string) => {\n  const res = await axios\n    .get(url, {\n      timeout: 5000,\n      headers: {\n        'accept-version': 'Latest',\n      },\n    })\n    .catch(error => {\n      throw error\n    })\n\n  if (res.status === 204) {\n    throw new Error('No content')\n  }\n  return res.data\n}\n\nconst fetchCoingeckoDataSWR = async (tokenAddresses: any, chainId: any, timeFrame: any): Promise<any> => {\n  return await Promise.all(\n    [tokenAddresses[0], tokenAddresses[1]].map(address =>\n      axios\n        .get(generateCoingeckoUrl(chainId, address, timeFrame), { timeout: 5000 })\n        .then(res => {\n          if (res.status === 204) {\n            throw new Error('No content')\n          }\n          return res.data\n        })\n        .catch(error => {\n          throw error\n        }),\n    ),\n  )\n}\n\nexport default function useBasicChartData(tokens: (Token | null | undefined)[], timeFrame: LiveDataTimeframeEnum) {\n  const { chainId } = useActiveWeb3React()\n\n  const isReverse = useMemo(() => {\n    if (!tokens || !tokens[0] || !tokens[1] || tokens[0].equals(tokens[1])) return false\n    const [token0] = tokens[0].sortsBefore(tokens[1]) ? [tokens[0], tokens[1]] : [tokens[1], tokens[0]]\n    return token0 !== tokens[0]\n  }, [tokens])\n\n  const tokenAddresses = useMemo(\n    () =>\n      tokens\n        .filter(Boolean)\n        .map(token => (token?.isNative ? WETH[chainId || ChainId.MAINNET].address : token?.address)?.toLowerCase()),\n    [tokens, chainId],\n  )\n\n  const {\n    data: coingeckoData,\n    error: coingeckoError,\n    isValidating: coingeckoLoading,\n  } = useSWR(tokenAddresses[0] && tokenAddresses[1] && [tokenAddresses, chainId, timeFrame], fetchCoingeckoDataSWR, {\n    shouldRetryOnError: false,\n    revalidateOnFocus: false,\n    revalidateIfStale: false,\n  })\n\n  const {\n    data: kyberData,\n    error: kyberError,\n    isValidating: kyberLoading,\n  } = useSWR(\n    coingeckoError && tokenAddresses[0] && tokenAddresses[1]\n      ? `${\n          process.env.REACT_APP_PRICE_CHART_API\n        }/price-chart?chainId=${chainId}&timeWindow=${timeFrame.toLowerCase()}&tokenIn=${tokenAddresses[0]}&tokenOut=${\n          tokenAddresses[1]\n        }`\n      : null,\n    fetchKyberDataSWR,\n    {\n      shouldRetryOnError: false,\n      revalidateOnFocus: false,\n      revalidateIfStale: false,\n    },\n  )\n\n  const isKyberDataNotValid = useMemo(() => {\n    if (kyberError || kyberData === null) return true\n    if (kyberData && kyberData.length === 0) return true\n    if (\n      kyberData &&\n      kyberData.length > 0 &&\n      kyberData.every((item: any) => !item.token0Price || item.token0Price === '0')\n    )\n      return true\n    return false\n  }, [kyberError, kyberData])\n\n  const chartData = useMemo(() => {\n    if (!isKyberDataNotValid && kyberData && kyberData.length > 0) {\n      return kyberData\n        .sort((a: any, b: any) => parseInt(a.timestamp) - parseInt(b.timestamp))\n        .map((item: any) => {\n          return {\n            time: parseInt(item.timestamp) * 1000,\n            value: !isReverse ? item.token0Price : item.token1Price || 0,\n          }\n        })\n    } else if (coingeckoData && coingeckoData[0]?.prices?.length > 0 && coingeckoData[1]?.prices?.length > 0) {\n      const [data1, data2] = coingeckoData\n      return data1.prices.map((item: number[]) => {\n        const closestPrice = getClosestPrice(data2.prices, item[0])\n        return { time: item[0], value: closestPrice > 0 ? parseFloat((item[1] / closestPrice).toPrecision(6)) : 0 }\n      })\n    } else return []\n  }, [kyberData, coingeckoData, isKyberDataNotValid, isReverse])\n\n  const error = (!!kyberError && !!coingeckoError) || chartData.length === 0\n\n  const { data: liveKyberData } = useSWR(\n    !isKyberDataNotValid && kyberData && chainId\n      ? liveDataApi[chainId] + `?ids=${tokenAddresses[0]},${tokenAddresses[1]}`\n      : null,\n    fetchKyberDataSWRWithHeader,\n    {\n      refreshInterval: 60000,\n      shouldRetryOnError: false,\n      revalidateOnFocus: false,\n      revalidateIfStale: false,\n    },\n  )\n\n  const { data: liveCoingeckoData } = useSWR(\n    isKyberDataNotValid && coingeckoData ? [tokenAddresses, chainId, 'live'] : null,\n    fetchCoingeckoDataSWR,\n    {\n      refreshInterval: 60000,\n      shouldRetryOnError: false,\n      revalidateOnFocus: false,\n      revalidateIfStale: false,\n    },\n  )\n\n  const latestData = useMemo(() => {\n    if (isKyberDataNotValid) {\n      if (liveCoingeckoData) {\n        const [data1, data2] = liveCoingeckoData\n        if (data1.prices?.length > 0 && data2.prices?.length > 0) {\n          const newValue = parseFloat(\n            (data1.prices[data1.prices.length - 1][1] / data2.prices[data2.prices.length - 1][1]).toPrecision(6),\n          )\n          return { time: new Date().getTime(), value: newValue }\n        }\n      }\n    } else {\n      if (liveKyberData) {\n        const value =\n          liveKyberData && tokenAddresses[0] && tokenAddresses[1]\n            ? liveKyberData[tokenAddresses[0]]?.price / liveKyberData[tokenAddresses[1]]?.price\n            : 0\n        if (value) return { time: new Date().getTime(), value: value }\n      }\n    }\n    return null\n  }, [liveKyberData, liveCoingeckoData, isKyberDataNotValid, tokenAddresses])\n\n  return {\n    data: useMemo(() => (latestData ? [...chartData, latestData] : chartData), [latestData, chartData]),\n    error: error,\n    loading: !tokenAddresses[0] || !tokenAddresses[1] || kyberLoading || coingeckoLoading,\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}