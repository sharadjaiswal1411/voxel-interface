{"ast":null,"code":"import _slicedToArray from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _defineProperty from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n\nvar _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$();\n\nimport { Trans } from \"@lingui/react\";\nimport { ZERO } from '@kyberswap/ks-sdk-classic';\nimport { CurrencyAmount, Price, Rounding } from '@kyberswap/ks-sdk-core';\nimport { FullMath, Pool, Position, SqrtPriceMath, TICK_SPACINGS, TickMath, encodeSqrtRatioX96, nearestUsableTick, priceToClosestTick, tickToPrice } from '@kyberswap/ks-sdk-elastic';\nimport JSBI from 'jsbi';\nimport React, { useCallback, useMemo } from 'react';\nimport { useActiveWeb3React } from 'hooks';\nimport { PoolState, usePool } from 'hooks/usePools';\nimport { useAppDispatch, useAppSelector } from 'state/hooks';\nimport { tryParseAmount } from 'state/swap/hooks';\nimport { useCurrencyBalances } from 'state/wallet/hooks';\nimport { getTickToPrice } from 'utils/getTickToPrice';\nimport { BIG_INT_ZERO } from '../../../constants';\nimport { Bound, Field, setFullRange, typeInput, typeLeftRangeInput, typeRightRangeInput, typeStartPriceInput } from './actions';\nimport { tryParseTick } from './utils';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport function useProAmmMintState() {\n  _s();\n\n  return useAppSelector(function (state) {\n    return state.mintV2;\n  });\n}\n\n_s(useProAmmMintState, \"bRaY7Fsh/GrWHjZMhGvF04Z7BZI=\", false, function () {\n  return [useAppSelector];\n});\n\nexport function useProAmmMintActionHandlers(noLiquidity) {\n  _s2();\n\n  var dispatch = useAppDispatch();\n  var onFieldAInput = useCallback(function (typedValue) {\n    dispatch(typeInput({\n      field: Field.CURRENCY_A,\n      typedValue: typedValue,\n      noLiquidity: noLiquidity === true\n    }));\n  }, [dispatch, noLiquidity]);\n  var onFieldBInput = useCallback(function (typedValue) {\n    dispatch(typeInput({\n      field: Field.CURRENCY_B,\n      typedValue: typedValue,\n      noLiquidity: noLiquidity === true\n    }));\n  }, [dispatch, noLiquidity]);\n  var onLeftRangeInput = useCallback(function (typedValue) {\n    dispatch(typeLeftRangeInput({\n      typedValue: typedValue\n    }));\n  }, [dispatch]);\n  var onRightRangeInput = useCallback(function (typedValue) {\n    dispatch(typeRightRangeInput({\n      typedValue: typedValue\n    }));\n  }, [dispatch]);\n  var onStartPriceInput = useCallback(function (typedValue) {\n    dispatch(typeStartPriceInput({\n      typedValue: typedValue\n    }));\n  }, [dispatch]);\n  return {\n    onFieldAInput: onFieldAInput,\n    onFieldBInput: onFieldBInput,\n    onLeftRangeInput: onLeftRangeInput,\n    onRightRangeInput: onRightRangeInput,\n    onStartPriceInput: onStartPriceInput\n  };\n}\n\n_s2(useProAmmMintActionHandlers, \"dOTZHF17zY9BuUfYGfh2RaVZy6M=\", false, function () {\n  return [useAppDispatch];\n});\n\nexport function useProAmmDerivedMintInfo(currencyA, currencyB, feeAmount, baseCurrency, // override for existing position\nexistingPosition) {\n  _s3();\n\n  var _currencyBalances, _currencyBalances$Fie, _currencyBalances$Fie2, _currencyBalances$Fie3, _currencyBalances$Fie4, _currencyBalances$Fie5, _currencyBalances$Fie6;\n\n  var _useActiveWeb3React = useActiveWeb3React(),\n      account = _useActiveWeb3React.account;\n\n  var _useProAmmMintState = useProAmmMintState(),\n      independentField = _useProAmmMintState.independentField,\n      typedValue = _useProAmmMintState.typedValue,\n      leftRangeTypedValue = _useProAmmMintState.leftRangeTypedValue,\n      rightRangeTypedValue = _useProAmmMintState.rightRangeTypedValue,\n      startPriceTypedValue = _useProAmmMintState.startPriceTypedValue;\n\n  var dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A; // currencies\n\n  var currencies = useMemo(function () {\n    var _ref;\n\n    return _ref = {}, _defineProperty(_ref, Field.CURRENCY_A, currencyA), _defineProperty(_ref, Field.CURRENCY_B, currencyB), _ref;\n  }, [currencyA, currencyB]); // formatted with tokens\n\n  var _useMemo = useMemo(function () {\n    return [currencyA === null || currencyA === void 0 ? void 0 : currencyA.wrapped, currencyB === null || currencyB === void 0 ? void 0 : currencyB.wrapped, baseCurrency === null || baseCurrency === void 0 ? void 0 : baseCurrency.wrapped];\n  }, [currencyA, currencyB, baseCurrency]),\n      _useMemo2 = _slicedToArray(_useMemo, 3),\n      tokenA = _useMemo2[0],\n      tokenB = _useMemo2[1],\n      baseToken = _useMemo2[2];\n\n  var _useMemo3 = useMemo(function () {\n    return tokenA && tokenB ? tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA] : [undefined, undefined];\n  }, [tokenA, tokenB]),\n      _useMemo4 = _slicedToArray(_useMemo3, 2),\n      token0 = _useMemo4[0],\n      token1 = _useMemo4[1]; // balances\n\n\n  var balances = useCurrencyBalances(account !== null && account !== void 0 ? account : undefined, useMemo(function () {\n    return [currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]];\n  }, [currencies]));\n  var currencyBalances = (_currencyBalances = {}, _defineProperty(_currencyBalances, Field.CURRENCY_A, balances[0]), _defineProperty(_currencyBalances, Field.CURRENCY_B, balances[1]), _currencyBalances); // pool\n\n  var _usePool = usePool(currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B], feeAmount),\n      _usePool2 = _slicedToArray(_usePool, 2),\n      poolState = _usePool2[0],\n      pool = _usePool2[1];\n\n  var noLiquidity = poolState === PoolState.NOT_EXISTS; // note to parse inputs in reverse\n\n  var invertPrice = Boolean(baseToken && token0 && !baseToken.equals(token0)); // always returns the price with 0 as base token\n\n  var price = useMemo(function () {\n    // if no liquidity use typed value\n    if (noLiquidity) {\n      var parsedQuoteAmount = tryParseAmount(startPriceTypedValue, invertPrice ? token0 : token1);\n\n      if (parsedQuoteAmount && token0 && token1) {\n        var _ref2;\n\n        var baseAmount = tryParseAmount('1', invertPrice ? token1 : token0);\n\n        var _price = baseAmount && parsedQuoteAmount ? new Price(baseAmount.currency, parsedQuoteAmount.currency, baseAmount.quotient, parsedQuoteAmount.quotient) : undefined;\n\n        return (_ref2 = invertPrice ? _price === null || _price === void 0 ? void 0 : _price.invert() : _price) !== null && _ref2 !== void 0 ? _ref2 : undefined;\n      }\n\n      return undefined;\n    } else {\n      // get the amount of quote currency\n      return pool && token0 ? pool.priceOf(token0) : undefined;\n    }\n  }, [noLiquidity, startPriceTypedValue, invertPrice, token1, token0, pool]); // check for invalid price input (converts to invalid ratio)\n\n  var invalidPrice = useMemo(function () {\n    var sqrtRatioX96 = price ? encodeSqrtRatioX96(price.numerator, price.denominator) : undefined;\n    return price && sqrtRatioX96 && !(JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO) && JSBI.lessThan(sqrtRatioX96, TickMath.MAX_SQRT_RATIO));\n  }, [price]); // used for ratio calculation when pool not initialized\n\n  var mockPool = useMemo(function () {\n    if (tokenA && tokenB && feeAmount && price && !invalidPrice) {\n      var currentTick = priceToClosestTick(price);\n      var currentSqrt = TickMath.getSqrtRatioAtTick(currentTick);\n      return new Pool(tokenA, tokenB, feeAmount, currentSqrt, JSBI.BigInt(0), JSBI.BigInt(0), currentTick, []);\n    } else {\n      return undefined;\n    }\n  }, [feeAmount, invalidPrice, price, tokenA, tokenB]); // if pool exists use it, if not use the mock pool\n\n  var poolForPosition = pool !== null && pool !== void 0 ? pool : mockPool; // lower and upper limits in the tick space for `feeAmount<Trans>\n\n  var tickSpaceLimits = useMemo(function () {\n    var _ref3;\n\n    return _ref3 = {}, _defineProperty(_ref3, Bound.LOWER, feeAmount ? nearestUsableTick(TickMath.MIN_TICK, TICK_SPACINGS[feeAmount]) : undefined), _defineProperty(_ref3, Bound.UPPER, feeAmount ? nearestUsableTick(TickMath.MAX_TICK, TICK_SPACINGS[feeAmount]) : undefined), _ref3;\n  }, [feeAmount]); // parse typed range values and determine closest ticks\n  // lower should always be a smaller tick\n\n  var ticks = useMemo(function () {\n    var _ref4;\n\n    //case NO invert\n    //      tickLower = tryParseTick(0, 1, left)\n    //      tickUpper = tryParseTick(0, 1, right)\n    //case invert\n    //      tickLower = tryParseTick(1, 0, right)\n    //      tickUpper = tryParseTick(1, 0, left)\n    //priceToClosestTick always return tick of token0/token1 => calc [1/right, 1/left] as price of token0/token1\n    return _ref4 = {}, _defineProperty(_ref4, Bound.LOWER, typeof (existingPosition === null || existingPosition === void 0 ? void 0 : existingPosition.tickLower) === 'number' ? existingPosition.tickLower : invertPrice && typeof rightRangeTypedValue === 'boolean' || !invertPrice && typeof leftRangeTypedValue === 'boolean' ? tickSpaceLimits[Bound.LOWER] : invertPrice ? tryParseTick(token1, token0, feeAmount, rightRangeTypedValue.toString()) : tryParseTick(token0, token1, feeAmount, leftRangeTypedValue.toString())), _defineProperty(_ref4, Bound.UPPER, typeof (existingPosition === null || existingPosition === void 0 ? void 0 : existingPosition.tickUpper) === 'number' ? existingPosition.tickUpper : !invertPrice && typeof rightRangeTypedValue === 'boolean' || invertPrice && typeof leftRangeTypedValue === 'boolean' ? tickSpaceLimits[Bound.UPPER] : invertPrice ? tryParseTick(token1, token0, feeAmount, leftRangeTypedValue.toString()) : tryParseTick(token0, token1, feeAmount, rightRangeTypedValue.toString())), _ref4;\n  }, [existingPosition, feeAmount, invertPrice, leftRangeTypedValue, rightRangeTypedValue, token0, token1, tickSpaceLimits]);\n\n  var _ref5 = ticks || {},\n      tickLower = _ref5[Bound.LOWER],\n      tickUpper = _ref5[Bound.UPPER]; // specifies whether the lower and upper ticks is at the exteme bounds\n\n\n  var ticksAtLimit = useMemo(function () {\n    var _ref6;\n\n    return _ref6 = {}, _defineProperty(_ref6, Bound.LOWER, feeAmount && tickLower === tickSpaceLimits.LOWER), _defineProperty(_ref6, Bound.UPPER, feeAmount && tickUpper === tickSpaceLimits.UPPER), _ref6;\n  }, [tickSpaceLimits, tickLower, tickUpper, feeAmount]); // mark invalid range\n\n  var invalidRange = Boolean(typeof tickLower === 'number' && typeof tickUpper === 'number' && tickLower >= tickUpper); // always returns the price with 0 as base token\n\n  var pricesAtTicks = useMemo(function () {\n    var _ref7;\n\n    return _ref7 = {}, _defineProperty(_ref7, Bound.LOWER, getTickToPrice(token0, token1, ticks[Bound.LOWER])), _defineProperty(_ref7, Bound.UPPER, getTickToPrice(token0, token1, ticks[Bound.UPPER])), _ref7;\n  }, [token0, token1, ticks]);\n  var lowerPrice = pricesAtTicks[Bound.LOWER],\n      upperPrice = pricesAtTicks[Bound.UPPER]; // liquidity range warning\n\n  var outOfRange = Boolean(!invalidRange && price && lowerPrice && upperPrice && (price.lessThan(lowerPrice) || price.greaterThan(upperPrice))); // amounts\n\n  var independentAmount = tryParseAmount(typedValue, currencies[independentField]);\n  var dependentAmount = useMemo(function () {\n    // we wrap the currencies just to get the price in terms of the other token\n    var wrappedIndependentAmount = independentAmount === null || independentAmount === void 0 ? void 0 : independentAmount.wrapped;\n    var dependentCurrency = dependentField === Field.CURRENCY_B ? currencyB : currencyA;\n\n    if (independentAmount && wrappedIndependentAmount && typeof tickLower === 'number' && typeof tickUpper === 'number' && poolForPosition) {\n      // if price is out of range or invalid range - return 0 (single deposit will be independent)\n      if (outOfRange || invalidRange) {\n        return undefined;\n      }\n\n      var _position = wrappedIndependentAmount.currency.equals(poolForPosition.token0) ? Position.fromAmount0({\n        pool: poolForPosition,\n        tickLower: tickLower,\n        tickUpper: tickUpper,\n        amount0: independentAmount.quotient,\n        useFullPrecision: true // we want full precision for the theoretical position\n\n      }) : Position.fromAmount1({\n        pool: poolForPosition,\n        tickLower: tickLower,\n        tickUpper: tickUpper,\n        amount1: independentAmount.quotient\n      });\n\n      var dependentTokenAmount = wrappedIndependentAmount.currency.equals(poolForPosition.token0) ? _position.amount1 : _position.amount0;\n      return dependentCurrency && CurrencyAmount.fromRawAmount(dependentCurrency, dependentTokenAmount.quotient);\n    }\n\n    return undefined;\n  }, [independentAmount, outOfRange, dependentField, currencyB, currencyA, tickLower, tickUpper, poolForPosition, invalidRange]);\n  var parsedAmounts = useMemo(function () {\n    var _ref8;\n\n    return _ref8 = {}, _defineProperty(_ref8, Field.CURRENCY_A, independentField === Field.CURRENCY_A ? independentAmount : dependentAmount), _defineProperty(_ref8, Field.CURRENCY_B, independentField === Field.CURRENCY_A ? dependentAmount : independentAmount), _ref8;\n  }, [dependentAmount, independentAmount, independentField]); // single deposit only if price is out of range\n\n  var deposit0Disabled = Boolean(typeof tickUpper === 'number' && poolForPosition && poolForPosition.tickCurrent >= tickUpper);\n  var deposit1Disabled = Boolean(typeof tickLower === 'number' && poolForPosition && poolForPosition.tickCurrent < tickLower); // sorted for token order\n\n  var depositADisabled = invalidRange || Boolean(deposit0Disabled && poolForPosition && tokenA && poolForPosition.token0.equals(tokenA) || deposit1Disabled && poolForPosition && tokenA && poolForPosition.token1.equals(tokenA));\n  var depositBDisabled = invalidRange || Boolean(deposit0Disabled && poolForPosition && tokenB && poolForPosition.token0.equals(tokenB) || deposit1Disabled && poolForPosition && tokenB && poolForPosition.token1.equals(tokenB)); // create position entity based on users selection\n\n  var position = useMemo(function () {\n    var _parsedAmounts, _parsedAmounts2;\n\n    if (!poolForPosition || !tokenA || !tokenB || typeof tickLower !== 'number' || typeof tickUpper !== 'number' || invalidRange) {\n      return undefined;\n    } // mark as 0 if disabled because out of range\n\n\n    var amount0 = !deposit0Disabled ? parsedAmounts === null || parsedAmounts === void 0 ? void 0 : (_parsedAmounts = parsedAmounts[tokenA.equals(poolForPosition.token0) ? Field.CURRENCY_A : Field.CURRENCY_B]) === null || _parsedAmounts === void 0 ? void 0 : _parsedAmounts.quotient : BIG_INT_ZERO;\n    var amount1 = !deposit1Disabled ? parsedAmounts === null || parsedAmounts === void 0 ? void 0 : (_parsedAmounts2 = parsedAmounts[tokenA.equals(poolForPosition.token0) ? Field.CURRENCY_B : Field.CURRENCY_A]) === null || _parsedAmounts2 === void 0 ? void 0 : _parsedAmounts2.quotient : BIG_INT_ZERO;\n\n    if (amount0 !== undefined && amount1 !== undefined) {\n      return Position.fromAmounts({\n        pool: poolForPosition,\n        tickLower: tickLower,\n        tickUpper: tickUpper,\n        amount0: amount0,\n        amount1: amount1,\n        useFullPrecision: true // we want full precision for the theoretical position\n\n      });\n    } else {\n      return undefined;\n    }\n  }, [parsedAmounts, poolForPosition, tokenA, tokenB, deposit0Disabled, deposit1Disabled, invalidRange, tickLower, tickUpper]);\n  var amount0Unlock = price && noLiquidity ? FullMath.mulDiv(SqrtPriceMath.getAmount0Unlock(encodeSqrtRatioX96(price.numerator, price.denominator)), JSBI.BigInt('105'), JSBI.BigInt('100')) : JSBI.BigInt('0');\n  var amount1Unlock = price && noLiquidity ? FullMath.mulDiv(SqrtPriceMath.getAmount1Unlock(encodeSqrtRatioX96(price.numerator, price.denominator)), JSBI.BigInt('105'), JSBI.BigInt('100')) : JSBI.BigInt('0');\n  var errorMessage;\n\n  if (!account) {\n    errorMessage = /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Connect Wallet\"\n    }, void 0, false, void 0, this);\n  }\n\n  if (poolState === PoolState.INVALID) {\n    var _errorMessage;\n\n    errorMessage = (_errorMessage = errorMessage) !== null && _errorMessage !== void 0 ? _errorMessage : /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Invalid pair\"\n    }, void 0, false, void 0, this);\n  }\n\n  if (invalidPrice) {\n    var _errorMessage2;\n\n    errorMessage = (_errorMessage2 = errorMessage) !== null && _errorMessage2 !== void 0 ? _errorMessage2 : /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Invalid price input\"\n    }, void 0, false, void 0, this);\n  }\n\n  if (!parsedAmounts[Field.CURRENCY_A] && !depositADisabled || !parsedAmounts[Field.CURRENCY_B] && !depositBDisabled) {\n    var _errorMessage3;\n\n    errorMessage = (_errorMessage3 = errorMessage) !== null && _errorMessage3 !== void 0 ? _errorMessage3 : /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Enter an amount\"\n    }, void 0, false, void 0, this);\n  }\n\n  var currencyAAmount = parsedAmounts[Field.CURRENCY_A],\n      currencyBAmount = parsedAmounts[Field.CURRENCY_B];\n\n  if (currencyAAmount && currencyBalances !== null && currencyBalances !== void 0 && (_currencyBalances$Fie = currencyBalances[Field.CURRENCY_A]) !== null && _currencyBalances$Fie !== void 0 && _currencyBalances$Fie.lessThan(currencyAAmount) || noLiquidity && depositADisabled && currencyBalances !== null && currencyBalances !== void 0 && (_currencyBalances$Fie2 = currencyBalances[Field.CURRENCY_A]) !== null && _currencyBalances$Fie2 !== void 0 && _currencyBalances$Fie2.equalTo(ZERO)) {\n    var _currencies$Field$CUR;\n\n    errorMessage = /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Insufficient {0} balance\",\n      values: {\n        0: (_currencies$Field$CUR = currencies[Field.CURRENCY_A]) === null || _currencies$Field$CUR === void 0 ? void 0 : _currencies$Field$CUR.symbol\n      }\n    }, void 0, false, void 0, this);\n  } else if (noLiquidity && currencyAAmount && currencyA && currencyBalances !== null && currencyBalances !== void 0 && (_currencyBalances$Fie3 = currencyBalances[Field.CURRENCY_A]) !== null && _currencyBalances$Fie3 !== void 0 && _currencyBalances$Fie3.lessThan(currencyAAmount.add(CurrencyAmount.fromRawAmount(currencyA, !invertPrice ? amount0Unlock : amount1Unlock)))) {\n    var _currencies$Field$CUR2;\n\n    errorMessage = /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Insufficient {0} balance.\",\n      values: {\n        0: (_currencies$Field$CUR2 = currencies[Field.CURRENCY_A]) === null || _currencies$Field$CUR2 === void 0 ? void 0 : _currencies$Field$CUR2.symbol\n      }\n    }, void 0, false, void 0, this);\n  }\n\n  if (currencyBAmount && currencyBalances !== null && currencyBalances !== void 0 && (_currencyBalances$Fie4 = currencyBalances[Field.CURRENCY_B]) !== null && _currencyBalances$Fie4 !== void 0 && _currencyBalances$Fie4.lessThan(currencyBAmount) || noLiquidity && depositBDisabled && currencyBalances !== null && currencyBalances !== void 0 && (_currencyBalances$Fie5 = currencyBalances[Field.CURRENCY_B]) !== null && _currencyBalances$Fie5 !== void 0 && _currencyBalances$Fie5.equalTo(ZERO)) {\n    var _currencies$Field$CUR3;\n\n    errorMessage = /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Insufficient {0} balance\",\n      values: {\n        0: (_currencies$Field$CUR3 = currencies[Field.CURRENCY_B]) === null || _currencies$Field$CUR3 === void 0 ? void 0 : _currencies$Field$CUR3.symbol\n      }\n    }, void 0, false, void 0, this);\n  } else if (noLiquidity && currencyBAmount && currencyB && currencyBalances !== null && currencyBalances !== void 0 && (_currencyBalances$Fie6 = currencyBalances[Field.CURRENCY_B]) !== null && _currencyBalances$Fie6 !== void 0 && _currencyBalances$Fie6.lessThan(currencyBAmount.add(CurrencyAmount.fromRawAmount(currencyB, !invertPrice ? amount1Unlock : amount0Unlock)))) {\n    var _currencies$Field$CUR4;\n\n    errorMessage = /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Insufficient {0} balance.\",\n      values: {\n        0: (_currencies$Field$CUR4 = currencies[Field.CURRENCY_B]) === null || _currencies$Field$CUR4 === void 0 ? void 0 : _currencies$Field$CUR4.symbol\n      }\n    }, void 0, false, void 0, this);\n  }\n\n  var invalidPool = poolState === PoolState.INVALID;\n  return {\n    dependentField: dependentField,\n    currencies: currencies,\n    pool: pool,\n    poolState: poolState,\n    currencyBalances: currencyBalances,\n    parsedAmounts: parsedAmounts,\n    ticks: ticks,\n    price: price,\n    pricesAtTicks: pricesAtTicks,\n    position: position,\n    noLiquidity: noLiquidity,\n    errorMessage: errorMessage,\n    invalidPool: invalidPool,\n    invalidRange: invalidRange,\n    outOfRange: outOfRange,\n    depositADisabled: depositADisabled,\n    depositBDisabled: depositBDisabled,\n    invertPrice: invertPrice,\n    ticksAtLimit: ticksAtLimit,\n    amount0Unlock: amount0Unlock,\n    amount1Unlock: amount1Unlock\n  };\n}\n\n_s3(useProAmmDerivedMintInfo, \"WEMiS6p99Js98XDUFaZBSahh1U0=\", false, function () {\n  return [useActiveWeb3React, useProAmmMintState, useCurrencyBalances, usePool];\n});\n\nexport function useRangeHopCallbacks(baseCurrency, quoteCurrency, feeAmount, tickLower, tickUpper, pool, price) {\n  _s4();\n\n  var dispatch = useAppDispatch();\n\n  var _useProAmmMintState2 = useProAmmMintState(),\n      startPriceTypedValue = _useProAmmMintState2.startPriceTypedValue;\n\n  var baseToken = useMemo(function () {\n    return baseCurrency === null || baseCurrency === void 0 ? void 0 : baseCurrency.wrapped;\n  }, [baseCurrency]);\n  var quoteToken = useMemo(function () {\n    return quoteCurrency === null || quoteCurrency === void 0 ? void 0 : quoteCurrency.wrapped;\n  }, [quoteCurrency]);\n  var initTick; // if (price) {\n  //   initTick = priceToClosestTick(price)\n  // }\n\n  if (pool) {\n    initTick = pool.tickCurrent;\n  } else {\n    initTick = tryParseTick(baseCurrency === null || baseCurrency === void 0 ? void 0 : baseCurrency.wrapped, quoteCurrency === null || quoteCurrency === void 0 ? void 0 : quoteCurrency.wrapped, feeAmount, startPriceTypedValue);\n  }\n\n  var getDecrementLower = useCallback(function () {\n    if (baseToken && quoteToken && feeAmount) {\n      if (typeof tickLower === 'number' && tickLower < TickMath.MAX_TICK - 2 && tickLower > TickMath.MIN_TICK + 2) {\n        var newPrice = tickToPrice(baseToken, quoteToken, tickLower - TICK_SPACINGS[feeAmount]);\n        return newPrice.toSignificant(9, undefined, Rounding.ROUND_UP);\n      } else if (initTick) {\n        var _newPrice = tickToPrice(baseToken, quoteToken, initTick - TICK_SPACINGS[feeAmount]);\n\n        return _newPrice.toSignificant(9, undefined, Rounding.ROUND_UP);\n      }\n    }\n\n    return '';\n  }, [baseToken, quoteToken, tickLower, feeAmount, initTick]);\n  var getIncrementLower = useCallback(function () {\n    if (baseToken && quoteToken && feeAmount) {\n      if (typeof tickLower === 'number' && tickLower < TickMath.MAX_TICK - 2 && tickLower > TickMath.MIN_TICK + 2) {\n        var newPrice = tickToPrice(baseToken, quoteToken, tickLower + TICK_SPACINGS[feeAmount]);\n        return newPrice.toSignificant(9, undefined, Rounding.ROUND_UP);\n      } else if (initTick) {\n        var _newPrice2 = tickToPrice(baseToken, quoteToken, initTick + TICK_SPACINGS[feeAmount]);\n\n        return _newPrice2.toSignificant(9, undefined, Rounding.ROUND_UP);\n      }\n    }\n\n    return '';\n  }, [baseToken, quoteToken, tickLower, feeAmount, initTick]);\n  var getDecrementUpper = useCallback(function () {\n    if (baseToken && quoteToken && feeAmount) {\n      if (typeof tickUpper === 'number' && tickUpper < TickMath.MAX_TICK - 2 && tickUpper > TickMath.MIN_TICK + 2) {\n        var newPrice = tickToPrice(baseToken, quoteToken, tickUpper - TICK_SPACINGS[feeAmount]);\n        return newPrice.toSignificant(9, undefined, Rounding.ROUND_UP);\n      } else if (initTick) {\n        var _newPrice3 = tickToPrice(baseToken, quoteToken, initTick - TICK_SPACINGS[feeAmount]);\n\n        return _newPrice3.toSignificant(9, undefined, Rounding.ROUND_UP);\n      }\n    }\n\n    return '';\n  }, [baseToken, quoteToken, tickUpper, feeAmount, initTick]);\n  var getIncrementUpper = useCallback(function () {\n    if (baseToken && quoteToken && feeAmount) {\n      if (typeof tickUpper === 'number' && tickUpper < TickMath.MAX_TICK - 2 && tickUpper > TickMath.MIN_TICK + 2) {\n        var newPrice = tickToPrice(baseToken, quoteToken, tickUpper + TICK_SPACINGS[feeAmount]);\n        return newPrice.toSignificant(9, undefined, Rounding.ROUND_UP);\n      } else if (initTick) {\n        var _newPrice4 = tickToPrice(baseToken, quoteToken, initTick + TICK_SPACINGS[feeAmount]);\n\n        return _newPrice4.toSignificant(9, undefined, Rounding.ROUND_UP);\n      }\n    }\n\n    return '';\n  }, [baseToken, quoteToken, tickUpper, feeAmount, initTick]);\n  var getSetFullRange = useCallback(function () {\n    dispatch(setFullRange());\n  }, [dispatch]);\n  return {\n    getDecrementLower: getDecrementLower,\n    getIncrementLower: getIncrementLower,\n    getDecrementUpper: getDecrementUpper,\n    getIncrementUpper: getIncrementUpper,\n    getSetFullRange: getSetFullRange\n  };\n}\n\n_s4(useRangeHopCallbacks, \"S3NO7P4IVPdvAjhfi/M/Iqer0Gk=\", false, function () {\n  return [useAppDispatch, useProAmmMintState];\n});","map":{"version":3,"names":["ZERO","CurrencyAmount","Price","Rounding","FullMath","Pool","Position","SqrtPriceMath","TICK_SPACINGS","TickMath","encodeSqrtRatioX96","nearestUsableTick","priceToClosestTick","tickToPrice","JSBI","React","useCallback","useMemo","useActiveWeb3React","PoolState","usePool","useAppDispatch","useAppSelector","tryParseAmount","useCurrencyBalances","getTickToPrice","BIG_INT_ZERO","Bound","Field","setFullRange","typeInput","typeLeftRangeInput","typeRightRangeInput","typeStartPriceInput","tryParseTick","useProAmmMintState","state","mintV2","useProAmmMintActionHandlers","noLiquidity","dispatch","onFieldAInput","typedValue","field","CURRENCY_A","onFieldBInput","CURRENCY_B","onLeftRangeInput","onRightRangeInput","onStartPriceInput","useProAmmDerivedMintInfo","currencyA","currencyB","feeAmount","baseCurrency","existingPosition","account","independentField","leftRangeTypedValue","rightRangeTypedValue","startPriceTypedValue","dependentField","currencies","wrapped","tokenA","tokenB","baseToken","sortsBefore","undefined","token0","token1","balances","currencyBalances","poolState","pool","NOT_EXISTS","invertPrice","Boolean","equals","price","parsedQuoteAmount","baseAmount","currency","quotient","invert","priceOf","invalidPrice","sqrtRatioX96","numerator","denominator","greaterThanOrEqual","MIN_SQRT_RATIO","lessThan","MAX_SQRT_RATIO","mockPool","currentTick","currentSqrt","getSqrtRatioAtTick","BigInt","poolForPosition","tickSpaceLimits","LOWER","MIN_TICK","UPPER","MAX_TICK","ticks","tickLower","toString","tickUpper","ticksAtLimit","invalidRange","pricesAtTicks","lowerPrice","upperPrice","outOfRange","greaterThan","independentAmount","dependentAmount","wrappedIndependentAmount","dependentCurrency","position","fromAmount0","amount0","useFullPrecision","fromAmount1","amount1","dependentTokenAmount","fromRawAmount","parsedAmounts","deposit0Disabled","tickCurrent","deposit1Disabled","depositADisabled","depositBDisabled","fromAmounts","amount0Unlock","mulDiv","getAmount0Unlock","amount1Unlock","getAmount1Unlock","errorMessage","INVALID","currencyAAmount","currencyBAmount","equalTo","symbol","add","invalidPool","useRangeHopCallbacks","quoteCurrency","quoteToken","initTick","getDecrementLower","newPrice","toSignificant","ROUND_UP","getIncrementLower","getDecrementUpper","getIncrementUpper","getSetFullRange"],"sources":["/Applications/XAMPP/voxel-interface/src/state/mint/proamm/hooks.tsx"],"sourcesContent":["import { ZERO } from '@kyberswap/ks-sdk-classic'\nimport { Currency, CurrencyAmount, Price, Rounding, Token } from '@kyberswap/ks-sdk-core'\nimport {\n  FeeAmount,\n  FullMath,\n  Pool,\n  Position,\n  SqrtPriceMath,\n  TICK_SPACINGS,\n  TickMath,\n  encodeSqrtRatioX96,\n  nearestUsableTick,\n  priceToClosestTick,\n  tickToPrice,\n} from '@kyberswap/ks-sdk-elastic'\nimport { Trans } from '@lingui/macro'\nimport JSBI from 'jsbi'\nimport React, { ReactNode, useCallback, useMemo } from 'react'\n\nimport { useActiveWeb3React } from 'hooks'\nimport { PoolState, usePool } from 'hooks/usePools'\nimport { useAppDispatch, useAppSelector } from 'state/hooks'\nimport { tryParseAmount } from 'state/swap/hooks'\nimport { useCurrencyBalances } from 'state/wallet/hooks'\nimport { getTickToPrice } from 'utils/getTickToPrice'\n\nimport { BIG_INT_ZERO } from '../../../constants'\nimport { AppState } from '../../index'\nimport {\n  Bound,\n  Field,\n  setFullRange,\n  typeInput,\n  typeLeftRangeInput,\n  typeRightRangeInput,\n  typeStartPriceInput,\n} from './actions'\nimport { tryParseTick } from './utils'\n\nexport function useProAmmMintState(): AppState['mintV2'] {\n  return useAppSelector(state => state.mintV2)\n}\n\nexport function useProAmmMintActionHandlers(noLiquidity: boolean | undefined): {\n  onFieldAInput: (typedValue: string) => void\n  onFieldBInput: (typedValue: string) => void\n  onLeftRangeInput: (typedValue: string) => void\n  onRightRangeInput: (typedValue: string) => void\n  onStartPriceInput: (typedValue: string) => void\n} {\n  const dispatch = useAppDispatch()\n  const onFieldAInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeInput({ field: Field.CURRENCY_A, typedValue, noLiquidity: noLiquidity === true }))\n    },\n    [dispatch, noLiquidity],\n  )\n\n  const onFieldBInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeInput({ field: Field.CURRENCY_B, typedValue, noLiquidity: noLiquidity === true }))\n    },\n    [dispatch, noLiquidity],\n  )\n\n  const onLeftRangeInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeLeftRangeInput({ typedValue }))\n    },\n    [dispatch],\n  )\n\n  const onRightRangeInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeRightRangeInput({ typedValue }))\n    },\n    [dispatch],\n  )\n\n  const onStartPriceInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeStartPriceInput({ typedValue }))\n    },\n    [dispatch],\n  )\n  return {\n    onFieldAInput,\n    onFieldBInput,\n    onLeftRangeInput,\n    onRightRangeInput,\n    onStartPriceInput,\n  }\n}\n\nexport function useProAmmDerivedMintInfo(\n  currencyA?: Currency,\n  currencyB?: Currency,\n  feeAmount?: FeeAmount,\n  baseCurrency?: Currency,\n  // override for existing position\n  existingPosition?: Position,\n): {\n  pool?: Pool | null\n  poolState: PoolState\n  ticks: { [bound in Bound]?: number | undefined }\n  price?: Price<Token, Token>\n  pricesAtTicks: {\n    [bound in Bound]?: Price<Token, Token> | undefined\n  }\n  currencies: { [field in Field]?: Currency }\n  currencyBalances: { [field in Field]?: CurrencyAmount<Currency> }\n  dependentField: Field\n  parsedAmounts: { [field in Field]?: CurrencyAmount<Currency> }\n  position: Position | undefined\n  noLiquidity?: boolean\n  errorMessage?: ReactNode\n  invalidPool: boolean\n  outOfRange: boolean\n  invalidRange: boolean\n  depositADisabled: boolean\n  depositBDisabled: boolean\n  invertPrice: boolean\n  ticksAtLimit: { [bound in Bound]?: boolean | undefined }\n  amount0Unlock: JSBI\n  amount1Unlock: JSBI\n} {\n  const { account } = useActiveWeb3React()\n  const { independentField, typedValue, leftRangeTypedValue, rightRangeTypedValue, startPriceTypedValue } =\n    useProAmmMintState()\n  const dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A\n\n  // currencies\n  const currencies: { [field in Field]?: Currency } = useMemo(\n    () => ({\n      [Field.CURRENCY_A]: currencyA,\n      [Field.CURRENCY_B]: currencyB,\n    }),\n    [currencyA, currencyB],\n  )\n  // formatted with tokens\n  const [tokenA, tokenB, baseToken] = useMemo(\n    () => [currencyA?.wrapped, currencyB?.wrapped, baseCurrency?.wrapped],\n    [currencyA, currencyB, baseCurrency],\n  )\n\n  const [token0, token1] = useMemo(\n    () =>\n      tokenA && tokenB ? (tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA]) : [undefined, undefined],\n    [tokenA, tokenB],\n  )\n  // balances\n  const balances = useCurrencyBalances(\n    account ?? undefined,\n    useMemo(() => [currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]], [currencies]),\n  )\n  const currencyBalances: { [field in Field]?: CurrencyAmount<Currency> } = {\n    [Field.CURRENCY_A]: balances[0],\n    [Field.CURRENCY_B]: balances[1],\n  }\n\n  // pool\n  const [poolState, pool] = usePool(currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B], feeAmount)\n\n  const noLiquidity = poolState === PoolState.NOT_EXISTS\n  // note to parse inputs in reverse\n  const invertPrice = Boolean(baseToken && token0 && !baseToken.equals(token0))\n\n  // always returns the price with 0 as base token\n  const price: Price<Token, Token> | undefined = useMemo(() => {\n    // if no liquidity use typed value\n    if (noLiquidity) {\n      const parsedQuoteAmount = tryParseAmount(startPriceTypedValue, invertPrice ? token0 : token1)\n      if (parsedQuoteAmount && token0 && token1) {\n        const baseAmount = tryParseAmount('1', invertPrice ? token1 : token0)\n        const price =\n          baseAmount && parsedQuoteAmount\n            ? new Price(\n                baseAmount.currency,\n                parsedQuoteAmount.currency,\n                baseAmount.quotient,\n                parsedQuoteAmount.quotient,\n              )\n            : undefined\n        return (invertPrice ? price?.invert() : price) ?? undefined\n      }\n      return undefined\n    } else {\n      // get the amount of quote currency\n      return pool && token0 ? pool.priceOf(token0) : undefined\n    }\n  }, [noLiquidity, startPriceTypedValue, invertPrice, token1, token0, pool])\n  // check for invalid price input (converts to invalid ratio)\n  const invalidPrice = useMemo(() => {\n    const sqrtRatioX96 = price ? encodeSqrtRatioX96(price.numerator, price.denominator) : undefined\n    return (\n      price &&\n      sqrtRatioX96 &&\n      !(\n        JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO) &&\n        JSBI.lessThan(sqrtRatioX96, TickMath.MAX_SQRT_RATIO)\n      )\n    )\n  }, [price])\n  // used for ratio calculation when pool not initialized\n  const mockPool = useMemo(() => {\n    if (tokenA && tokenB && feeAmount && price && !invalidPrice) {\n      const currentTick = priceToClosestTick(price)\n      const currentSqrt = TickMath.getSqrtRatioAtTick(currentTick)\n      return new Pool(tokenA, tokenB, feeAmount, currentSqrt, JSBI.BigInt(0), JSBI.BigInt(0), currentTick, [])\n    } else {\n      return undefined\n    }\n  }, [feeAmount, invalidPrice, price, tokenA, tokenB])\n\n  // if pool exists use it, if not use the mock pool\n  const poolForPosition: Pool | undefined = pool ?? mockPool\n\n  // lower and upper limits in the tick space for `feeAmount<Trans>\n  const tickSpaceLimits: {\n    [bound in Bound]: number | undefined\n  } = useMemo(\n    () => ({\n      [Bound.LOWER]: feeAmount ? nearestUsableTick(TickMath.MIN_TICK, TICK_SPACINGS[feeAmount]) : undefined,\n      [Bound.UPPER]: feeAmount ? nearestUsableTick(TickMath.MAX_TICK, TICK_SPACINGS[feeAmount]) : undefined,\n    }),\n    [feeAmount],\n  )\n\n  // parse typed range values and determine closest ticks\n  // lower should always be a smaller tick\n  const ticks: {\n    [key: string]: number | undefined\n  } = useMemo(() => {\n    //case NO invert\n    //      tickLower = tryParseTick(0, 1, left)\n    //      tickUpper = tryParseTick(0, 1, right)\n    //case invert\n    //      tickLower = tryParseTick(1, 0, right)\n    //      tickUpper = tryParseTick(1, 0, left)\n    //priceToClosestTick always return tick of token0/token1 => calc [1/right, 1/left] as price of token0/token1\n    return {\n      [Bound.LOWER]:\n        typeof existingPosition?.tickLower === 'number'\n          ? existingPosition.tickLower\n          : (invertPrice && typeof rightRangeTypedValue === 'boolean') ||\n            (!invertPrice && typeof leftRangeTypedValue === 'boolean')\n          ? tickSpaceLimits[Bound.LOWER]\n          : invertPrice\n          ? tryParseTick(token1, token0, feeAmount, rightRangeTypedValue.toString())\n          : tryParseTick(token0, token1, feeAmount, leftRangeTypedValue.toString()),\n      [Bound.UPPER]:\n        typeof existingPosition?.tickUpper === 'number'\n          ? existingPosition.tickUpper\n          : (!invertPrice && typeof rightRangeTypedValue === 'boolean') ||\n            (invertPrice && typeof leftRangeTypedValue === 'boolean')\n          ? tickSpaceLimits[Bound.UPPER]\n          : invertPrice\n          ? tryParseTick(token1, token0, feeAmount, leftRangeTypedValue.toString())\n          : tryParseTick(token0, token1, feeAmount, rightRangeTypedValue.toString()),\n    }\n  }, [\n    existingPosition,\n    feeAmount,\n    invertPrice,\n    leftRangeTypedValue,\n    rightRangeTypedValue,\n    token0,\n    token1,\n    tickSpaceLimits,\n  ])\n\n  const { [Bound.LOWER]: tickLower, [Bound.UPPER]: tickUpper } = ticks || {}\n\n  // specifies whether the lower and upper ticks is at the exteme bounds\n  const ticksAtLimit = useMemo(\n    () => ({\n      [Bound.LOWER]: feeAmount && tickLower === tickSpaceLimits.LOWER,\n      [Bound.UPPER]: feeAmount && tickUpper === tickSpaceLimits.UPPER,\n    }),\n    [tickSpaceLimits, tickLower, tickUpper, feeAmount],\n  )\n\n  // mark invalid range\n  const invalidRange = Boolean(typeof tickLower === 'number' && typeof tickUpper === 'number' && tickLower >= tickUpper)\n\n  // always returns the price with 0 as base token\n  const pricesAtTicks = useMemo(() => {\n    return {\n      [Bound.LOWER]: getTickToPrice(token0, token1, ticks[Bound.LOWER]),\n      [Bound.UPPER]: getTickToPrice(token0, token1, ticks[Bound.UPPER]),\n    }\n  }, [token0, token1, ticks])\n  const { [Bound.LOWER]: lowerPrice, [Bound.UPPER]: upperPrice } = pricesAtTicks\n\n  // liquidity range warning\n  const outOfRange = Boolean(\n    !invalidRange && price && lowerPrice && upperPrice && (price.lessThan(lowerPrice) || price.greaterThan(upperPrice)),\n  )\n\n  // amounts\n  const independentAmount: CurrencyAmount<Currency> | undefined = tryParseAmount(\n    typedValue,\n    currencies[independentField],\n  )\n\n  const dependentAmount: CurrencyAmount<Currency> | undefined = useMemo(() => {\n    // we wrap the currencies just to get the price in terms of the other token\n    const wrappedIndependentAmount = independentAmount?.wrapped\n    const dependentCurrency = dependentField === Field.CURRENCY_B ? currencyB : currencyA\n    if (\n      independentAmount &&\n      wrappedIndependentAmount &&\n      typeof tickLower === 'number' &&\n      typeof tickUpper === 'number' &&\n      poolForPosition\n    ) {\n      // if price is out of range or invalid range - return 0 (single deposit will be independent)\n      if (outOfRange || invalidRange) {\n        return undefined\n      }\n\n      const position: Position | undefined = wrappedIndependentAmount.currency.equals(poolForPosition.token0)\n        ? Position.fromAmount0({\n            pool: poolForPosition,\n            tickLower,\n            tickUpper,\n            amount0: independentAmount.quotient,\n            useFullPrecision: true, // we want full precision for the theoretical position\n          })\n        : Position.fromAmount1({\n            pool: poolForPosition,\n            tickLower,\n            tickUpper,\n            amount1: independentAmount.quotient,\n          })\n\n      const dependentTokenAmount = wrappedIndependentAmount.currency.equals(poolForPosition.token0)\n        ? position.amount1\n        : position.amount0\n      return dependentCurrency && CurrencyAmount.fromRawAmount(dependentCurrency, dependentTokenAmount.quotient)\n    }\n    return undefined\n  }, [\n    independentAmount,\n    outOfRange,\n    dependentField,\n    currencyB,\n    currencyA,\n    tickLower,\n    tickUpper,\n    poolForPosition,\n    invalidRange,\n  ])\n\n  const parsedAmounts: { [field in Field]: CurrencyAmount<Currency> | undefined } = useMemo(() => {\n    return {\n      [Field.CURRENCY_A]: independentField === Field.CURRENCY_A ? independentAmount : dependentAmount,\n      [Field.CURRENCY_B]: independentField === Field.CURRENCY_A ? dependentAmount : independentAmount,\n    }\n  }, [dependentAmount, independentAmount, independentField])\n  // single deposit only if price is out of range\n  const deposit0Disabled = Boolean(\n    typeof tickUpper === 'number' && poolForPosition && poolForPosition.tickCurrent >= tickUpper,\n  )\n  const deposit1Disabled = Boolean(\n    typeof tickLower === 'number' && poolForPosition && poolForPosition.tickCurrent < tickLower,\n  )\n  // sorted for token order\n  const depositADisabled =\n    invalidRange ||\n    Boolean(\n      (deposit0Disabled && poolForPosition && tokenA && poolForPosition.token0.equals(tokenA)) ||\n        (deposit1Disabled && poolForPosition && tokenA && poolForPosition.token1.equals(tokenA)),\n    )\n  const depositBDisabled =\n    invalidRange ||\n    Boolean(\n      (deposit0Disabled && poolForPosition && tokenB && poolForPosition.token0.equals(tokenB)) ||\n        (deposit1Disabled && poolForPosition && tokenB && poolForPosition.token1.equals(tokenB)),\n    )\n\n  // create position entity based on users selection\n  const position: Position | undefined = useMemo(() => {\n    if (\n      !poolForPosition ||\n      !tokenA ||\n      !tokenB ||\n      typeof tickLower !== 'number' ||\n      typeof tickUpper !== 'number' ||\n      invalidRange\n    ) {\n      return undefined\n    }\n    // mark as 0 if disabled because out of range\n    const amount0 = !deposit0Disabled\n      ? parsedAmounts?.[tokenA.equals(poolForPosition.token0) ? Field.CURRENCY_A : Field.CURRENCY_B]?.quotient\n      : BIG_INT_ZERO\n    const amount1 = !deposit1Disabled\n      ? parsedAmounts?.[tokenA.equals(poolForPosition.token0) ? Field.CURRENCY_B : Field.CURRENCY_A]?.quotient\n      : BIG_INT_ZERO\n\n    if (amount0 !== undefined && amount1 !== undefined) {\n      return Position.fromAmounts({\n        pool: poolForPosition,\n        tickLower,\n        tickUpper,\n        amount0,\n        amount1,\n        useFullPrecision: true, // we want full precision for the theoretical position\n      })\n    } else {\n      return undefined\n    }\n  }, [\n    parsedAmounts,\n    poolForPosition,\n    tokenA,\n    tokenB,\n    deposit0Disabled,\n    deposit1Disabled,\n    invalidRange,\n    tickLower,\n    tickUpper,\n  ])\n\n  const amount0Unlock =\n    price && noLiquidity\n      ? FullMath.mulDiv(\n          SqrtPriceMath.getAmount0Unlock(encodeSqrtRatioX96(price.numerator, price.denominator)),\n          JSBI.BigInt('105'),\n          JSBI.BigInt('100'),\n        )\n      : JSBI.BigInt('0')\n  const amount1Unlock =\n    price && noLiquidity\n      ? FullMath.mulDiv(\n          SqrtPriceMath.getAmount1Unlock(encodeSqrtRatioX96(price.numerator, price.denominator)),\n          JSBI.BigInt('105'),\n          JSBI.BigInt('100'),\n        )\n      : JSBI.BigInt('0')\n  let errorMessage: ReactNode | undefined\n  if (!account) {\n    errorMessage = <Trans>Connect Wallet</Trans>\n  }\n\n  if (poolState === PoolState.INVALID) {\n    errorMessage = errorMessage ?? <Trans>Invalid pair</Trans>\n  }\n\n  if (invalidPrice) {\n    errorMessage = errorMessage ?? <Trans>Invalid price input</Trans>\n  }\n\n  if (\n    (!parsedAmounts[Field.CURRENCY_A] && !depositADisabled) ||\n    (!parsedAmounts[Field.CURRENCY_B] && !depositBDisabled)\n  ) {\n    errorMessage = errorMessage ?? <Trans>Enter an amount</Trans>\n  }\n\n  const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts\n\n  if (\n    (currencyAAmount && currencyBalances?.[Field.CURRENCY_A]?.lessThan(currencyAAmount)) ||\n    (noLiquidity && depositADisabled && currencyBalances?.[Field.CURRENCY_A]?.equalTo(ZERO))\n  ) {\n    errorMessage = <Trans>Insufficient {currencies[Field.CURRENCY_A]?.symbol} balance</Trans>\n  } else if (\n    noLiquidity &&\n    currencyAAmount &&\n    currencyA &&\n    currencyBalances?.[Field.CURRENCY_A]?.lessThan(\n      currencyAAmount.add(CurrencyAmount.fromRawAmount(currencyA, !invertPrice ? amount0Unlock : amount1Unlock)),\n    )\n  ) {\n    errorMessage = <Trans>Insufficient {currencies[Field.CURRENCY_A]?.symbol} balance.</Trans>\n  }\n\n  if (\n    (currencyBAmount && currencyBalances?.[Field.CURRENCY_B]?.lessThan(currencyBAmount)) ||\n    (noLiquidity && depositBDisabled && currencyBalances?.[Field.CURRENCY_B]?.equalTo(ZERO))\n  ) {\n    errorMessage = <Trans>Insufficient {currencies[Field.CURRENCY_B]?.symbol} balance</Trans>\n  } else if (\n    noLiquidity &&\n    currencyBAmount &&\n    currencyB &&\n    currencyBalances?.[Field.CURRENCY_B]?.lessThan(\n      currencyBAmount.add(CurrencyAmount.fromRawAmount(currencyB, !invertPrice ? amount1Unlock : amount0Unlock)),\n    )\n  ) {\n    errorMessage = <Trans>Insufficient {currencies[Field.CURRENCY_B]?.symbol} balance.</Trans>\n  }\n  const invalidPool = poolState === PoolState.INVALID\n\n  return {\n    dependentField,\n    currencies,\n    pool,\n    poolState,\n    currencyBalances,\n    parsedAmounts,\n    ticks,\n    price,\n    pricesAtTicks,\n    position,\n    noLiquidity,\n    errorMessage,\n    invalidPool,\n    invalidRange,\n    outOfRange,\n    depositADisabled,\n    depositBDisabled,\n    invertPrice,\n    ticksAtLimit,\n    amount0Unlock,\n    amount1Unlock,\n  }\n}\n\nexport function useRangeHopCallbacks(\n  baseCurrency: Currency | undefined,\n  quoteCurrency: Currency | undefined,\n  feeAmount: FeeAmount | undefined,\n  tickLower: number | undefined,\n  tickUpper: number | undefined,\n  pool?: Pool | undefined | null,\n  price?: Price<Token, Token> | undefined | null,\n) {\n  const dispatch = useAppDispatch()\n\n  const { startPriceTypedValue } = useProAmmMintState()\n  const baseToken = useMemo(() => baseCurrency?.wrapped, [baseCurrency])\n  const quoteToken = useMemo(() => quoteCurrency?.wrapped, [quoteCurrency])\n\n  let initTick: number | undefined\n  // if (price) {\n  //   initTick = priceToClosestTick(price)\n  // }\n\n  if (pool) {\n    initTick = pool.tickCurrent\n  } else {\n    initTick = tryParseTick(baseCurrency?.wrapped, quoteCurrency?.wrapped, feeAmount, startPriceTypedValue)\n  }\n\n  const getDecrementLower = useCallback(() => {\n    if (baseToken && quoteToken && feeAmount) {\n      if (typeof tickLower === 'number' && tickLower < TickMath.MAX_TICK - 2 && tickLower > TickMath.MIN_TICK + 2) {\n        const newPrice = tickToPrice(baseToken, quoteToken, tickLower - TICK_SPACINGS[feeAmount])\n        return newPrice.toSignificant(9, undefined, Rounding.ROUND_UP)\n      } else if (initTick) {\n        const newPrice = tickToPrice(baseToken, quoteToken, initTick - TICK_SPACINGS[feeAmount])\n        return newPrice.toSignificant(9, undefined, Rounding.ROUND_UP)\n      }\n    }\n    return ''\n  }, [baseToken, quoteToken, tickLower, feeAmount, initTick])\n\n  const getIncrementLower = useCallback(() => {\n    if (baseToken && quoteToken && feeAmount) {\n      if (typeof tickLower === 'number' && tickLower < TickMath.MAX_TICK - 2 && tickLower > TickMath.MIN_TICK + 2) {\n        const newPrice = tickToPrice(baseToken, quoteToken, tickLower + TICK_SPACINGS[feeAmount])\n        return newPrice.toSignificant(9, undefined, Rounding.ROUND_UP)\n      } else if (initTick) {\n        const newPrice = tickToPrice(baseToken, quoteToken, initTick + TICK_SPACINGS[feeAmount])\n        return newPrice.toSignificant(9, undefined, Rounding.ROUND_UP)\n      }\n    }\n    return ''\n  }, [baseToken, quoteToken, tickLower, feeAmount, initTick])\n\n  const getDecrementUpper = useCallback(() => {\n    if (baseToken && quoteToken && feeAmount) {\n      if (typeof tickUpper === 'number' && tickUpper < TickMath.MAX_TICK - 2 && tickUpper > TickMath.MIN_TICK + 2) {\n        const newPrice = tickToPrice(baseToken, quoteToken, tickUpper - TICK_SPACINGS[feeAmount])\n        return newPrice.toSignificant(9, undefined, Rounding.ROUND_UP)\n      } else if (initTick) {\n        const newPrice = tickToPrice(baseToken, quoteToken, initTick - TICK_SPACINGS[feeAmount])\n        return newPrice.toSignificant(9, undefined, Rounding.ROUND_UP)\n      }\n    }\n    return ''\n  }, [baseToken, quoteToken, tickUpper, feeAmount, initTick])\n\n  const getIncrementUpper = useCallback(() => {\n    if (baseToken && quoteToken && feeAmount) {\n      if (typeof tickUpper === 'number' && tickUpper < TickMath.MAX_TICK - 2 && tickUpper > TickMath.MIN_TICK + 2) {\n        const newPrice = tickToPrice(baseToken, quoteToken, tickUpper + TICK_SPACINGS[feeAmount])\n        return newPrice.toSignificant(9, undefined, Rounding.ROUND_UP)\n      } else if (initTick) {\n        const newPrice = tickToPrice(baseToken, quoteToken, initTick + TICK_SPACINGS[feeAmount])\n        return newPrice.toSignificant(9, undefined, Rounding.ROUND_UP)\n      }\n    }\n    return ''\n  }, [baseToken, quoteToken, tickUpper, feeAmount, initTick])\n\n  const getSetFullRange = useCallback(() => {\n    dispatch(setFullRange())\n  }, [dispatch])\n\n  return { getDecrementLower, getIncrementLower, getDecrementUpper, getIncrementUpper, getSetFullRange }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}