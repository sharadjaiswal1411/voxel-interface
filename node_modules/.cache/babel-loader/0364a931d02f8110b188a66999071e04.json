{"ast":null,"code":"import { getAddress } from 'ethers/lib/utils';\nimport { NETWORKS_INFO } from 'constants/networks';\nimport { MAP_TOKEN_HAS_MULTI_BY_NETWORK, WHITE_LIST_TOKEN_INFO_PAIR } from 'constants/tokenLists/token-info';\n/**\n * hard code: ex: usdt => usdt_e, ... if network has multi symbol same name base on network\n * @param network ex: poylgon, ...\n * @param value symbol name, ex: usdt, ...\n * @returns\n */\n\nexport var convertSymbol = function convertSymbol(network, value) {\n  var mapData = MAP_TOKEN_HAS_MULTI_BY_NETWORK[network];\n\n  if (mapData) {\n    var newValue = mapData[value];\n    if (newValue) return newValue;\n  }\n\n  return value;\n};\n/**\n * check url format /network/sym1-to-sym2, sym1 vs sym2 is in whitelist\n * @param chainId\n * @param symbol1 ex: knc\n * @param symbol2 ex: usdt\n * @returns\n */\n\nexport var checkPairInWhiteList = function checkPairInWhiteList(chainId, symbol1, symbol2) {\n  if (!chainId) {\n    return {\n      isInWhiteList: false,\n      data: {},\n      canonicalUrl: ''\n    };\n  }\n\n  var mapByNetwork = WHITE_LIST_TOKEN_INFO_PAIR[chainId];\n  var str1 = \"\".concat(symbol1, \"-to-\").concat(symbol2);\n  var str2 = \"\".concat(symbol2, \"-to-\").concat(symbol1);\n  var data = mapByNetwork ? mapByNetwork[str1] || mapByNetwork[str2] : null;\n  var isInWhiteList = !!data;\n  var pathCanonicalUrl = mapByNetwork && mapByNetwork[str1] ? str1 : str2;\n  var canonicalUrl = isInWhiteList ? \"\".concat(window.location.protocol, \"//\").concat(window.location.host, \"/swap/\").concat(NETWORKS_INFO[chainId].route, \"/\").concat(pathCanonicalUrl) : '';\n  return {\n    isInWhiteList: isInWhiteList,\n    data: data || {},\n    canonicalUrl: canonicalUrl\n  };\n};\nexport var getFormattedAddress = function getFormattedAddress(address, fallback) {\n  try {\n    return getAddress(address || '');\n  } catch (e) {\n    return fallback || address || '';\n  }\n};","map":{"version":3,"names":["getAddress","NETWORKS_INFO","MAP_TOKEN_HAS_MULTI_BY_NETWORK","WHITE_LIST_TOKEN_INFO_PAIR","convertSymbol","network","value","mapData","newValue","checkPairInWhiteList","chainId","symbol1","symbol2","isInWhiteList","data","canonicalUrl","mapByNetwork","str1","str2","pathCanonicalUrl","window","location","protocol","host","route","getFormattedAddress","address","fallback","e"],"sources":["/Applications/XAMPP/voxel-interface/src/utils/tokenInfo.ts"],"sourcesContent":["import { ChainId } from '@kyberswap/ks-sdk-core'\nimport { getAddress } from 'ethers/lib/utils'\n\nimport { NETWORKS_INFO } from 'constants/networks'\nimport { MAP_TOKEN_HAS_MULTI_BY_NETWORK, WHITE_LIST_TOKEN_INFO_PAIR } from 'constants/tokenLists/token-info'\n\n/**\n * hard code: ex: usdt => usdt_e, ... if network has multi symbol same name base on network\n * @param network ex: poylgon, ...\n * @param value symbol name, ex: usdt, ...\n * @returns\n */\nexport const convertSymbol = (network: string, value: string) => {\n  const mapData = MAP_TOKEN_HAS_MULTI_BY_NETWORK[network]\n  if (mapData) {\n    const newValue = mapData[value]\n    if (newValue) return newValue\n  }\n  return value\n}\n\n/**\n * check url format /network/sym1-to-sym2, sym1 vs sym2 is in whitelist\n * @param chainId\n * @param symbol1 ex: knc\n * @param symbol2 ex: usdt\n * @returns\n */\nexport const checkPairInWhiteList = (chainId: ChainId | undefined, symbol1: string, symbol2: string) => {\n  if (!chainId) {\n    return { isInWhiteList: false, data: {}, canonicalUrl: '' }\n  }\n  const mapByNetwork = WHITE_LIST_TOKEN_INFO_PAIR[chainId]\n  const str1 = `${symbol1}-to-${symbol2}`\n  const str2 = `${symbol2}-to-${symbol1}`\n  const data = mapByNetwork ? mapByNetwork[str1] || mapByNetwork[str2] : null\n  const isInWhiteList = !!data\n\n  const pathCanonicalUrl = mapByNetwork && mapByNetwork[str1] ? str1 : str2\n  const canonicalUrl = isInWhiteList\n    ? `${window.location.protocol}//${window.location.host}/swap/${NETWORKS_INFO[chainId].route}/${pathCanonicalUrl}`\n    : ''\n  return { isInWhiteList, data: data || {}, canonicalUrl }\n}\n\nexport const getFormattedAddress = (address?: string, fallback?: string): string => {\n  try {\n    return getAddress(address || '')\n  } catch (e) {\n    return fallback || address || ''\n  }\n}\n"],"mappings":"AACA,SAASA,UAAT,QAA2B,kBAA3B;AAEA,SAASC,aAAT,QAA8B,oBAA9B;AACA,SAASC,8BAAT,EAAyCC,0BAAzC,QAA2E,iCAA3E;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAACC,OAAD,EAAkBC,KAAlB,EAAoC;EAC/D,IAAMC,OAAO,GAAGL,8BAA8B,CAACG,OAAD,CAA9C;;EACA,IAAIE,OAAJ,EAAa;IACX,IAAMC,QAAQ,GAAGD,OAAO,CAACD,KAAD,CAAxB;IACA,IAAIE,QAAJ,EAAc,OAAOA,QAAP;EACf;;EACD,OAAOF,KAAP;AACD,CAPM;AASP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMG,oBAAoB,GAAG,SAAvBA,oBAAuB,CAACC,OAAD,EAA+BC,OAA/B,EAAgDC,OAAhD,EAAoE;EACtG,IAAI,CAACF,OAAL,EAAc;IACZ,OAAO;MAAEG,aAAa,EAAE,KAAjB;MAAwBC,IAAI,EAAE,EAA9B;MAAkCC,YAAY,EAAE;IAAhD,CAAP;EACD;;EACD,IAAMC,YAAY,GAAGb,0BAA0B,CAACO,OAAD,CAA/C;EACA,IAAMO,IAAI,aAAMN,OAAN,iBAAoBC,OAApB,CAAV;EACA,IAAMM,IAAI,aAAMN,OAAN,iBAAoBD,OAApB,CAAV;EACA,IAAMG,IAAI,GAAGE,YAAY,GAAGA,YAAY,CAACC,IAAD,CAAZ,IAAsBD,YAAY,CAACE,IAAD,CAArC,GAA8C,IAAvE;EACA,IAAML,aAAa,GAAG,CAAC,CAACC,IAAxB;EAEA,IAAMK,gBAAgB,GAAGH,YAAY,IAAIA,YAAY,CAACC,IAAD,CAA5B,GAAqCA,IAArC,GAA4CC,IAArE;EACA,IAAMH,YAAY,GAAGF,aAAa,aAC3BO,MAAM,CAACC,QAAP,CAAgBC,QADW,eACEF,MAAM,CAACC,QAAP,CAAgBE,IADlB,mBAC+BtB,aAAa,CAACS,OAAD,CAAb,CAAuBc,KADtD,cAC+DL,gBAD/D,IAE9B,EAFJ;EAGA,OAAO;IAAEN,aAAa,EAAbA,aAAF;IAAiBC,IAAI,EAAEA,IAAI,IAAI,EAA/B;IAAmCC,YAAY,EAAZA;EAAnC,CAAP;AACD,CAfM;AAiBP,OAAO,IAAMU,mBAAmB,GAAG,SAAtBA,mBAAsB,CAACC,OAAD,EAAmBC,QAAnB,EAAiD;EAClF,IAAI;IACF,OAAO3B,UAAU,CAAC0B,OAAO,IAAI,EAAZ,CAAjB;EACD,CAFD,CAEE,OAAOE,CAAP,EAAU;IACV,OAAOD,QAAQ,IAAID,OAAZ,IAAuB,EAA9B;EACD;AACF,CANM"},"metadata":{},"sourceType":"module"}