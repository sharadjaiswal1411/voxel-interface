{"ast":null,"code":"import _objectSpread from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { withScope, captureException, showReportDialog } from '@sentry/browser';\nimport { logger } from '@sentry/utils';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport * as React from 'react';\nvar _jsxFileName = \"/home/runner/work/sentry-javascript/sentry-javascript/packages/react/src/errorboundary.tsx\";\n\nfunction isAtLeastReact17(version) {\n  var major = version.match(/^([^.]+)/);\n  return major !== null && parseInt(major[0]) >= 17;\n}\n\nvar UNKNOWN_COMPONENT = 'unknown';\nvar INITIAL_STATE = {\n  componentStack: null,\n  error: null,\n  eventId: null\n};\n/**\n * A ErrorBoundary component that logs errors to Sentry. Requires React >= 16.\n * NOTE: If you are a Sentry user, and you are seeing this stack frame, it means the\n * Sentry React SDK ErrorBoundary caught an error invoking your application code. This\n * is expected behavior and NOT indicative of a bug with the Sentry React SDK.\n */\n\nvar ErrorBoundary = /*#__PURE__*/function (_React$Component) {\n  _inherits(ErrorBoundary, _React$Component);\n\n  var _super = _createSuper(ErrorBoundary);\n\n  function ErrorBoundary() {\n    var _this;\n\n    _classCallCheck(this, ErrorBoundary);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    ErrorBoundary.prototype.__init.call(_assertThisInitialized(_this));\n\n    ErrorBoundary.prototype.__init2.call(_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  _createClass(ErrorBoundary, [{\n    key: \"__init\",\n    value: function __init() {\n      this.state = INITIAL_STATE;\n    }\n  }, {\n    key: \"componentDidCatch\",\n    value: function componentDidCatch(error, _ref) {\n      var _this2 = this;\n\n      var componentStack = _ref.componentStack;\n      var _this$props = this.props,\n          beforeCapture = _this$props.beforeCapture,\n          onError = _this$props.onError,\n          showDialog = _this$props.showDialog,\n          dialogOptions = _this$props.dialogOptions;\n      withScope(function (scope) {\n        // If on React version >= 17, create stack trace from componentStack param and links\n        // to to the original error using `error.cause` otherwise relies on error param for stacktrace.\n        // Linking errors requires the `LinkedErrors` integration be enabled.\n        if (isAtLeastReact17(React.version)) {\n          var errorBoundaryError = new Error(error.message);\n          errorBoundaryError.name = \"React ErrorBoundary \".concat(errorBoundaryError.name);\n          errorBoundaryError.stack = componentStack; // Using the `LinkedErrors` integration to link the errors together.\n\n          error.cause = errorBoundaryError;\n        }\n\n        if (beforeCapture) {\n          beforeCapture(scope, error, componentStack);\n        }\n\n        var eventId = captureException(error, {\n          contexts: {\n            react: {\n              componentStack: componentStack\n            }\n          }\n        });\n\n        if (onError) {\n          onError(error, componentStack, eventId);\n        }\n\n        if (showDialog) {\n          showReportDialog(_objectSpread(_objectSpread({}, dialogOptions), {}, {\n            eventId: eventId\n          }));\n        } // componentDidCatch is used over getDerivedStateFromError\n        // so that componentStack is accessible through state.\n\n\n        _this2.setState({\n          error: error,\n          componentStack: componentStack,\n          eventId: eventId\n        });\n      });\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var onMount = this.props.onMount;\n\n      if (onMount) {\n        onMount();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var _this$state = this.state,\n          error = _this$state.error,\n          componentStack = _this$state.componentStack,\n          eventId = _this$state.eventId;\n      var onUnmount = this.props.onUnmount;\n\n      if (onUnmount) {\n        onUnmount(error, componentStack, eventId);\n      }\n    }\n  }, {\n    key: \"__init2\",\n    value: function __init2() {\n      var _this3 = this;\n\n      this.resetErrorBoundary = function () {\n        var onReset = _this3.props.onReset;\n        var _this3$state = _this3.state,\n            error = _this3$state.error,\n            componentStack = _this3$state.componentStack,\n            eventId = _this3$state.eventId;\n\n        if (onReset) {\n          onReset(error, componentStack, eventId);\n        }\n\n        _this3.setState(INITIAL_STATE);\n      };\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props2 = this.props,\n          fallback = _this$props2.fallback,\n          children = _this$props2.children;\n      var _this$state2 = this.state,\n          error = _this$state2.error,\n          componentStack = _this$state2.componentStack,\n          eventId = _this$state2.eventId;\n\n      if (error) {\n        var element = undefined;\n\n        if (typeof fallback === 'function') {\n          element = fallback({\n            error: error,\n            componentStack: componentStack,\n            resetError: this.resetErrorBoundary,\n            eventId: eventId\n          });\n        } else {\n          element = fallback;\n        }\n\n        if (React.isValidElement(element)) {\n          return element;\n        }\n\n        if (fallback) {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('fallback did not produce a valid ReactElement');\n        } // Fail gracefully if no fallback provided or is not valid\n\n\n        return null;\n      }\n\n      if (typeof children === 'function') {\n        return children();\n      }\n\n      return children;\n    }\n  }]);\n\n  return ErrorBoundary;\n}(React.Component);\n\nfunction withErrorBoundary(WrappedComponent, errorBoundaryOptions) {\n  var _this4 = this;\n\n  var componentDisplayName = WrappedComponent.displayName || WrappedComponent.name || UNKNOWN_COMPONENT;\n\n  var Wrapped = function Wrapped(props) {\n    return React.createElement(ErrorBoundary, _objectSpread(_objectSpread({}, errorBoundaryOptions), {}, {\n      __self: _this4,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 168\n      }\n    }), React.createElement(WrappedComponent, _objectSpread(_objectSpread({}, props), {}, {\n      __self: _this4,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 169\n      }\n    })));\n  };\n\n  Wrapped.displayName = \"errorBoundary(\".concat(componentDisplayName, \")\"); // Copy over static methods from Wrapped component to Profiler HOC\n  // See: https://reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over\n\n  hoistNonReactStatics(Wrapped, WrappedComponent);\n  return Wrapped;\n}\n\nexport { ErrorBoundary, UNKNOWN_COMPONENT, isAtLeastReact17, withErrorBoundary };","map":null,"metadata":{},"sourceType":"module"}