{"ast":null,"code":"import _slicedToArray from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _defineProperty from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n\nvar _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$();\n\nimport { i18n } from \"@lingui/core\";\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { CurrencyAmount, Percent, Price, WETH } from '@kyberswap/ks-sdk-core';\nimport JSBI from 'jsbi';\nimport { useCallback, useMemo } from 'react';\nimport { useSelector } from 'react-redux';\nimport { nativeOnChain } from 'constants/tokens';\nimport { useZapInAmounts } from 'hooks/useZap';\nimport { useAppDispatch } from 'state/hooks';\nimport { PairState, usePairByAddress, useUnAmplifiedPair } from '../../data/Reserves';\nimport { useTotalSupply } from '../../data/TotalSupply';\nimport { useActiveWeb3React } from '../../hooks';\nimport { tryParseAmount } from '../swap/hooks';\nimport { useCurrencyBalances } from '../wallet/hooks';\nimport { Field, switchTokenField, typeInput } from './actions';\nvar ZERO = JSBI.BigInt(0);\nexport function useMintState() {\n  _s();\n\n  return useSelector(function (state) {\n    return state.mint;\n  });\n}\n\n_s(useMintState, \"nKHvd/QB6hocKEk0fSJoSYcCyR8=\", false, function () {\n  return [useSelector];\n});\n\nexport function useDerivedMintInfo(currencyA, currencyB, pairAddress, isStaticFee) {\n  _s2();\n\n  var _currencies$Field$CUR, _currencies$Field$CUR2, _currencyBalances, _currencyBalances$Fie, _currencyBalances$Fie2;\n\n  var _useActiveWeb3React = useActiveWeb3React(),\n      account = _useActiveWeb3React.account,\n      chainId = _useActiveWeb3React.chainId;\n\n  var _useMintState = useMintState(),\n      independentField = _useMintState.independentField,\n      typedValue = _useMintState.typedValue,\n      otherTypedValue = _useMintState.otherTypedValue;\n\n  var dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A; // tokens\n\n  var currencies = useMemo(function () {\n    var _ref;\n\n    return _ref = {}, _defineProperty(_ref, Field.CURRENCY_A, currencyA !== null && currencyA !== void 0 ? currencyA : undefined), _defineProperty(_ref, Field.CURRENCY_B, currencyB !== null && currencyB !== void 0 ? currencyB : undefined), _ref;\n  }, [currencyA, currencyB]); // pair\n\n  var tokenA = (_currencies$Field$CUR = currencies[Field.CURRENCY_A]) === null || _currencies$Field$CUR === void 0 ? void 0 : _currencies$Field$CUR.wrapped;\n  var tokenB = (_currencies$Field$CUR2 = currencies[Field.CURRENCY_B]) === null || _currencies$Field$CUR2 === void 0 ? void 0 : _currencies$Field$CUR2.wrapped;\n\n  var _usePairByAddress = usePairByAddress(tokenA, tokenB, pairAddress),\n      _usePairByAddress2 = _slicedToArray(_usePairByAddress, 4),\n      pairState = _usePairByAddress2[0],\n      pair = _usePairByAddress2[1],\n      isStaticFeePair = _usePairByAddress2[2],\n      isOldStaticFeeContract = _usePairByAddress2[3];\n\n  var unAmplifiedPairAddresses = useUnAmplifiedPair(tokenA, tokenB);\n  var unAmplifiedPairAddress = unAmplifiedPairAddresses ? isStaticFee || isStaticFeePair ? unAmplifiedPairAddresses[0] : unAmplifiedPairAddresses[1] : '';\n  var totalSupply = useTotalSupply(pair === null || pair === void 0 ? void 0 : pair.liquidityToken);\n  var noLiquidity = (pairState === PairState.NOT_EXISTS || Boolean(totalSupply && JSBI.equal(totalSupply.quotient, ZERO))) && ((tokenA === null || tokenA === void 0 ? void 0 : tokenA.symbol) !== WETH[chainId].symbol || (tokenB === null || tokenB === void 0 ? void 0 : tokenB.symbol) !== WETH[chainId].symbol); // balances\n\n  var balances = useCurrencyBalances(account !== null && account !== void 0 ? account : undefined, [currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]]);\n  var currencyBalances = (_currencyBalances = {}, _defineProperty(_currencyBalances, Field.CURRENCY_A, balances[0]), _defineProperty(_currencyBalances, Field.CURRENCY_B, balances[1]), _currencyBalances); // amounts\n\n  var independentAmount = tryParseAmount(typedValue, currencies[independentField]);\n  var dependentAmount = useMemo(function () {\n    if (noLiquidity) {\n      if (otherTypedValue && currencies[dependentField]) {\n        return tryParseAmount(otherTypedValue, currencies[dependentField]);\n      }\n\n      return undefined;\n    } else if (independentAmount) {\n      // we wrap the currencies just to get the price in terms of the other token\n      var wrappedIndependentAmount = independentAmount === null || independentAmount === void 0 ? void 0 : independentAmount.wrapped;\n\n      var _tokenA = currencyA === null || currencyA === void 0 ? void 0 : currencyA.wrapped,\n          _tokenB = currencyB === null || currencyB === void 0 ? void 0 : currencyB.wrapped;\n\n      if (_tokenA && _tokenB && wrappedIndependentAmount && pair) {\n        var dependentCurrency = dependentField === Field.CURRENCY_B ? currencyB : currencyA;\n        var dependentTokenAmount = dependentField === Field.CURRENCY_B ? pair.priceOfReal(_tokenA).quote(wrappedIndependentAmount) : pair.priceOfReal(_tokenB).quote(wrappedIndependentAmount);\n        return dependentCurrency !== null && dependentCurrency !== void 0 && dependentCurrency.isNative ? CurrencyAmount.fromRawAmount(dependentCurrency, dependentTokenAmount.quotient) : dependentTokenAmount;\n      }\n\n      return undefined;\n    } else {\n      return undefined;\n    }\n  }, [noLiquidity, otherTypedValue, currencies, dependentField, independentAmount, currencyA, currencyB, pair]);\n  var parsedAmounts = useMemo(function () {\n    var _ref2;\n\n    return _ref2 = {}, _defineProperty(_ref2, Field.CURRENCY_A, independentField === Field.CURRENCY_A ? independentAmount : dependentAmount), _defineProperty(_ref2, Field.CURRENCY_B, independentField === Field.CURRENCY_A ? dependentAmount : independentAmount), _ref2;\n  }, [independentAmount, dependentAmount, independentField]);\n  var price = useMemo(function () {\n    if (noLiquidity) {\n      var _currencyAAmount = parsedAmounts[Field.CURRENCY_A],\n          _currencyBAmount = parsedAmounts[Field.CURRENCY_B];\n\n      if (_currencyAAmount && _currencyBAmount) {\n        var value = _currencyBAmount.divide(_currencyAAmount);\n\n        return new Price(_currencyAAmount.currency, _currencyBAmount.currency, value.denominator, value.numerator);\n      }\n\n      return undefined;\n    } else {\n      var wrappedCurrencyA = currencyA === null || currencyA === void 0 ? void 0 : currencyA.wrapped;\n      return pair && wrappedCurrencyA ? pair.priceOf(wrappedCurrencyA) : undefined;\n    }\n  }, [currencyA, noLiquidity, pair, parsedAmounts]); // liquidity minted\n\n  var liquidityMinted = useMemo(function () {\n    var currencyAAmount = parsedAmounts[Field.CURRENCY_A],\n        currencyBAmount = parsedAmounts[Field.CURRENCY_B];\n    var tokenAmountA = currencyAAmount === null || currencyAAmount === void 0 ? void 0 : currencyAAmount.wrapped,\n        tokenAmountB = currencyBAmount === null || currencyBAmount === void 0 ? void 0 : currencyBAmount.wrapped;\n\n    if (pair && totalSupply && tokenAmountA && tokenAmountB) {\n      try {\n        return pair.getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB);\n      } catch (e) {\n        console.error(e);\n        return undefined;\n      }\n    } else {\n      return undefined;\n    }\n  }, [parsedAmounts, pair, totalSupply]);\n  var poolTokenPercentage = useMemo(function () {\n    if (liquidityMinted && totalSupply) {\n      return new Percent(liquidityMinted.quotient, totalSupply.add(liquidityMinted).quotient);\n    } else {\n      return undefined;\n    }\n  }, [liquidityMinted, totalSupply]);\n  var error;\n\n  if (!account) {\n    error =\n    /*i18n*/\n    i18n._(\"Connect wallet\");\n  }\n\n  if (pairAddress && pairState === PairState.INVALID || (tokenA === null || tokenA === void 0 ? void 0 : tokenA.symbol) === (tokenB === null || tokenB === void 0 ? void 0 : tokenB.symbol)) {\n    var _error;\n\n    error = (_error = error) !== null && _error !== void 0 ? _error : 'Invalid pair';\n  }\n\n  var currencyAAmount = parsedAmounts[Field.CURRENCY_A],\n      currencyBAmount = parsedAmounts[Field.CURRENCY_B];\n\n  if (!currencyAAmount && typedValue || !currencyBAmount && otherTypedValue || (currencyBAmount === null || currencyBAmount === void 0 ? void 0 : currencyBAmount.toExact()) === '0' || (currencyAAmount === null || currencyAAmount === void 0 ? void 0 : currencyAAmount.toExact()) === '0') {\n    var _error2;\n\n    error = (_error2 = error) !== null && _error2 !== void 0 ? _error2 :\n    /*i18n*/\n    i18n._(\"Invalid amount\");\n  }\n\n  if (!parsedAmounts[Field.CURRENCY_A] || !parsedAmounts[Field.CURRENCY_B]) {\n    var _error3;\n\n    error = (_error3 = error) !== null && _error3 !== void 0 ? _error3 :\n    /*i18n*/\n    i18n._(\"Enter an amount\");\n  }\n\n  var cA = currencies[Field.CURRENCY_A];\n  var cB = currencies[Field.CURRENCY_B];\n\n  if (!!cA && currencyAAmount && currencyBalances !== null && currencyBalances !== void 0 && (_currencyBalances$Fie = currencyBalances[Field.CURRENCY_A]) !== null && _currencyBalances$Fie !== void 0 && _currencyBalances$Fie.lessThan(currencyAAmount)) {\n    error =\n    /*i18n*/\n    i18n._(\"Insufficient {0} balance\", {\n      0: cA.symbol\n    });\n  }\n\n  if (!!cB && currencyBAmount && currencyBalances !== null && currencyBalances !== void 0 && (_currencyBalances$Fie2 = currencyBalances[Field.CURRENCY_B]) !== null && _currencyBalances$Fie2 !== void 0 && _currencyBalances$Fie2.lessThan(currencyBAmount)) {\n    error =\n    /*i18n*/\n    i18n._(\"Insufficient {0} balance\", {\n      0: cB.symbol\n    });\n  }\n\n  return {\n    dependentField: dependentField,\n    currencies: currencies,\n    pair: pair,\n    pairState: pairState,\n    currencyBalances: currencyBalances,\n    parsedAmounts: parsedAmounts,\n    price: price,\n    noLiquidity: noLiquidity,\n    liquidityMinted: liquidityMinted,\n    poolTokenPercentage: poolTokenPercentage,\n    error: error,\n    unAmplifiedPairAddress: unAmplifiedPairAddress,\n    isStaticFeePair: isStaticFeePair,\n    isOldStaticFeeContract: isOldStaticFeeContract\n  };\n}\n\n_s2(useDerivedMintInfo, \"LpJpe/aw6AzkBrCOLvZt8loGi88=\", false, function () {\n  return [useActiveWeb3React, useMintState, usePairByAddress, useUnAmplifiedPair, useTotalSupply, useCurrencyBalances];\n});\n\nexport function useMintActionHandlers(noLiquidity) {\n  _s3();\n\n  var dispatch = useAppDispatch();\n  var onFieldAInput = useCallback(function (typedValue) {\n    dispatch(typeInput({\n      field: Field.CURRENCY_A,\n      typedValue: typedValue,\n      noLiquidity: noLiquidity === true\n    }));\n  }, [dispatch, noLiquidity]);\n  var onFieldBInput = useCallback(function (typedValue) {\n    dispatch(typeInput({\n      field: Field.CURRENCY_B,\n      typedValue: typedValue,\n      noLiquidity: noLiquidity === true\n    }));\n  }, [dispatch, noLiquidity]);\n  return {\n    onFieldAInput: onFieldAInput,\n    onFieldBInput: onFieldBInput\n  };\n}\n\n_s3(useMintActionHandlers, \"SD7NTLW00Yoy8nJI/INxRyad7FM=\", false, function () {\n  return [useAppDispatch];\n});\n\nexport function useDerivedZapInInfo(currencyA, currencyB, pairAddress) {\n  _s4();\n\n  var _currencies$Field$CUR3, _currencies$Field$CUR4, _currencyBalances2, _currencies$independe, _parsedAmounts$indepe, _parsedAmounts$depend, _currencyBalances$ind, _currencyBalances$ind2;\n\n  var _useActiveWeb3React2 = useActiveWeb3React(),\n      account = _useActiveWeb3React2.account,\n      chainId = _useActiveWeb3React2.chainId;\n\n  var _useMintState2 = useMintState(),\n      independentField = _useMintState2.independentField,\n      typedValue = _useMintState2.typedValue;\n\n  var dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A; // tokens\n\n  var currencies = useMemo(function () {\n    var _ref3;\n\n    return _ref3 = {}, _defineProperty(_ref3, Field.CURRENCY_A, currencyA !== null && currencyA !== void 0 ? currencyA : undefined), _defineProperty(_ref3, Field.CURRENCY_B, currencyB !== null && currencyB !== void 0 ? currencyB : undefined), _ref3;\n  }, [currencyA, currencyB]); // pair\n\n  var tokenA = (_currencies$Field$CUR3 = currencies[Field.CURRENCY_A]) === null || _currencies$Field$CUR3 === void 0 ? void 0 : _currencies$Field$CUR3.wrapped;\n  var tokenB = (_currencies$Field$CUR4 = currencies[Field.CURRENCY_B]) === null || _currencies$Field$CUR4 === void 0 ? void 0 : _currencies$Field$CUR4.wrapped;\n\n  var _usePairByAddress3 = usePairByAddress(tokenA, tokenB, pairAddress),\n      _usePairByAddress4 = _slicedToArray(_usePairByAddress3, 4),\n      pairState = _usePairByAddress4[0],\n      pair = _usePairByAddress4[1],\n      isStaticFeePair = _usePairByAddress4[2],\n      isOldStaticFeeContract = _usePairByAddress4[3];\n\n  var unAmplifiedPairAddresses = useUnAmplifiedPair(tokenA, tokenB);\n  var unAmplifiedPairAddress = unAmplifiedPairAddresses ? isStaticFeePair ? unAmplifiedPairAddresses[0] : unAmplifiedPairAddresses[1] : '';\n  var totalSupply = useTotalSupply(pair === null || pair === void 0 ? void 0 : pair.liquidityToken);\n  var noLiquidity = (pairState === PairState.NOT_EXISTS || Boolean(totalSupply && JSBI.equal(totalSupply.quotient, ZERO))) && ((tokenA === null || tokenA === void 0 ? void 0 : tokenA.symbol) !== WETH[chainId].symbol || (tokenB === null || tokenB === void 0 ? void 0 : tokenB.symbol) !== WETH[chainId].symbol); // balances\n\n  var balances = useCurrencyBalances(account !== null && account !== void 0 ? account : undefined, useMemo(function () {\n    return [currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]];\n  }, [currencies]));\n  var currencyBalances = (_currencyBalances2 = {}, _defineProperty(_currencyBalances2, Field.CURRENCY_A, balances[0]), _defineProperty(_currencyBalances2, Field.CURRENCY_B, balances[1]), _currencyBalances2);\n  var userInCurrencyAmount = useMemo(function () {\n    return tryParseAmount(typedValue, currencies[independentField], true);\n  }, [currencies, independentField, typedValue]);\n  var userIn = useMemo(function () {\n    return userInCurrencyAmount ? BigNumber.from(userInCurrencyAmount.quotient.toString()) : undefined;\n  }, [userInCurrencyAmount]);\n  var zapInAmounts = useZapInAmounts(!!isStaticFeePair, !!isOldStaticFeeContract, dependentField === Field.CURRENCY_B ? tokenA === null || tokenA === void 0 ? void 0 : tokenA.address : tokenB === null || tokenB === void 0 ? void 0 : tokenB.address, dependentField === Field.CURRENCY_B ? tokenB === null || tokenB === void 0 ? void 0 : tokenB.address : tokenA === null || tokenA === void 0 ? void 0 : tokenA.address, pair === null || pair === void 0 ? void 0 : pair.address, userIn); // amounts\n\n  var independentAmount = tryParseAmount(zapInAmounts.amounts.tokenInAmount.toString(), (_currencies$independe = currencies[independentField]) === null || _currencies$independe === void 0 ? void 0 : _currencies$independe.wrapped, false);\n  var dependentAmount = useMemo(function () {\n    if (independentAmount) {\n      // we wrap the currencies just to get the price in terms of the other token\n      var wrappedIndependentAmount = independentAmount === null || independentAmount === void 0 ? void 0 : independentAmount.wrapped;\n\n      var _tokenA2 = currencyA === null || currencyA === void 0 ? void 0 : currencyA.wrapped,\n          _tokenB2 = currencyB === null || currencyB === void 0 ? void 0 : currencyB.wrapped;\n\n      if (_tokenA2 && _tokenB2 && wrappedIndependentAmount && pair) {\n        var _currencies$dependent;\n\n        var dependentTokenAmount = tryParseAmount(zapInAmounts.amounts.tokenOutAmount.toString(), (_currencies$dependent = currencies[dependentField]) === null || _currencies$dependent === void 0 ? void 0 : _currencies$dependent.wrapped, false);\n        return dependentTokenAmount;\n      }\n\n      return undefined;\n    } else {\n      return undefined;\n    }\n  }, [independentAmount, currencyA, currencyB, pair, zapInAmounts.amounts.tokenOutAmount, currencies, dependentField]);\n  var parsedAmounts = useMemo(function () {\n    var _ref4;\n\n    return _ref4 = {}, _defineProperty(_ref4, Field.CURRENCY_A, independentField === Field.CURRENCY_A ? independentAmount : dependentAmount), _defineProperty(_ref4, Field.CURRENCY_B, independentField === Field.CURRENCY_A ? dependentAmount : independentAmount), _ref4;\n  }, [independentAmount, dependentAmount, independentField]);\n  var price = useMemo(function () {\n    var wrappedCurrencyA = currencyA === null || currencyA === void 0 ? void 0 : currencyA.wrapped;\n    return pair && wrappedCurrencyA ? pair.priceOf(wrappedCurrencyA) : undefined;\n  }, [currencyA, pair]); // liquidity minted\n\n  var liquidityMinted = useMemo(function () {\n    var currencyAAmount = parsedAmounts[Field.CURRENCY_A],\n        currencyBAmount = parsedAmounts[Field.CURRENCY_B];\n    var tokenAmountA = currencyAAmount === null || currencyAAmount === void 0 ? void 0 : currencyAAmount.wrapped,\n        tokenAmountB = currencyBAmount === null || currencyBAmount === void 0 ? void 0 : currencyBAmount.wrapped;\n\n    if (pair && totalSupply && tokenAmountA && tokenAmountB) {\n      try {\n        return pair.getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB);\n      } catch (e) {\n        console.error(e);\n        return undefined;\n      }\n    } else {\n      return undefined;\n    }\n  }, [parsedAmounts, pair, totalSupply]);\n  var poolTokenPercentage = useMemo(function () {\n    if (liquidityMinted && totalSupply) {\n      return new Percent(liquidityMinted.quotient, totalSupply.add(liquidityMinted).quotient);\n    } else {\n      return undefined;\n    }\n  }, [liquidityMinted, totalSupply]);\n  var insufficientLiquidity = false;\n  var error;\n\n  if (!account) {\n    error =\n    /*i18n*/\n    i18n._(\"Connect wallet\");\n  }\n\n  if (pairAddress && pairState === PairState.INVALID || (tokenA === null || tokenA === void 0 ? void 0 : tokenA.symbol) === 'WETH' && (tokenB === null || tokenB === void 0 ? void 0 : tokenB.symbol) === 'WETH') {\n    var _error4;\n\n    error = (_error4 = error) !== null && _error4 !== void 0 ? _error4 : 'Invalid pair';\n  }\n\n  if (!typedValue && (!parsedAmounts[independentField] || !parsedAmounts[dependentField])) {\n    var _error5;\n\n    error = (_error5 = error) !== null && _error5 !== void 0 ? _error5 :\n    /*i18n*/\n    i18n._(\"Enter an amount\");\n  }\n\n  if (!parsedAmounts[independentField] && typedValue || ((_parsedAmounts$indepe = parsedAmounts[independentField]) === null || _parsedAmounts$indepe === void 0 ? void 0 : _parsedAmounts$indepe.toExact()) === '0' || ((_parsedAmounts$depend = parsedAmounts[dependentField]) === null || _parsedAmounts$depend === void 0 ? void 0 : _parsedAmounts$depend.toExact()) === '0') {\n    var _error6;\n\n    error = (_error6 = error) !== null && _error6 !== void 0 ? _error6 :\n    /*i18n*/\n    i18n._(\"Invalid amount\");\n  }\n\n  var selectedCurrency = currencies[independentField];\n\n  if (!!selectedCurrency && independentAmount && userInCurrencyAmount && (currencyBalances !== null && currencyBalances !== void 0 && (_currencyBalances$ind = currencyBalances[independentField]) !== null && _currencyBalances$ind !== void 0 && _currencyBalances$ind.lessThan(independentAmount) || currencyBalances !== null && currencyBalances !== void 0 && (_currencyBalances$ind2 = currencyBalances[independentField]) !== null && _currencyBalances$ind2 !== void 0 && _currencyBalances$ind2.lessThan(userInCurrencyAmount))) {\n    error =\n    /*i18n*/\n    i18n._(\"Insufficient {0} balance\", {\n      0: selectedCurrency.isNative ? nativeOnChain(chainId).symbol : selectedCurrency.symbol\n    });\n  }\n\n  if (zapInAmounts.error && zapInAmounts.error.message.includes('INSUFFICIENT_LIQUIDITY')) {\n    insufficientLiquidity = true;\n  }\n\n  if (zapInAmounts.error && !zapInAmounts.error.message.includes('INSUFFICIENT_LIQUIDITY')) {\n    error =\n    /*i18n*/\n    i18n._(\"Something went wrong\");\n  }\n\n  return {\n    dependentField: dependentField,\n    currencies: currencies,\n    pair: pair,\n    pairState: pairState,\n    currencyBalances: currencyBalances,\n    parsedAmounts: parsedAmounts,\n    price: price,\n    noLiquidity: noLiquidity,\n    liquidityMinted: liquidityMinted,\n    poolTokenPercentage: poolTokenPercentage,\n    insufficientLiquidity: insufficientLiquidity,\n    error: error,\n    unAmplifiedPairAddress: unAmplifiedPairAddress,\n    isStaticFeePair: isStaticFeePair,\n    isOldStaticFeeContract: isOldStaticFeeContract\n  };\n}\n\n_s4(useDerivedZapInInfo, \"WSsNQdwADgM3J5nAJ30+aklfp60=\", false, function () {\n  return [useActiveWeb3React, useMintState, usePairByAddress, useUnAmplifiedPair, useTotalSupply, useCurrencyBalances, useZapInAmounts];\n});\n\nexport function useZapInActionHandlers() {\n  _s5();\n\n  var dispatch = useAppDispatch();\n\n  var _useMintState3 = useMintState(),\n      independentField = _useMintState3.independentField;\n\n  var onFieldInput = useCallback(function (typedValue) {\n    dispatch(typeInput({\n      field: independentField,\n      typedValue: typedValue,\n      noLiquidity: false\n    }));\n  }, [dispatch, independentField]);\n  var onSwitchField = useCallback(function () {\n    dispatch(switchTokenField({\n      field: independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A\n    }));\n  }, [dispatch, independentField]);\n  return {\n    onFieldInput: onFieldInput,\n    onSwitchField: onSwitchField\n  };\n}\n\n_s5(useZapInActionHandlers, \"diwUSI5S7vvw0eeq8HPINiBCbdg=\", false, function () {\n  return [useAppDispatch, useMintState];\n});","map":{"version":3,"names":["BigNumber","CurrencyAmount","Percent","Price","WETH","JSBI","useCallback","useMemo","useSelector","nativeOnChain","useZapInAmounts","useAppDispatch","PairState","usePairByAddress","useUnAmplifiedPair","useTotalSupply","useActiveWeb3React","tryParseAmount","useCurrencyBalances","Field","switchTokenField","typeInput","ZERO","BigInt","useMintState","state","mint","useDerivedMintInfo","currencyA","currencyB","pairAddress","isStaticFee","account","chainId","independentField","typedValue","otherTypedValue","dependentField","CURRENCY_A","CURRENCY_B","currencies","undefined","tokenA","wrapped","tokenB","pairState","pair","isStaticFeePair","isOldStaticFeeContract","unAmplifiedPairAddresses","unAmplifiedPairAddress","totalSupply","liquidityToken","noLiquidity","NOT_EXISTS","Boolean","equal","quotient","symbol","balances","currencyBalances","independentAmount","dependentAmount","wrappedIndependentAmount","dependentCurrency","dependentTokenAmount","priceOfReal","quote","isNative","fromRawAmount","parsedAmounts","price","currencyAAmount","currencyBAmount","value","divide","currency","denominator","numerator","wrappedCurrencyA","priceOf","liquidityMinted","tokenAmountA","tokenAmountB","getLiquidityMinted","e","console","error","poolTokenPercentage","add","INVALID","toExact","cA","cB","lessThan","useMintActionHandlers","dispatch","onFieldAInput","field","onFieldBInput","useDerivedZapInInfo","userInCurrencyAmount","userIn","from","toString","zapInAmounts","address","amounts","tokenInAmount","tokenOutAmount","insufficientLiquidity","selectedCurrency","message","includes","useZapInActionHandlers","onFieldInput","onSwitchField"],"sources":["/Applications/XAMPP/voxel-interface/src/state/mint/hooks.ts"],"sourcesContent":["import { BigNumber } from '@ethersproject/bignumber'\nimport { Pair } from '@kyberswap/ks-sdk-classic'\nimport { ChainId, Currency, CurrencyAmount, Percent, Price, TokenAmount, WETH } from '@kyberswap/ks-sdk-core'\nimport { t } from '@lingui/macro'\nimport JSBI from 'jsbi'\nimport { useCallback, useMemo } from 'react'\nimport { useSelector } from 'react-redux'\n\nimport { nativeOnChain } from 'constants/tokens'\nimport { useZapInAmounts } from 'hooks/useZap'\nimport { useAppDispatch } from 'state/hooks'\n\nimport { PairState, usePairByAddress, useUnAmplifiedPair } from '../../data/Reserves'\nimport { useTotalSupply } from '../../data/TotalSupply'\nimport { useActiveWeb3React } from '../../hooks'\nimport { AppState } from '../index'\nimport { tryParseAmount } from '../swap/hooks'\nimport { useCurrencyBalances } from '../wallet/hooks'\nimport { Field, switchTokenField, typeInput } from './actions'\n\nconst ZERO = JSBI.BigInt(0)\n\nexport function useMintState(): AppState['mint'] {\n  return useSelector<AppState, AppState['mint']>(state => state.mint)\n}\n\nexport function useDerivedMintInfo(\n  currencyA: Currency | undefined,\n  currencyB: Currency | undefined,\n  pairAddress: string | undefined,\n  isStaticFee?: boolean,\n): {\n  dependentField: Field\n  currencies: { [field in Field]?: Currency }\n  pair?: Pair | null\n  pairState: PairState\n  currencyBalances: { [field in Field]?: CurrencyAmount<Currency> }\n  parsedAmounts: { [field in Field]?: CurrencyAmount<Currency> }\n  price?: Price<Currency, Currency>\n  noLiquidity?: boolean\n  liquidityMinted?: TokenAmount\n  poolTokenPercentage?: Percent\n  error?: string\n  unAmplifiedPairAddress?: string\n  isStaticFeePair?: boolean\n  isOldStaticFeeContract?: boolean\n} {\n  const { account, chainId } = useActiveWeb3React()\n\n  const { independentField, typedValue, otherTypedValue } = useMintState()\n  const dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A\n\n  // tokens\n  const currencies: { [field in Field]?: Currency } = useMemo(\n    () => ({\n      [Field.CURRENCY_A]: currencyA ?? undefined,\n      [Field.CURRENCY_B]: currencyB ?? undefined,\n    }),\n    [currencyA, currencyB],\n  )\n\n  // pair\n  const tokenA = currencies[Field.CURRENCY_A]?.wrapped\n  const tokenB = currencies[Field.CURRENCY_B]?.wrapped\n  const [pairState, pair, isStaticFeePair, isOldStaticFeeContract] = usePairByAddress(tokenA, tokenB, pairAddress)\n  const unAmplifiedPairAddresses = useUnAmplifiedPair(tokenA, tokenB)\n  const unAmplifiedPairAddress = unAmplifiedPairAddresses\n    ? isStaticFee || isStaticFeePair\n      ? unAmplifiedPairAddresses[0]\n      : unAmplifiedPairAddresses[1]\n    : ''\n  const totalSupply = useTotalSupply(pair?.liquidityToken)\n\n  const noLiquidity: boolean =\n    (pairState === PairState.NOT_EXISTS || Boolean(totalSupply && JSBI.equal(totalSupply.quotient, ZERO))) &&\n    (tokenA?.symbol !== WETH[chainId as ChainId].symbol || tokenB?.symbol !== WETH[chainId as ChainId].symbol)\n\n  // balances\n  const balances = useCurrencyBalances(account ?? undefined, [\n    currencies[Field.CURRENCY_A],\n    currencies[Field.CURRENCY_B],\n  ])\n  const currencyBalances: { [field in Field]?: CurrencyAmount<Currency> } = {\n    [Field.CURRENCY_A]: balances[0],\n    [Field.CURRENCY_B]: balances[1],\n  }\n\n  // amounts\n  const independentAmount: CurrencyAmount<Currency> | undefined = tryParseAmount(\n    typedValue,\n    currencies[independentField],\n  )\n\n  const dependentAmount: CurrencyAmount<Currency> | undefined = useMemo(() => {\n    if (noLiquidity) {\n      if (otherTypedValue && currencies[dependentField]) {\n        return tryParseAmount(otherTypedValue, currencies[dependentField])\n      }\n      return undefined\n    } else if (independentAmount) {\n      // we wrap the currencies just to get the price in terms of the other token\n      const wrappedIndependentAmount = independentAmount?.wrapped\n      const [tokenA, tokenB] = [currencyA?.wrapped, currencyB?.wrapped]\n\n      if (tokenA && tokenB && wrappedIndependentAmount && pair) {\n        const dependentCurrency = dependentField === Field.CURRENCY_B ? currencyB : currencyA\n        const dependentTokenAmount =\n          dependentField === Field.CURRENCY_B\n            ? pair.priceOfReal(tokenA).quote(wrappedIndependentAmount)\n            : pair.priceOfReal(tokenB).quote(wrappedIndependentAmount)\n\n        return dependentCurrency?.isNative\n          ? CurrencyAmount.fromRawAmount(dependentCurrency, dependentTokenAmount.quotient)\n          : dependentTokenAmount\n      }\n      return undefined\n    } else {\n      return undefined\n    }\n  }, [noLiquidity, otherTypedValue, currencies, dependentField, independentAmount, currencyA, currencyB, pair])\n\n  const parsedAmounts: { [field in Field]: CurrencyAmount<Currency> | undefined } = useMemo(() => {\n    return {\n      [Field.CURRENCY_A]: independentField === Field.CURRENCY_A ? independentAmount : dependentAmount,\n      [Field.CURRENCY_B]: independentField === Field.CURRENCY_A ? dependentAmount : independentAmount,\n    }\n  }, [independentAmount, dependentAmount, independentField])\n\n  const price = useMemo(() => {\n    if (noLiquidity) {\n      const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts\n      if (currencyAAmount && currencyBAmount) {\n        const value = currencyBAmount.divide(currencyAAmount)\n        return new Price(currencyAAmount.currency, currencyBAmount.currency, value.denominator, value.numerator)\n      }\n      return undefined\n    } else {\n      const wrappedCurrencyA = currencyA?.wrapped\n      return pair && wrappedCurrencyA ? pair.priceOf(wrappedCurrencyA) : undefined\n    }\n  }, [currencyA, noLiquidity, pair, parsedAmounts])\n\n  // liquidity minted\n  const liquidityMinted = useMemo(() => {\n    const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts\n    const [tokenAmountA, tokenAmountB] = [currencyAAmount?.wrapped, currencyBAmount?.wrapped]\n\n    if (pair && totalSupply && tokenAmountA && tokenAmountB) {\n      try {\n        return pair.getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB)\n      } catch (e) {\n        console.error(e)\n        return undefined\n      }\n    } else {\n      return undefined\n    }\n  }, [parsedAmounts, pair, totalSupply])\n\n  const poolTokenPercentage = useMemo(() => {\n    if (liquidityMinted && totalSupply) {\n      return new Percent(liquidityMinted.quotient, totalSupply.add(liquidityMinted).quotient)\n    } else {\n      return undefined\n    }\n  }, [liquidityMinted, totalSupply])\n\n  let error: string | undefined\n  if (!account) {\n    error = t`Connect wallet`\n  }\n\n  if ((pairAddress && pairState === PairState.INVALID) || tokenA?.symbol === tokenB?.symbol) {\n    error = error ?? 'Invalid pair'\n  }\n\n  const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts\n\n  if (\n    (!currencyAAmount && typedValue) ||\n    (!currencyBAmount && otherTypedValue) ||\n    currencyBAmount?.toExact() === '0' ||\n    currencyAAmount?.toExact() === '0'\n  ) {\n    error = error ?? t`Invalid amount`\n  }\n\n  if (!parsedAmounts[Field.CURRENCY_A] || !parsedAmounts[Field.CURRENCY_B]) {\n    error = error ?? t`Enter an amount`\n  }\n\n  const cA = currencies[Field.CURRENCY_A]\n  const cB = currencies[Field.CURRENCY_B]\n  if (!!cA && currencyAAmount && currencyBalances?.[Field.CURRENCY_A]?.lessThan(currencyAAmount)) {\n    error = t`Insufficient ${cA.symbol} balance`\n  }\n\n  if (!!cB && currencyBAmount && currencyBalances?.[Field.CURRENCY_B]?.lessThan(currencyBAmount)) {\n    error = t`Insufficient ${cB.symbol} balance`\n  }\n\n  return {\n    dependentField,\n    currencies,\n    pair,\n    pairState,\n    currencyBalances,\n    parsedAmounts,\n    price,\n    noLiquidity,\n    liquidityMinted,\n    poolTokenPercentage,\n    error,\n    unAmplifiedPairAddress,\n    isStaticFeePair,\n    isOldStaticFeeContract,\n  }\n}\n\nexport function useMintActionHandlers(noLiquidity: boolean | undefined): {\n  onFieldAInput: (typedValue: string) => void\n  onFieldBInput: (typedValue: string) => void\n} {\n  const dispatch = useAppDispatch()\n\n  const onFieldAInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeInput({ field: Field.CURRENCY_A, typedValue, noLiquidity: noLiquidity === true }))\n    },\n    [dispatch, noLiquidity],\n  )\n  const onFieldBInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeInput({ field: Field.CURRENCY_B, typedValue, noLiquidity: noLiquidity === true }))\n    },\n    [dispatch, noLiquidity],\n  )\n\n  return {\n    onFieldAInput,\n    onFieldBInput,\n  }\n}\n\nexport function useDerivedZapInInfo(\n  currencyA: Currency | undefined,\n  currencyB: Currency | undefined,\n  pairAddress: string | undefined,\n): {\n  dependentField: Field\n  currencies: { [field in Field]?: Currency }\n  pair?: Pair | null\n  pairState: PairState\n  currencyBalances: { [field in Field]?: CurrencyAmount<Currency> }\n  parsedAmounts: { [field in Field]: CurrencyAmount<Currency> | undefined }\n  price?: Price<Currency, Currency>\n  noLiquidity?: boolean\n  liquidityMinted?: TokenAmount\n  poolTokenPercentage?: Percent\n  insufficientLiquidity?: boolean\n  error?: string\n  unAmplifiedPairAddress?: string\n  isStaticFeePair?: boolean\n  isOldStaticFeeContract?: boolean\n} {\n  const { account, chainId } = useActiveWeb3React()\n\n  const { independentField, typedValue } = useMintState()\n  const dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A\n\n  // tokens\n  const currencies: { [field in Field]?: Currency } = useMemo(\n    () => ({\n      [Field.CURRENCY_A]: currencyA ?? undefined,\n      [Field.CURRENCY_B]: currencyB ?? undefined,\n    }),\n    [currencyA, currencyB],\n  )\n\n  // pair\n  const tokenA = currencies[Field.CURRENCY_A]?.wrapped\n  const tokenB = currencies[Field.CURRENCY_B]?.wrapped\n  const [pairState, pair, isStaticFeePair, isOldStaticFeeContract] = usePairByAddress(tokenA, tokenB, pairAddress)\n  const unAmplifiedPairAddresses = useUnAmplifiedPair(tokenA, tokenB)\n  const unAmplifiedPairAddress = unAmplifiedPairAddresses\n    ? isStaticFeePair\n      ? unAmplifiedPairAddresses[0]\n      : unAmplifiedPairAddresses[1]\n    : ''\n  const totalSupply = useTotalSupply(pair?.liquidityToken)\n  const noLiquidity: boolean =\n    (pairState === PairState.NOT_EXISTS || Boolean(totalSupply && JSBI.equal(totalSupply.quotient, ZERO))) &&\n    (tokenA?.symbol !== WETH[chainId as ChainId].symbol || tokenB?.symbol !== WETH[chainId as ChainId].symbol)\n\n  // balances\n  const balances = useCurrencyBalances(\n    account ?? undefined,\n    useMemo(() => [currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]], [currencies]),\n  )\n  const currencyBalances: { [field in Field]?: CurrencyAmount<Currency> } = {\n    [Field.CURRENCY_A]: balances[0],\n    [Field.CURRENCY_B]: balances[1],\n  }\n\n  const userInCurrencyAmount = useMemo(() => {\n    return tryParseAmount(typedValue, currencies[independentField], true)\n  }, [currencies, independentField, typedValue])\n\n  const userIn = useMemo(() => {\n    return userInCurrencyAmount ? BigNumber.from(userInCurrencyAmount.quotient.toString()) : undefined\n  }, [userInCurrencyAmount])\n\n  const zapInAmounts = useZapInAmounts(\n    !!isStaticFeePair,\n    !!isOldStaticFeeContract,\n    dependentField === Field.CURRENCY_B ? tokenA?.address : tokenB?.address,\n    dependentField === Field.CURRENCY_B ? tokenB?.address : tokenA?.address,\n    pair?.address,\n    userIn,\n  )\n\n  // amounts\n  const independentAmount: CurrencyAmount<Currency> | undefined = tryParseAmount(\n    zapInAmounts.amounts.tokenInAmount.toString(),\n    currencies[independentField]?.wrapped,\n    false,\n  )\n\n  const dependentAmount: CurrencyAmount<Currency> | undefined = useMemo(() => {\n    if (independentAmount) {\n      // we wrap the currencies just to get the price in terms of the other token\n      const wrappedIndependentAmount = independentAmount?.wrapped\n      const [tokenA, tokenB] = [currencyA?.wrapped, currencyB?.wrapped]\n\n      if (tokenA && tokenB && wrappedIndependentAmount && pair) {\n        const dependentTokenAmount = tryParseAmount(\n          zapInAmounts.amounts.tokenOutAmount.toString(),\n          currencies[dependentField]?.wrapped,\n          false,\n        )\n\n        return dependentTokenAmount\n      }\n\n      return undefined\n    } else {\n      return undefined\n    }\n  }, [independentAmount, currencyA, currencyB, pair, zapInAmounts.amounts.tokenOutAmount, currencies, dependentField])\n\n  const parsedAmounts: { [field in Field]: CurrencyAmount<Currency> | undefined } = useMemo(() => {\n    return {\n      [Field.CURRENCY_A]: independentField === Field.CURRENCY_A ? independentAmount : dependentAmount,\n      [Field.CURRENCY_B]: independentField === Field.CURRENCY_A ? dependentAmount : independentAmount,\n    }\n  }, [independentAmount, dependentAmount, independentField])\n\n  const price = useMemo(() => {\n    const wrappedCurrencyA = currencyA?.wrapped\n    return pair && wrappedCurrencyA ? pair.priceOf(wrappedCurrencyA) : undefined\n  }, [currencyA, pair])\n\n  // liquidity minted\n  const liquidityMinted = useMemo(() => {\n    const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts\n    const [tokenAmountA, tokenAmountB] = [currencyAAmount?.wrapped, currencyBAmount?.wrapped]\n\n    if (pair && totalSupply && tokenAmountA && tokenAmountB) {\n      try {\n        return pair.getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB)\n      } catch (e) {\n        console.error(e)\n        return undefined\n      }\n    } else {\n      return undefined\n    }\n  }, [parsedAmounts, pair, totalSupply])\n\n  const poolTokenPercentage = useMemo(() => {\n    if (liquidityMinted && totalSupply) {\n      return new Percent(liquidityMinted.quotient, totalSupply.add(liquidityMinted).quotient)\n    } else {\n      return undefined\n    }\n  }, [liquidityMinted, totalSupply])\n\n  let insufficientLiquidity = false\n  let error: string | undefined\n  if (!account) {\n    error = t`Connect wallet`\n  }\n\n  if ((pairAddress && pairState === PairState.INVALID) || (tokenA?.symbol === 'WETH' && tokenB?.symbol === 'WETH')) {\n    error = error ?? 'Invalid pair'\n  }\n\n  if (!typedValue && (!parsedAmounts[independentField] || !parsedAmounts[dependentField])) {\n    error = error ?? t`Enter an amount`\n  }\n\n  if (\n    (!parsedAmounts[independentField] && typedValue) ||\n    parsedAmounts[independentField]?.toExact() === '0' ||\n    parsedAmounts[dependentField]?.toExact() === '0'\n  ) {\n    error = error ?? t`Invalid amount`\n  }\n\n  const selectedCurrency = currencies[independentField]\n  if (\n    !!selectedCurrency &&\n    independentAmount &&\n    userInCurrencyAmount &&\n    (currencyBalances?.[independentField]?.lessThan(independentAmount) ||\n      currencyBalances?.[independentField]?.lessThan(userInCurrencyAmount))\n  ) {\n    error = t`Insufficient ${\n      selectedCurrency.isNative ? nativeOnChain(chainId as ChainId).symbol : selectedCurrency.symbol\n    } balance`\n  }\n\n  if (zapInAmounts.error && zapInAmounts.error.message.includes('INSUFFICIENT_LIQUIDITY')) {\n    insufficientLiquidity = true\n  }\n\n  if (zapInAmounts.error && !zapInAmounts.error.message.includes('INSUFFICIENT_LIQUIDITY')) {\n    error = t`Something went wrong`\n  }\n\n  return {\n    dependentField,\n    currencies,\n    pair,\n    pairState,\n    currencyBalances,\n    parsedAmounts,\n    price,\n    noLiquidity,\n    liquidityMinted,\n    poolTokenPercentage,\n    insufficientLiquidity,\n    error,\n    unAmplifiedPairAddress,\n    isStaticFeePair,\n    isOldStaticFeeContract,\n  }\n}\n\nexport function useZapInActionHandlers(): {\n  onFieldInput: (typedValue: string) => void\n  onSwitchField: () => void\n} {\n  const dispatch = useAppDispatch()\n  const { independentField } = useMintState()\n\n  const onFieldInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeInput({ field: independentField, typedValue, noLiquidity: false }))\n    },\n    [dispatch, independentField],\n  )\n\n  const onSwitchField = useCallback(() => {\n    dispatch(switchTokenField({ field: independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A }))\n  }, [dispatch, independentField])\n\n  return {\n    onFieldInput,\n    onSwitchField,\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}