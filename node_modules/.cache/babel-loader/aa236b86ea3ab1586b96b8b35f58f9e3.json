{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethUtil = require(\"ethereumjs-util\");\n\nvar _ = require(\"lodash\");\n\nvar configured_bignumber_1 = require(\"../../configured_bignumber\");\n\nvar constants_1 = require(\"../utils/constants\");\n\nfunction sanityCheckBigNumberRange(value_, minValue, maxValue) {\n  var value = new configured_bignumber_1.BigNumber(value_, 10);\n\n  if (value.isGreaterThan(maxValue)) {\n    throw new Error(\"Tried to assign value of \" + value + \", which exceeds max value of \" + maxValue);\n  } else if (value.isLessThan(minValue)) {\n    throw new Error(\"Tried to assign value of \" + value + \", which exceeds min value of \" + minValue);\n  } else if (value.isNaN()) {\n    throw new Error(\"Tried to assign NaN value\");\n  }\n}\n\nfunction bigNumberToPaddedBuffer(value) {\n  var valueHex = \"0x\" + value.toString(constants_1.constants.HEX_BASE);\n  var valueBuf = ethUtil.toBuffer(valueHex);\n  var valueBufPadded = ethUtil.setLengthLeft(valueBuf, constants_1.constants.EVM_WORD_WIDTH_IN_BYTES);\n  return valueBufPadded;\n}\n/**\n * Takes a numeric value and returns its ABI-encoded value\n * @param value_    The value to encode.\n * @return ABI Encoded value\n */\n\n\nfunction encodeNumericValue(value_) {\n  var value = new configured_bignumber_1.BigNumber(value_, 10); // Case 1/2: value is non-negative\n\n  if (value.isGreaterThanOrEqualTo(0)) {\n    var encodedPositiveValue = bigNumberToPaddedBuffer(value);\n    return encodedPositiveValue;\n  } // Case 2/2: Value is negative\n  // Use two's-complement to encode the value\n  // Step 1/3: Convert negative value to positive binary string\n\n\n  var valueBin = value.times(-1).toString(constants_1.constants.BIN_BASE); // Step 2/3: Invert binary value\n\n  var invertedValueBin = '1'.repeat(constants_1.constants.EVM_WORD_WIDTH_IN_BITS - valueBin.length);\n\n  _.each(valueBin, function (bit) {\n    invertedValueBin += bit === '1' ? '0' : '1';\n  });\n\n  var invertedValue = new configured_bignumber_1.BigNumber(invertedValueBin, constants_1.constants.BIN_BASE); // Step 3/3: Add 1 to inverted value\n\n  var negativeValue = invertedValue.plus(1);\n  var encodedValue = bigNumberToPaddedBuffer(negativeValue);\n  return encodedValue;\n}\n\nexports.encodeNumericValue = encodeNumericValue;\n/**\n * Takes a numeric value and returns its ABI-encoded value.\n * Performs an additional sanity check, given the min/max allowed value.\n * @param value_    The value to encode.\n * @return ABI Encoded value\n */\n\nfunction safeEncodeNumericValue(value, minValue, maxValue) {\n  sanityCheckBigNumberRange(value, minValue, maxValue);\n  var encodedValue = encodeNumericValue(value);\n  return encodedValue;\n}\n\nexports.safeEncodeNumericValue = safeEncodeNumericValue;\n/**\n * Takes an ABI-encoded numeric value and returns its decoded value as a BigNumber.\n * @param encodedValue    The encoded numeric value.\n * @param minValue        The minimum possible decoded value.\n * @return ABI Decoded value\n */\n\nfunction decodeNumericValue(encodedValue, minValue) {\n  var valueHex = ethUtil.bufferToHex(encodedValue); // Case 1/3: value is definitely non-negative because of numeric boundaries\n\n  var value = new configured_bignumber_1.BigNumber(valueHex, constants_1.constants.HEX_BASE);\n\n  if (!minValue.isLessThan(0)) {\n    return value;\n  } // Case 2/3: value is non-negative because there is no leading 1 (encoded as two's-complement)\n\n\n  var valueBin = value.toString(constants_1.constants.BIN_BASE);\n\n  var isValueNegative = valueBin.length === constants_1.constants.EVM_WORD_WIDTH_IN_BITS && _.startsWith(valueBin[0], '1');\n\n  if (!isValueNegative) {\n    return value;\n  } // Case 3/3: value is negative\n  // Step 1/3: Invert b inary value\n\n\n  var invertedValueBin = '';\n\n  _.each(valueBin, function (bit) {\n    invertedValueBin += bit === '1' ? '0' : '1';\n  });\n\n  var invertedValue = new configured_bignumber_1.BigNumber(invertedValueBin, constants_1.constants.BIN_BASE); // Step 2/3: Add 1 to inverted value\n  // The result is the two's-complement representation of the input value.\n\n  var positiveValue = invertedValue.plus(1); // Step 3/3: Invert positive value to get the negative value\n\n  var negativeValue = positiveValue.times(-1);\n  return negativeValue;\n}\n\nexports.decodeNumericValue = decodeNumericValue;\n/**\n * Takes an ABI-encoded numeric value and returns its decoded value as a BigNumber.\n * Performs an additional sanity check, given the min/max allowed value.\n * @param encodedValue    The encoded numeric value.\n * @param minValue        The minimum possible decoded value.\n * @return ABI Decoded value\n */\n\nfunction safeDecodeNumericValue(encodedValue, minValue, maxValue) {\n  var value = decodeNumericValue(encodedValue, minValue);\n  sanityCheckBigNumberRange(value, minValue, maxValue);\n  return value;\n}\n\nexports.safeDecodeNumericValue = safeDecodeNumericValue;","map":null,"metadata":{},"sourceType":"script"}