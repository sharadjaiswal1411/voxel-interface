{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethereum_types_1 = require(\"ethereum-types\");\n\nvar ethUtil = require(\"ethereumjs-util\");\n\nvar _ = require(\"lodash\");\n\nvar blob_1 = require(\"../abstract_data_types/types/blob\");\n\nvar constants_1 = require(\"../utils/constants\");\n\nvar AddressDataType =\n/** @class */\nfunction (_super) {\n  __extends(AddressDataType, _super);\n\n  function AddressDataType(dataItem, dataTypeFactory) {\n    var _this = _super.call(this, dataItem, dataTypeFactory, AddressDataType._SIZE_KNOWN_AT_COMPILE_TIME) || this;\n\n    if (!AddressDataType.matchType(dataItem.type)) {\n      throw new Error(\"Tried to instantiate Address with bad input: \" + dataItem);\n    }\n\n    return _this;\n  }\n\n  AddressDataType.matchType = function (type) {\n    return type === ethereum_types_1.SolidityTypes.Address;\n  }; // Disable prefer-function-over-method for inherited abstract methods.\n\n  /* tslint:disable prefer-function-over-method */\n\n\n  AddressDataType.prototype.encodeValue = function (value) {\n    if (!ethUtil.isValidAddress(value)) {\n      throw new Error(\"Invalid address: '\" + value + \"'\");\n    }\n\n    var valueBuf = ethUtil.toBuffer(value);\n    var encodedValueBuf = ethUtil.setLengthLeft(valueBuf, constants_1.constants.EVM_WORD_WIDTH_IN_BYTES);\n    return encodedValueBuf;\n  };\n\n  AddressDataType.prototype.decodeValue = function (calldata) {\n    var valueBufPadded = calldata.popWord();\n    var valueBuf = valueBufPadded.slice(AddressDataType._DECODED_ADDRESS_OFFSET_IN_BYTES);\n    var value = ethUtil.bufferToHex(valueBuf);\n\n    var valueLowercase = _.toLower(value);\n\n    return valueLowercase;\n  };\n\n  AddressDataType.prototype.getDefaultValue = function () {\n    return AddressDataType._DEFAULT_VALUE;\n  };\n\n  AddressDataType.prototype.getSignatureType = function () {\n    return ethereum_types_1.SolidityTypes.Address;\n  };\n\n  AddressDataType._SIZE_KNOWN_AT_COMPILE_TIME = true;\n  AddressDataType._ADDRESS_SIZE_IN_BYTES = 20;\n  AddressDataType._DECODED_ADDRESS_OFFSET_IN_BYTES = constants_1.constants.EVM_WORD_WIDTH_IN_BYTES - AddressDataType._ADDRESS_SIZE_IN_BYTES;\n  AddressDataType._DEFAULT_VALUE = '0x0000000000000000000000000000000000000000';\n  return AddressDataType;\n}(blob_1.AbstractBlobDataType);\n\nexports.AddressDataType = AddressDataType;","map":null,"metadata":{},"sourceType":"script"}