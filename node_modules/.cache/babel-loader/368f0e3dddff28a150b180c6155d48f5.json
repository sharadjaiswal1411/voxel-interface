{"ast":null,"code":"import _regeneratorRuntime from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _slicedToArray from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _asyncToGenerator from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\nvar _s = $RefreshSig$();\n\nimport { useEffect, useMemo, useRef } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useActiveWeb3React } from '../../hooks';\nimport { useMulticallContract } from '../../hooks/useContract';\nimport useDebounce from '../../hooks/useDebounce';\nimport chunkArray from '../../utils/chunkArray';\nimport { CancelledError, RetryableError, retry } from '../../utils/retry';\nimport { useBlockNumber } from '../application/hooks';\nimport { errorFetchingMulticallResults, fetchingMulticallResults, parseCallKey, updateMulticallResults } from './actions'; // chunk calls so we do not exceed the gas limit\n\nvar CALL_CHUNK_SIZE = 100;\n/**\n * Fetches a chunk of calls, enforcing a minimum block number constraint\n * @param multicallContract multicall contract to fetch against\n * @param chunk chunk of calls to make\n * @param minBlockNumber minimum block number of the result set\n */\n\nfunction fetchChunk(_x, _x2, _x3) {\n  return _fetchChunk.apply(this, arguments);\n}\n/**\n * From the current all listeners state, return each call key mapped to the\n * minimum number of blocks per fetch. This is how often each key must be fetched.\n * @param allListeners the all listeners state\n * @param chainId the current chain id\n */\n\n\nfunction _fetchChunk() {\n  _fetchChunk = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(multicallContract, chunk, minBlockNumber) {\n    var resultsBlockNumber, returnData, res, _error$data, _error$data2, _error$data2$message, _error$message, error, half, _yield$Promise$all, _yield$Promise$all2, c0, c1;\n\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            console.debug('Fetching chunk', multicallContract, chunk, minBlockNumber);\n            _context.prev = 1;\n            _context.next = 4;\n            return multicallContract.callStatic.tryBlockAndAggregate(false, // requireSuccess\n            chunk.map(function (obj) {\n              var _obj$gasRequired;\n\n              return {\n                target: obj.address,\n                callData: obj.callData,\n                gasLimit: (_obj$gasRequired = obj.gasRequired) !== null && _obj$gasRequired !== void 0 ? _obj$gasRequired : 1000000\n              };\n            }));\n\n          case 4:\n            res = _context.sent;\n            resultsBlockNumber = res.blockNumber;\n            returnData = res.returnData.map(function (item) {\n              return item[1];\n            }); // ;[resultsBlockNumber, returnData] = await multicallContract.aggregate(chunk.map(obj => [obj.address, obj.callData]))\n\n            _context.next = 28;\n            break;\n\n          case 9:\n            _context.prev = 9;\n            _context.t0 = _context[\"catch\"](1);\n            error = _context.t0;\n\n            if (!(error.code === -32000 || error !== null && error !== void 0 && (_error$data = error.data) !== null && _error$data !== void 0 && _error$data.message && (error === null || error === void 0 ? void 0 : (_error$data2 = error.data) === null || _error$data2 === void 0 ? void 0 : (_error$data2$message = _error$data2.message) === null || _error$data2$message === void 0 ? void 0 : _error$data2$message.indexOf('header not found')) !== -1 || ((_error$message = error.message) === null || _error$message === void 0 ? void 0 : _error$message.indexOf('header not found')) !== -1)) {\n              _context.next = 16;\n              break;\n            }\n\n            throw new RetryableError(\"header not found for block number \".concat(minBlockNumber));\n\n          case 16:\n            if (!(chunk.length > 1)) {\n              _context.next = 26;\n              break;\n            }\n\n            if (process.env.NODE_ENV === 'development') {\n              console.debug('Splitting a chunk in 2', chunk);\n            }\n\n            half = Math.floor(chunk.length / 2);\n            _context.next = 21;\n            return Promise.all([fetchChunk(multicallContract, chunk.slice(0, half), minBlockNumber), fetchChunk(multicallContract, chunk.slice(half, chunk.length), minBlockNumber)]);\n\n          case 21:\n            _yield$Promise$all = _context.sent;\n            _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n            c0 = _yield$Promise$all2[0];\n            c1 = _yield$Promise$all2[1];\n            return _context.abrupt(\"return\", {\n              results: c0.results.concat(c1.results),\n              blockNumber: c1.blockNumber\n            });\n\n          case 26:\n            console.debug('Failed to fetch chunk inside retry', error);\n            throw error;\n\n          case 28:\n            if (!(resultsBlockNumber.toNumber() < minBlockNumber)) {\n              _context.next = 31;\n              break;\n            }\n\n            console.debug(\"Fetched results for old block number: \".concat(resultsBlockNumber.toString(), \" vs. \").concat(minBlockNumber));\n            throw new RetryableError('Fetched for old block number');\n\n          case 31:\n            return _context.abrupt(\"return\", {\n              results: returnData,\n              blockNumber: resultsBlockNumber.toNumber()\n            });\n\n          case 32:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[1, 9]]);\n  }));\n  return _fetchChunk.apply(this, arguments);\n}\n\nexport function activeListeningKeys(allListeners, chainId) {\n  if (!allListeners || !chainId) return {};\n  var listeners = allListeners[chainId];\n  if (!listeners) return {};\n  return Object.keys(listeners).reduce(function (memo, callKey) {\n    var keyListeners = listeners[callKey];\n    memo[callKey] = Object.keys(keyListeners).filter(function (key) {\n      var blocksPerFetch = parseInt(key);\n      if (blocksPerFetch <= 0) return false;\n      return keyListeners[blocksPerFetch] > 0;\n    }).reduce(function (previousMin, current) {\n      return Math.min(previousMin, parseInt(current));\n    }, Infinity);\n    return memo;\n  }, {});\n}\n/**\n * Return the keys that need to be refetched\n * @param callResults current call result state\n * @param listeningKeys each call key mapped to how old the data can be in blocks\n * @param chainId the current chain id\n * @param latestBlockNumber the latest block number\n */\n\nexport function outdatedListeningKeys(callResults, listeningKeys, chainId, latestBlockNumber) {\n  if (!chainId || !latestBlockNumber) return [];\n  var results = callResults[chainId]; // no results at all, load everything\n\n  if (!results) return Object.keys(listeningKeys);\n  return Object.keys(listeningKeys).filter(function (callKey) {\n    var blocksPerFetch = listeningKeys[callKey];\n    var data = callResults[chainId][callKey]; // no data, must fetch\n\n    if (!data) return true;\n    var minDataBlockNumber = latestBlockNumber - (blocksPerFetch - 1); // already fetching it for a recent enough block, don't refetch it\n\n    if (data.fetchingBlockNumber && data.fetchingBlockNumber >= minDataBlockNumber) return false; // if data is older than minDataBlockNumber, fetch it\n\n    return !data.blockNumber || data.blockNumber < minDataBlockNumber;\n  });\n}\nexport default function Updater() {\n  _s();\n\n  var dispatch = useDispatch();\n  var state = useSelector(function (state) {\n    return state.multicall;\n  }); // wait for listeners to settle before triggering updates\n\n  var debouncedListeners = useDebounce(state.callListeners, 100);\n  var latestBlockNumber = useBlockNumber();\n\n  var _useActiveWeb3React = useActiveWeb3React(),\n      chainId = _useActiveWeb3React.chainId;\n\n  var multicallContract = useMulticallContract();\n  var cancellations = useRef();\n  var listeningKeys = useMemo(function () {\n    return activeListeningKeys(debouncedListeners, chainId);\n  }, [debouncedListeners, chainId]);\n  var unserializedOutdatedCallKeys = useMemo(function () {\n    return outdatedListeningKeys(state.callResults, listeningKeys, chainId, latestBlockNumber);\n  }, [chainId, state.callResults, listeningKeys, latestBlockNumber]);\n  var serializedOutdatedCallKeys = useMemo(function () {\n    return JSON.stringify(unserializedOutdatedCallKeys.sort());\n  }, [unserializedOutdatedCallKeys]);\n  useEffect(function () {\n    var _cancellations$curren;\n\n    if (!latestBlockNumber || !chainId || !multicallContract) return;\n    var outdatedCallKeys = JSON.parse(serializedOutdatedCallKeys);\n    if (outdatedCallKeys.length === 0) return;\n    var calls = outdatedCallKeys.map(function (key) {\n      return parseCallKey(key);\n    });\n    var chunkedCalls = chunkArray(calls, CALL_CHUNK_SIZE);\n\n    if (((_cancellations$curren = cancellations.current) === null || _cancellations$curren === void 0 ? void 0 : _cancellations$curren.blockNumber) !== latestBlockNumber) {\n      var _cancellations$curren2, _cancellations$curren3;\n\n      (_cancellations$curren2 = cancellations.current) === null || _cancellations$curren2 === void 0 ? void 0 : (_cancellations$curren3 = _cancellations$curren2.cancellations) === null || _cancellations$curren3 === void 0 ? void 0 : _cancellations$curren3.forEach(function (c) {\n        return c();\n      });\n    }\n\n    dispatch(fetchingMulticallResults({\n      calls: calls,\n      chainId: chainId,\n      fetchingBlockNumber: latestBlockNumber\n    }));\n    cancellations.current = {\n      blockNumber: latestBlockNumber,\n      cancellations: chunkedCalls.map(function (chunk, index) {\n        var _retry = retry(function () {\n          return fetchChunk(multicallContract, chunk, latestBlockNumber);\n        }, {\n          n: Infinity,\n          minWait: 2500,\n          maxWait: 3500\n        }),\n            cancel = _retry.cancel,\n            promise = _retry.promise;\n\n        promise.then(function (_ref) {\n          var returnData = _ref.results,\n              fetchBlockNumber = _ref.blockNumber;\n          cancellations.current = {\n            cancellations: [],\n            blockNumber: latestBlockNumber\n          }; // accumulates the length of all previous indices\n\n          var firstCallKeyIndex = chunkedCalls.slice(0, index).reduce(function (memo, curr) {\n            return memo + curr.length;\n          }, 0);\n          var lastCallKeyIndex = firstCallKeyIndex + returnData.length;\n          dispatch(updateMulticallResults({\n            chainId: chainId,\n            results: outdatedCallKeys.slice(firstCallKeyIndex, lastCallKeyIndex).reduce(function (memo, callKey, i) {\n              var _returnData$i;\n\n              memo[callKey] = (_returnData$i = returnData[i]) !== null && _returnData$i !== void 0 ? _returnData$i : null;\n              return memo;\n            }, {}),\n            blockNumber: fetchBlockNumber\n          }));\n        }).catch(function (error) {\n          if (error instanceof CancelledError) {\n            console.debug('Cancelled fetch for blockNumber', latestBlockNumber);\n            return;\n          }\n\n          console.error('Failed to fetch multicall chunk', chunk, chainId, error);\n          dispatch(errorFetchingMulticallResults({\n            calls: chunk,\n            chainId: chainId,\n            fetchingBlockNumber: latestBlockNumber\n          }));\n        });\n        return cancel;\n      })\n    };\n  }, [chainId, multicallContract, dispatch, serializedOutdatedCallKeys, latestBlockNumber]);\n  return null;\n}\n\n_s(Updater, \"xpRD+AhDwmTdNwtyGSlpafZt7S0=\", false, function () {\n  return [useDispatch, useSelector, useDebounce, useBlockNumber, useActiveWeb3React, useMulticallContract];\n});\n\n_c = Updater;\n\nvar _c;\n\n$RefreshReg$(_c, \"Updater\");","map":{"version":3,"names":["useEffect","useMemo","useRef","useDispatch","useSelector","useActiveWeb3React","useMulticallContract","useDebounce","chunkArray","CancelledError","RetryableError","retry","useBlockNumber","errorFetchingMulticallResults","fetchingMulticallResults","parseCallKey","updateMulticallResults","CALL_CHUNK_SIZE","fetchChunk","multicallContract","chunk","minBlockNumber","console","debug","callStatic","tryBlockAndAggregate","map","obj","target","address","callData","gasLimit","gasRequired","res","resultsBlockNumber","blockNumber","returnData","item","error","code","data","message","indexOf","length","process","env","NODE_ENV","half","Math","floor","Promise","all","slice","c0","c1","results","concat","toNumber","toString","activeListeningKeys","allListeners","chainId","listeners","Object","keys","reduce","memo","callKey","keyListeners","filter","key","blocksPerFetch","parseInt","previousMin","current","min","Infinity","outdatedListeningKeys","callResults","listeningKeys","latestBlockNumber","minDataBlockNumber","fetchingBlockNumber","Updater","dispatch","state","multicall","debouncedListeners","callListeners","cancellations","unserializedOutdatedCallKeys","serializedOutdatedCallKeys","JSON","stringify","sort","outdatedCallKeys","parse","calls","chunkedCalls","forEach","c","index","n","minWait","maxWait","cancel","promise","then","fetchBlockNumber","firstCallKeyIndex","curr","lastCallKeyIndex","i","catch"],"sources":["/Applications/XAMPP/voxel-interface/src/state/multicall/updater.tsx"],"sourcesContent":["import { Contract } from '@ethersproject/contracts'\nimport { useEffect, useMemo, useRef } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\n\nimport { useActiveWeb3React } from '../../hooks'\nimport { useMulticallContract } from '../../hooks/useContract'\nimport useDebounce from '../../hooks/useDebounce'\nimport chunkArray from '../../utils/chunkArray'\nimport { CancelledError, RetryableError, retry } from '../../utils/retry'\nimport { useBlockNumber } from '../application/hooks'\nimport { AppDispatch, AppState } from '../index'\nimport {\n  Call,\n  errorFetchingMulticallResults,\n  fetchingMulticallResults,\n  parseCallKey,\n  updateMulticallResults,\n} from './actions'\n\n// chunk calls so we do not exceed the gas limit\nconst CALL_CHUNK_SIZE = 100\n\n/**\n * Fetches a chunk of calls, enforcing a minimum block number constraint\n * @param multicallContract multicall contract to fetch against\n * @param chunk chunk of calls to make\n * @param minBlockNumber minimum block number of the result set\n */\nasync function fetchChunk(\n  multicallContract: Contract,\n  chunk: Call[],\n  minBlockNumber: number,\n): Promise<{ results: string[]; blockNumber: number }> {\n  console.debug('Fetching chunk', multicallContract, chunk, minBlockNumber)\n  let resultsBlockNumber, returnData\n\n  try {\n    const res = await multicallContract.callStatic.tryBlockAndAggregate(\n      false, // requireSuccess\n      chunk.map(obj => ({\n        target: obj.address,\n        callData: obj.callData,\n        gasLimit: obj.gasRequired ?? 1_000_000,\n      })),\n    )\n\n    resultsBlockNumber = res.blockNumber\n    returnData = res.returnData.map((item: any) => item[1])\n    // ;[resultsBlockNumber, returnData] = await multicallContract.aggregate(chunk.map(obj => [obj.address, obj.callData]))\n  } catch (e) {\n    const error: any = e\n    if (\n      error.code === -32000 ||\n      (error?.data?.message && error?.data?.message?.indexOf('header not found') !== -1) ||\n      error.message?.indexOf('header not found') !== -1\n    ) {\n      throw new RetryableError(`header not found for block number ${minBlockNumber}`)\n    } else {\n      if (chunk.length > 1) {\n        if (process.env.NODE_ENV === 'development') {\n          console.debug('Splitting a chunk in 2', chunk)\n        }\n        const half = Math.floor(chunk.length / 2)\n        const [c0, c1] = await Promise.all([\n          fetchChunk(multicallContract, chunk.slice(0, half), minBlockNumber),\n          fetchChunk(multicallContract, chunk.slice(half, chunk.length), minBlockNumber),\n        ])\n        return {\n          results: c0.results.concat(c1.results),\n          blockNumber: c1.blockNumber,\n        }\n      }\n    }\n    console.debug('Failed to fetch chunk inside retry', error)\n    throw error\n  }\n  if (resultsBlockNumber.toNumber() < minBlockNumber) {\n    console.debug(`Fetched results for old block number: ${resultsBlockNumber.toString()} vs. ${minBlockNumber}`)\n    throw new RetryableError('Fetched for old block number')\n  }\n  return { results: returnData, blockNumber: resultsBlockNumber.toNumber() }\n}\n\n/**\n * From the current all listeners state, return each call key mapped to the\n * minimum number of blocks per fetch. This is how often each key must be fetched.\n * @param allListeners the all listeners state\n * @param chainId the current chain id\n */\nexport function activeListeningKeys(\n  allListeners: AppState['multicall']['callListeners'],\n  chainId?: number,\n): { [callKey: string]: number } {\n  if (!allListeners || !chainId) return {}\n  const listeners = allListeners[chainId]\n  if (!listeners) return {}\n\n  return Object.keys(listeners).reduce<{ [callKey: string]: number }>((memo, callKey) => {\n    const keyListeners = listeners[callKey]\n\n    memo[callKey] = Object.keys(keyListeners)\n      .filter(key => {\n        const blocksPerFetch = parseInt(key)\n        if (blocksPerFetch <= 0) return false\n        return keyListeners[blocksPerFetch] > 0\n      })\n      .reduce((previousMin, current) => {\n        return Math.min(previousMin, parseInt(current))\n      }, Infinity)\n    return memo\n  }, {})\n}\n\n/**\n * Return the keys that need to be refetched\n * @param callResults current call result state\n * @param listeningKeys each call key mapped to how old the data can be in blocks\n * @param chainId the current chain id\n * @param latestBlockNumber the latest block number\n */\nexport function outdatedListeningKeys(\n  callResults: AppState['multicall']['callResults'],\n  listeningKeys: { [callKey: string]: number },\n  chainId: number | undefined,\n  latestBlockNumber: number | undefined,\n): string[] {\n  if (!chainId || !latestBlockNumber) return []\n  const results = callResults[chainId]\n  // no results at all, load everything\n  if (!results) return Object.keys(listeningKeys)\n\n  return Object.keys(listeningKeys).filter(callKey => {\n    const blocksPerFetch = listeningKeys[callKey]\n\n    const data = callResults[chainId][callKey]\n    // no data, must fetch\n    if (!data) return true\n\n    const minDataBlockNumber = latestBlockNumber - (blocksPerFetch - 1)\n\n    // already fetching it for a recent enough block, don't refetch it\n    if (data.fetchingBlockNumber && data.fetchingBlockNumber >= minDataBlockNumber) return false\n\n    // if data is older than minDataBlockNumber, fetch it\n    return !data.blockNumber || data.blockNumber < minDataBlockNumber\n  })\n}\n\nexport default function Updater(): null {\n  const dispatch = useDispatch<AppDispatch>()\n  const state = useSelector<AppState, AppState['multicall']>(state => state.multicall)\n  // wait for listeners to settle before triggering updates\n  const debouncedListeners = useDebounce(state.callListeners, 100)\n  const latestBlockNumber = useBlockNumber()\n  const { chainId } = useActiveWeb3React()\n  const multicallContract = useMulticallContract()\n  const cancellations = useRef<{ blockNumber: number; cancellations: (() => void)[] }>()\n\n  const listeningKeys: { [callKey: string]: number } = useMemo(() => {\n    return activeListeningKeys(debouncedListeners, chainId)\n  }, [debouncedListeners, chainId])\n\n  const unserializedOutdatedCallKeys = useMemo(() => {\n    return outdatedListeningKeys(state.callResults, listeningKeys, chainId, latestBlockNumber)\n  }, [chainId, state.callResults, listeningKeys, latestBlockNumber])\n\n  const serializedOutdatedCallKeys = useMemo(\n    () => JSON.stringify(unserializedOutdatedCallKeys.sort()),\n    [unserializedOutdatedCallKeys],\n  )\n\n  useEffect(() => {\n    if (!latestBlockNumber || !chainId || !multicallContract) return\n\n    const outdatedCallKeys: string[] = JSON.parse(serializedOutdatedCallKeys)\n\n    if (outdatedCallKeys.length === 0) return\n    const calls = outdatedCallKeys.map(key => parseCallKey(key))\n\n    const chunkedCalls = chunkArray(calls, CALL_CHUNK_SIZE)\n\n    if (cancellations.current?.blockNumber !== latestBlockNumber) {\n      cancellations.current?.cancellations?.forEach(c => c())\n    }\n\n    dispatch(\n      fetchingMulticallResults({\n        calls,\n        chainId,\n        fetchingBlockNumber: latestBlockNumber,\n      }),\n    )\n\n    cancellations.current = {\n      blockNumber: latestBlockNumber,\n      cancellations: chunkedCalls.map((chunk, index) => {\n        const { cancel, promise } = retry(() => fetchChunk(multicallContract, chunk, latestBlockNumber), {\n          n: Infinity,\n          minWait: 2500,\n          maxWait: 3500,\n        })\n        promise\n          .then(({ results: returnData, blockNumber: fetchBlockNumber }) => {\n            cancellations.current = { cancellations: [], blockNumber: latestBlockNumber }\n\n            // accumulates the length of all previous indices\n            const firstCallKeyIndex = chunkedCalls.slice(0, index).reduce<number>((memo, curr) => memo + curr.length, 0)\n            const lastCallKeyIndex = firstCallKeyIndex + returnData.length\n\n            dispatch(\n              updateMulticallResults({\n                chainId,\n                results: outdatedCallKeys\n                  .slice(firstCallKeyIndex, lastCallKeyIndex)\n                  .reduce<{ [callKey: string]: string | null }>((memo, callKey, i) => {\n                    memo[callKey] = returnData[i] ?? null\n                    return memo\n                  }, {}),\n                blockNumber: fetchBlockNumber,\n              }),\n            )\n          })\n          .catch((error: any) => {\n            if (error instanceof CancelledError) {\n              console.debug('Cancelled fetch for blockNumber', latestBlockNumber)\n              return\n            }\n            console.error('Failed to fetch multicall chunk', chunk, chainId, error)\n            dispatch(\n              errorFetchingMulticallResults({\n                calls: chunk,\n                chainId,\n                fetchingBlockNumber: latestBlockNumber,\n              }),\n            )\n          })\n        return cancel\n      }),\n    }\n  }, [chainId, multicallContract, dispatch, serializedOutdatedCallKeys, latestBlockNumber])\n\n  return null\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}