{"ast":null,"code":"import _objectSpread from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { _nullishCoalesce } from '@sentry/utils/esm/buildPolyfills';\nimport { getCurrentHub } from '@sentry/hub';\nimport { logger, dropUndefinedKeys, isBaggageMutable, createBaggage, getSentryBaggageItems } from '@sentry/utils';\nimport { Span, SpanRecorder } from './span.js';\n/** JSDoc */\n\nvar Transaction = /*#__PURE__*/function (_Span) {\n  _inherits(Transaction, _Span);\n\n  var _super = _createSuper(Transaction);\n\n  /**\n   * This constructor should never be called manually. Those instrumenting tracing should use\n   * `Sentry.startTransaction()`, and internal methods should use `hub.startTransaction()`.\n   * @internal\n   * @hideconstructor\n   * @hidden\n   */\n  function Transaction(transactionContext, hub) {\n    var _this;\n\n    _classCallCheck(this, Transaction);\n\n    _this = _super.call(this, transactionContext);\n\n    Transaction.prototype.__init.call(_assertThisInitialized(_this));\n\n    ;\n    _this._hub = hub || getCurrentHub();\n    _this._name = transactionContext.name || '';\n    _this.metadata = _objectSpread(_objectSpread({}, transactionContext.metadata), {}, {\n      spanMetadata: {}\n    });\n    _this._trimEnd = transactionContext.trimEnd; // this is because transactions are also spans, and spans have a transaction pointer\n\n    _this.transaction = _assertThisInitialized(_this);\n    return _this;\n  }\n  /** Getter for `name` property */\n\n\n  _createClass(Transaction, [{\n    key: \"__init\",\n    value:\n    /**\n     * The reference to the current hub.\n     */\n    function __init() {\n      this._measurements = {};\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return this._name;\n    }\n    /** Setter for `name` property, which also sets `source` */\n    ,\n    set: function set(newName) {\n      this._name = newName;\n      this.metadata.source = 'custom';\n    }\n    /**\n     * JSDoc\n     */\n\n  }, {\n    key: \"setName\",\n    value: function setName(name) {\n      var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'custom';\n      this.name = name;\n      this.metadata.source = source;\n    }\n    /**\n     * Attaches SpanRecorder to the span itself\n     * @param maxlen maximum number of spans that can be recorded\n     */\n\n  }, {\n    key: \"initSpanRecorder\",\n    value: function initSpanRecorder() {\n      var maxlen = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;\n\n      if (!this.spanRecorder) {\n        this.spanRecorder = new SpanRecorder(maxlen);\n      }\n\n      this.spanRecorder.add(this);\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"setMeasurement\",\n    value: function setMeasurement(name, value) {\n      var unit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      this._measurements[name] = {\n        value: value,\n        unit: unit\n      };\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"setMetadata\",\n    value: function setMetadata(newMetadata) {\n      this.metadata = _objectSpread(_objectSpread({}, this.metadata), newMetadata);\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"finish\",\n    value: function finish(endTimestamp) {\n      var _this2 = this;\n\n      // This transaction is already finished, so we should not flush it again.\n      if (this.endTimestamp !== undefined) {\n        return undefined;\n      }\n\n      if (!this.name) {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Transaction has no name, falling back to `<unlabeled transaction>`.');\n        this.name = '<unlabeled transaction>';\n      } // just sets the end timestamp\n\n\n      _get(_getPrototypeOf(Transaction.prototype), \"finish\", this).call(this, endTimestamp);\n\n      if (this.sampled !== true) {\n        // At this point if `sampled !== true` we want to discard the transaction.\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] Discarding transaction because its trace was not chosen to be sampled.');\n\n        var client = this._hub.getClient();\n\n        if (client) {\n          client.recordDroppedEvent('sample_rate', 'transaction');\n        }\n\n        return undefined;\n      }\n\n      var finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter(function (s) {\n        return s !== _this2 && s.endTimestamp;\n      }) : [];\n\n      if (this._trimEnd && finishedSpans.length > 0) {\n        this.endTimestamp = finishedSpans.reduce(function (prev, current) {\n          if (prev.endTimestamp && current.endTimestamp) {\n            return prev.endTimestamp > current.endTimestamp ? prev : current;\n          }\n\n          return prev;\n        }).endTimestamp;\n      }\n\n      var metadata = this.metadata;\n\n      var transaction = _objectSpread({\n        contexts: {\n          trace: this.getTraceContext()\n        },\n        spans: finishedSpans,\n        start_timestamp: this.startTimestamp,\n        tags: this.tags,\n        timestamp: this.endTimestamp,\n        transaction: this.name,\n        type: 'transaction',\n        sdkProcessingMetadata: _objectSpread(_objectSpread({}, metadata), {}, {\n          baggage: this.getBaggage()\n        })\n      }, metadata.source && {\n        transaction_info: {\n          source: metadata.source\n        }\n      });\n\n      var hasMeasurements = Object.keys(this._measurements).length > 0;\n\n      if (hasMeasurements) {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Measurements] Adding measurements to transaction', JSON.stringify(this._measurements, undefined, 2));\n        transaction.measurements = this._measurements;\n      }\n\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(\"[Tracing] Finishing \".concat(this.op, \" transaction: \").concat(this.name, \".\"));\n      return this._hub.captureEvent(transaction);\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"toContext\",\n    value: function toContext() {\n      var spanContext = _get(_getPrototypeOf(Transaction.prototype), \"toContext\", this).call(this);\n\n      return dropUndefinedKeys(_objectSpread(_objectSpread({}, spanContext), {}, {\n        name: this.name,\n        trimEnd: this._trimEnd\n      }));\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"updateWithContext\",\n    value: function updateWithContext(transactionContext) {\n      _get(_getPrototypeOf(Transaction.prototype), \"updateWithContext\", this).call(this, transactionContext);\n\n      this.name = _nullishCoalesce(transactionContext.name, function () {\n        return '';\n      });\n      this._trimEnd = transactionContext.trimEnd;\n      return this;\n    }\n    /**\n     * @inheritdoc\n     *\n     * @experimental\n     */\n\n  }, {\n    key: \"getBaggage\",\n    value: function getBaggage() {\n      var existingBaggage = this.metadata.baggage; // Only add Sentry baggage items to baggage, if baggage does not exist yet or it is still\n      // empty and mutable\n\n      var finalBaggage = !existingBaggage || isBaggageMutable(existingBaggage) ? this._populateBaggageWithSentryValues(existingBaggage) : existingBaggage; // Update the baggage stored on the transaction.\n\n      this.metadata.baggage = finalBaggage;\n      return finalBaggage;\n    }\n    /**\n     * Collects and adds data to the passed baggage object.\n     *\n     * Note: This function does not explicitly check if the passed baggage object is allowed\n     * to be modified. Implicitly, `setBaggageValue` will not make modification to the object\n     * if it was already set immutable.\n     *\n     * After adding the data, the baggage object is set immutable to prevent further modifications.\n     *\n     * @param baggage\n     *\n     * @returns modified and immutable baggage object\n     */\n\n  }, {\n    key: \"_populateBaggageWithSentryValues\",\n    value: function _populateBaggageWithSentryValues() {\n      var baggage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : createBaggage({});\n      var hub = this._hub || getCurrentHub();\n      var client = hub && hub.getClient();\n      if (!client) return baggage;\n\n      var _ref = client.getOptions() || {},\n          environment = _ref.environment,\n          release = _ref.release;\n\n      var _ref2 = client.getDsn() || {},\n          public_key = _ref2.publicKey;\n\n      var sample_rate = this.metadata && this.metadata.transactionSampling && this.metadata.transactionSampling.rate && this.metadata.transactionSampling.rate.toString();\n      var scope = hub.getScope();\n\n      var _ref3 = scope && scope.getUser() || {},\n          user_segment = _ref3.segment;\n\n      var source = this.metadata.source;\n      var transaction = source && source !== 'url' ? this.name : undefined;\n      return createBaggage(dropUndefinedKeys(_objectSpread({\n        environment: environment,\n        release: release,\n        transaction: transaction,\n        user_segment: user_segment,\n        public_key: public_key,\n        trace_id: this.traceId,\n        sample_rate: sample_rate\n      }, getSentryBaggageItems(baggage))), '', false // set baggage immutable\n      );\n    }\n  }]);\n\n  return Transaction;\n}(Span);\n\nexport { Transaction };","map":null,"metadata":{},"sourceType":"module"}