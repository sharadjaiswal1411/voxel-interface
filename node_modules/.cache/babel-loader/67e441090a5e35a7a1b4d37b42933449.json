{"ast":null,"code":"import _objectSpread from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { tickToPrice } from '@kyberswap/ks-sdk-elastic';\nimport JSBI from 'jsbi';\nvar PRICE_FIXED_DIGITS = 8; // Computes the numSurroundingTicks above or below the active tick.\n\nexport default function computeSurroundingTicks(token0, token1, activeTickProcessed, sortedTickData, pivot, ascending) {\n  var previousTickProcessed = _objectSpread({}, activeTickProcessed); // Iterate outwards (either up or down depending on direction) from the active tick,\n  // building active liquidity for every tick.\n\n\n  var processedTicks = [];\n\n  for (var i = pivot + (ascending ? 1 : -1); ascending ? i < sortedTickData.length : i >= 0; ascending ? i++ : i--) {\n    var tickIdx = Number(sortedTickData[i].tickIdx);\n    var currentTickProcessed = {\n      liquidityActive: previousTickProcessed.liquidityActive,\n      tickIdx: tickIdx,\n      liquidityNet: JSBI.BigInt(sortedTickData[i].liquidityNet),\n      price0: tickToPrice(token0, token1, tickIdx).toFixed(PRICE_FIXED_DIGITS)\n    }; // Update the active liquidity.\n    // If we are iterating ascending and we found an initialized tick we immediately apply\n    // it to the current processed tick we are building.\n    // If we are iterating descending, we don't want to apply the net liquidity until the following tick.\n\n    if (ascending) {\n      currentTickProcessed.liquidityActive = JSBI.add(previousTickProcessed.liquidityActive, JSBI.BigInt(sortedTickData[i].liquidityNet));\n    } else if (!ascending && JSBI.notEqual(previousTickProcessed.liquidityNet, JSBI.BigInt(0))) {\n      // We are iterating descending, so look at the previous tick and apply any net liquidity.\n      currentTickProcessed.liquidityActive = JSBI.subtract(previousTickProcessed.liquidityActive, previousTickProcessed.liquidityNet);\n    }\n\n    processedTicks.push(currentTickProcessed);\n    previousTickProcessed = currentTickProcessed;\n  }\n\n  if (!ascending) {\n    processedTicks = processedTicks.reverse();\n  }\n\n  return processedTicks;\n}","map":{"version":3,"names":["tickToPrice","JSBI","PRICE_FIXED_DIGITS","computeSurroundingTicks","token0","token1","activeTickProcessed","sortedTickData","pivot","ascending","previousTickProcessed","processedTicks","i","length","tickIdx","Number","currentTickProcessed","liquidityActive","liquidityNet","BigInt","price0","toFixed","add","notEqual","subtract","push","reverse"],"sources":["/Applications/XAMPP/voxel-interface/src/utils/computeSurroundingTicks.ts"],"sourcesContent":["import { Token } from '@kyberswap/ks-sdk-core'\nimport { tickToPrice } from '@kyberswap/ks-sdk-elastic'\nimport JSBI from 'jsbi'\n\nimport { Tick } from 'apollo/queries/promm'\nimport { TickProcessed } from 'hooks/usePoolTickData'\n\nconst PRICE_FIXED_DIGITS = 8\n\n// Computes the numSurroundingTicks above or below the active tick.\nexport default function computeSurroundingTicks(\n  token0: Token,\n  token1: Token,\n  activeTickProcessed: TickProcessed,\n  sortedTickData: Tick[],\n  pivot: number,\n  ascending: boolean,\n): TickProcessed[] {\n  let previousTickProcessed: TickProcessed = {\n    ...activeTickProcessed,\n  }\n  // Iterate outwards (either up or down depending on direction) from the active tick,\n  // building active liquidity for every tick.\n  let processedTicks: TickProcessed[] = []\n  for (let i = pivot + (ascending ? 1 : -1); ascending ? i < sortedTickData.length : i >= 0; ascending ? i++ : i--) {\n    const tickIdx = Number(sortedTickData[i].tickIdx)\n    const currentTickProcessed: TickProcessed = {\n      liquidityActive: previousTickProcessed.liquidityActive,\n      tickIdx,\n      liquidityNet: JSBI.BigInt(sortedTickData[i].liquidityNet),\n      price0: tickToPrice(token0, token1, tickIdx).toFixed(PRICE_FIXED_DIGITS),\n    }\n\n    // Update the active liquidity.\n    // If we are iterating ascending and we found an initialized tick we immediately apply\n    // it to the current processed tick we are building.\n    // If we are iterating descending, we don't want to apply the net liquidity until the following tick.\n    if (ascending) {\n      currentTickProcessed.liquidityActive = JSBI.add(\n        previousTickProcessed.liquidityActive,\n        JSBI.BigInt(sortedTickData[i].liquidityNet),\n      )\n    } else if (!ascending && JSBI.notEqual(previousTickProcessed.liquidityNet, JSBI.BigInt(0))) {\n      // We are iterating descending, so look at the previous tick and apply any net liquidity.\n      currentTickProcessed.liquidityActive = JSBI.subtract(\n        previousTickProcessed.liquidityActive,\n        previousTickProcessed.liquidityNet,\n      )\n    }\n\n    processedTicks.push(currentTickProcessed)\n    previousTickProcessed = currentTickProcessed\n  }\n\n  if (!ascending) {\n    processedTicks = processedTicks.reverse()\n  }\n\n  return processedTicks\n}\n"],"mappings":";AACA,SAASA,WAAT,QAA4B,2BAA5B;AACA,OAAOC,IAAP,MAAiB,MAAjB;AAKA,IAAMC,kBAAkB,GAAG,CAA3B,C,CAEA;;AACA,eAAe,SAASC,uBAAT,CACbC,MADa,EAEbC,MAFa,EAGbC,mBAHa,EAIbC,cAJa,EAKbC,KALa,EAMbC,SANa,EAOI;EACjB,IAAIC,qBAAoC,qBACnCJ,mBADmC,CAAxC,CADiB,CAIjB;EACA;;;EACA,IAAIK,cAA+B,GAAG,EAAtC;;EACA,KAAK,IAAIC,CAAC,GAAGJ,KAAK,IAAIC,SAAS,GAAG,CAAH,GAAO,CAAC,CAArB,CAAlB,EAA2CA,SAAS,GAAGG,CAAC,GAAGL,cAAc,CAACM,MAAtB,GAA+BD,CAAC,IAAI,CAAxF,EAA2FH,SAAS,GAAGG,CAAC,EAAJ,GAASA,CAAC,EAA9G,EAAkH;IAChH,IAAME,OAAO,GAAGC,MAAM,CAACR,cAAc,CAACK,CAAD,CAAd,CAAkBE,OAAnB,CAAtB;IACA,IAAME,oBAAmC,GAAG;MAC1CC,eAAe,EAAEP,qBAAqB,CAACO,eADG;MAE1CH,OAAO,EAAPA,OAF0C;MAG1CI,YAAY,EAAEjB,IAAI,CAACkB,MAAL,CAAYZ,cAAc,CAACK,CAAD,CAAd,CAAkBM,YAA9B,CAH4B;MAI1CE,MAAM,EAAEpB,WAAW,CAACI,MAAD,EAASC,MAAT,EAAiBS,OAAjB,CAAX,CAAqCO,OAArC,CAA6CnB,kBAA7C;IAJkC,CAA5C,CAFgH,CAShH;IACA;IACA;IACA;;IACA,IAAIO,SAAJ,EAAe;MACbO,oBAAoB,CAACC,eAArB,GAAuChB,IAAI,CAACqB,GAAL,CACrCZ,qBAAqB,CAACO,eADe,EAErChB,IAAI,CAACkB,MAAL,CAAYZ,cAAc,CAACK,CAAD,CAAd,CAAkBM,YAA9B,CAFqC,CAAvC;IAID,CALD,MAKO,IAAI,CAACT,SAAD,IAAcR,IAAI,CAACsB,QAAL,CAAcb,qBAAqB,CAACQ,YAApC,EAAkDjB,IAAI,CAACkB,MAAL,CAAY,CAAZ,CAAlD,CAAlB,EAAqF;MAC1F;MACAH,oBAAoB,CAACC,eAArB,GAAuChB,IAAI,CAACuB,QAAL,CACrCd,qBAAqB,CAACO,eADe,EAErCP,qBAAqB,CAACQ,YAFe,CAAvC;IAID;;IAEDP,cAAc,CAACc,IAAf,CAAoBT,oBAApB;IACAN,qBAAqB,GAAGM,oBAAxB;EACD;;EAED,IAAI,CAACP,SAAL,EAAgB;IACdE,cAAc,GAAGA,cAAc,CAACe,OAAf,EAAjB;EACD;;EAED,OAAOf,cAAP;AACD"},"metadata":{},"sourceType":"module"}