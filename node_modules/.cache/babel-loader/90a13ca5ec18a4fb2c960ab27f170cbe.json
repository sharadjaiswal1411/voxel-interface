{"ast":null,"code":"import _slicedToArray from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _defineProperty from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n\nvar _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$();\n\nimport { i18n } from \"@lingui/core\";\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { Percent, TokenAmount } from '@kyberswap/ks-sdk-core';\nimport JSBI from 'jsbi';\nimport { useCallback, useMemo } from 'react';\nimport { useSelector } from 'react-redux';\nimport { useZapOutAmount } from 'hooks/useZap';\nimport { useAppDispatch } from 'state/hooks';\nimport { useUserSlippageTolerance } from 'state/user/hooks';\nimport { calculateSlippageAmount } from 'utils';\nimport { usePairByAddress } from '../../data/Reserves';\nimport { useTotalSupply } from '../../data/TotalSupply';\nimport { useActiveWeb3React } from '../../hooks';\nimport { tryParseAmount } from '../swap/hooks';\nimport { useTokenBalances } from '../wallet/hooks';\nimport { Field, switchTokenField, typeInput } from './actions';\nexport function useBurnState() {\n  _s();\n\n  return useSelector(function (state) {\n    return state.burn;\n  });\n}\n\n_s(useBurnState, \"nKHvd/QB6hocKEk0fSJoSYcCyR8=\", false, function () {\n  return [useSelector];\n});\n\nexport function useDerivedBurnInfo(currencyA, currencyB, pairAddress) {\n  _s2();\n\n  var _pair$liquidityToken$, _pair$liquidityToken, _tokens, _liquidityValues, _parsedAmounts, _amountsMin, _parsedAmounts$Field$;\n\n  var _useActiveWeb3React = useActiveWeb3React(),\n      account = _useActiveWeb3React.account;\n\n  var _useBurnState = useBurnState(),\n      independentField = _useBurnState.independentField,\n      typedValue = _useBurnState.typedValue;\n\n  var dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A; // tokens\n\n  var currencies = useMemo(function () {\n    var _ref;\n\n    return _ref = {}, _defineProperty(_ref, Field.CURRENCY_A, currencyA !== null && currencyA !== void 0 ? currencyA : undefined), _defineProperty(_ref, Field.CURRENCY_B, currencyB !== null && currencyB !== void 0 ? currencyB : undefined), _ref;\n  }, [currencyA, currencyB]);\n  var tokenA = currencyA === null || currencyA === void 0 ? void 0 : currencyA.wrapped,\n      tokenB = currencyB === null || currencyB === void 0 ? void 0 : currencyB.wrapped;\n  var error; // pair + totalsupply\n\n  var _usePairByAddress = usePairByAddress(tokenA, tokenB, pairAddress),\n      _usePairByAddress2 = _slicedToArray(_usePairByAddress, 4),\n      pair = _usePairByAddress2[1],\n      isStaticFeePair = _usePairByAddress2[2],\n      isOldStaticFeeContract = _usePairByAddress2[3];\n\n  var _useUserSlippageToler = useUserSlippageTolerance(),\n      _useUserSlippageToler2 = _slicedToArray(_useUserSlippageToler, 1),\n      allowedSlippage = _useUserSlippageToler2[0]; // balances\n\n\n  var relevantTokenBalances = useTokenBalances(account !== null && account !== void 0 ? account : undefined, [pair === null || pair === void 0 ? void 0 : pair.liquidityToken]);\n  var userLiquidity = relevantTokenBalances === null || relevantTokenBalances === void 0 ? void 0 : relevantTokenBalances[(_pair$liquidityToken$ = pair === null || pair === void 0 ? void 0 : (_pair$liquidityToken = pair.liquidityToken) === null || _pair$liquidityToken === void 0 ? void 0 : _pair$liquidityToken.address) !== null && _pair$liquidityToken$ !== void 0 ? _pair$liquidityToken$ : ''];\n  var tokens = (_tokens = {}, _defineProperty(_tokens, Field.CURRENCY_A, tokenA), _defineProperty(_tokens, Field.CURRENCY_B, tokenB), _defineProperty(_tokens, Field.LIQUIDITY, pair === null || pair === void 0 ? void 0 : pair.liquidityToken), _tokens); // liquidity values\n\n  var totalSupply = useTotalSupply(pair === null || pair === void 0 ? void 0 : pair.liquidityToken);\n  var liquidityValueA = pair && totalSupply && userLiquidity && tokenA && // this condition is a short-circuit in the case where useTokenBalance updates sooner than useTotalSupply\n  JSBI.greaterThanOrEqual(totalSupply.quotient, userLiquidity.quotient) ? TokenAmount.fromRawAmount(tokenA, pair.getLiquidityValue(tokenA, totalSupply, userLiquidity).quotient) : undefined;\n  var liquidityValueB = pair && totalSupply && userLiquidity && tokenB && // this condition is a short-circuit in the case where useTokenBalance updates sooner than useTotalSupply\n  JSBI.greaterThanOrEqual(totalSupply.quotient, userLiquidity.quotient) ? TokenAmount.fromRawAmount(tokenB, pair.getLiquidityValue(tokenB, totalSupply, userLiquidity).quotient) : undefined;\n  var liquidityValues = (_liquidityValues = {}, _defineProperty(_liquidityValues, Field.CURRENCY_A, liquidityValueA), _defineProperty(_liquidityValues, Field.CURRENCY_B, liquidityValueB), _liquidityValues);\n  var percentToRemove = new Percent('0', '100'); // user specified a %\n\n  if (independentField === Field.LIQUIDITY_PERCENT) {\n    percentToRemove = new Percent(typedValue, '100');\n  } // user specified a specific amount of liquidity tokens\n  else if (independentField === Field.LIQUIDITY) {\n    if (pair !== null && pair !== void 0 && pair.liquidityToken) {\n      var independentAmount = tryParseAmount(typedValue, pair.liquidityToken);\n\n      if (independentAmount && userLiquidity && independentAmount.greaterThan(userLiquidity)) {\n        var _error;\n\n        error = (_error = error) !== null && _error !== void 0 ? _error :\n        /*i18n*/\n        i18n._(\"Insufficient balance\");\n      }\n\n      if (independentAmount && userLiquidity && !independentAmount.greaterThan(userLiquidity)) {\n        percentToRemove = new Percent(independentAmount.quotient, userLiquidity.quotient);\n      }\n    }\n  } // user specified a specific amount of token a or b\n  else {\n    if (tokens[independentField]) {\n      var _independentAmount = tryParseAmount(typedValue, tokens[independentField]);\n\n      var liquidityValue = liquidityValues[independentField];\n\n      if (_independentAmount && liquidityValue && !_independentAmount.greaterThan(liquidityValue)) {\n        percentToRemove = new Percent(_independentAmount.quotient, liquidityValue.quotient);\n      }\n    }\n  }\n\n  var parsedAmounts = (_parsedAmounts = {}, _defineProperty(_parsedAmounts, Field.LIQUIDITY_PERCENT, percentToRemove), _defineProperty(_parsedAmounts, Field.LIQUIDITY, userLiquidity && percentToRemove && percentToRemove.greaterThan('0') ? TokenAmount.fromRawAmount(userLiquidity.currency, percentToRemove.multiply(userLiquidity.quotient).quotient) : undefined), _defineProperty(_parsedAmounts, Field.CURRENCY_A, tokenA && percentToRemove && percentToRemove.greaterThan('0') && liquidityValueA ? TokenAmount.fromRawAmount(tokenA, percentToRemove.multiply(liquidityValueA.quotient).quotient) : undefined), _defineProperty(_parsedAmounts, Field.CURRENCY_B, tokenB && percentToRemove && percentToRemove.greaterThan('0') && liquidityValueB ? TokenAmount.fromRawAmount(tokenB, percentToRemove.multiply(liquidityValueB.quotient).quotient) : undefined), _parsedAmounts);\n  var amountsMin = (_amountsMin = {}, _defineProperty(_amountsMin, Field.CURRENCY_A, parsedAmounts && parsedAmounts[Field.CURRENCY_A] ? calculateSlippageAmount(parsedAmounts[Field.CURRENCY_A], allowedSlippage)[0] : undefined), _defineProperty(_amountsMin, Field.CURRENCY_B, parsedAmounts && parsedAmounts[Field.CURRENCY_B] ? calculateSlippageAmount(parsedAmounts[Field.CURRENCY_B], allowedSlippage)[0] : undefined), _amountsMin);\n  var price = useMemo(function () {\n    var wrappedCurrencyA = currencyA === null || currencyA === void 0 ? void 0 : currencyA.wrapped;\n    return pair && wrappedCurrencyA ? pair.priceOf(wrappedCurrencyA) : undefined;\n  }, [currencyA, pair]);\n\n  if (!account) {\n    error =\n    /*i18n*/\n    i18n._(\"Connect wallet\");\n  }\n\n  if (!parsedAmounts[Field.LIQUIDITY] || !parsedAmounts[Field.CURRENCY_A] || !parsedAmounts[Field.CURRENCY_B]) {\n    var _error2;\n\n    error = (_error2 = error) !== null && _error2 !== void 0 ? _error2 :\n    /*i18n*/\n    i18n._(\"Enter an amount\");\n  }\n\n  if (userLiquidity && (_parsedAmounts$Field$ = parsedAmounts[Field.LIQUIDITY]) !== null && _parsedAmounts$Field$ !== void 0 && _parsedAmounts$Field$.greaterThan(userLiquidity)) {\n    var _error3;\n\n    error = (_error3 = error) !== null && _error3 !== void 0 ? _error3 :\n    /*i18n*/\n    i18n._(\"Insufficient balance\");\n  }\n\n  return {\n    dependentField: dependentField,\n    currencies: currencies,\n    pair: pair,\n    userLiquidity: userLiquidity,\n    parsedAmounts: parsedAmounts,\n    amountsMin: amountsMin,\n    price: price,\n    error: error,\n    isStaticFeePair: isStaticFeePair,\n    isOldStaticFeeContract: isOldStaticFeeContract\n  };\n}\n\n_s2(useDerivedBurnInfo, \"yI63sbvMwZ+VN9ux8+GaPvoTJuU=\", false, function () {\n  return [useActiveWeb3React, useBurnState, usePairByAddress, useUserSlippageTolerance, useTokenBalances, useTotalSupply];\n});\n\nexport function useBurnActionHandlers() {\n  _s3();\n\n  var dispatch = useAppDispatch();\n  var onUserInput = useCallback(function (field, typedValue) {\n    dispatch(typeInput({\n      field: field,\n      typedValue: typedValue\n    }));\n  }, [dispatch]);\n  return {\n    onUserInput: onUserInput\n  };\n}\n\n_s3(useBurnActionHandlers, \"r/x3H4MiKpsB+LnefuuwydAEap8=\", false, function () {\n  return [useAppDispatch];\n});\n\nexport function useDerivedZapOutInfo(currencyA, currencyB, pairAddress) {\n  _s4();\n\n  var _pair$liquidityToken$2, _pair$liquidityToken2, _tokens2, _liquidityValues2, _noZapAmounts, _parsedAmounts2, _amountsMin2, _parsedAmounts$Field$2, _zapOutAmount$error$m, _zapOutAmount$error$d, _zapOutAmount$error$d2;\n\n  var _useActiveWeb3React2 = useActiveWeb3React(),\n      account = _useActiveWeb3React2.account;\n\n  var _useBurnState2 = useBurnState(),\n      independentField = _useBurnState2.independentField,\n      independentTokenField = _useBurnState2.independentTokenField,\n      typedValue = _useBurnState2.typedValue;\n\n  var dependentTokenField = independentTokenField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A; // tokens\n\n  var currencies = useMemo(function () {\n    var _ref2;\n\n    return _ref2 = {}, _defineProperty(_ref2, Field.CURRENCY_A, currencyA !== null && currencyA !== void 0 ? currencyA : undefined), _defineProperty(_ref2, Field.CURRENCY_B, currencyB !== null && currencyB !== void 0 ? currencyB : undefined), _ref2;\n  }, [currencyA, currencyB]);\n  var tokenA = currencyA === null || currencyA === void 0 ? void 0 : currencyA.wrapped,\n      tokenB = currencyB === null || currencyB === void 0 ? void 0 : currencyB.wrapped;\n  var tokenIn = independentTokenField === Field.CURRENCY_A ? tokenB : tokenA;\n  var tokenOut = independentTokenField === Field.CURRENCY_A ? tokenA : tokenB;\n  var insufficientLiquidity = false;\n  var error; // pair + totalsupply\n\n  var _usePairByAddress3 = usePairByAddress(tokenA, tokenB, pairAddress),\n      _usePairByAddress4 = _slicedToArray(_usePairByAddress3, 4),\n      pair = _usePairByAddress4[1],\n      isStaticFeePair = _usePairByAddress4[2],\n      isOldStaticFeeContract = _usePairByAddress4[3];\n\n  var _useUserSlippageToler3 = useUserSlippageTolerance(),\n      _useUserSlippageToler4 = _slicedToArray(_useUserSlippageToler3, 1),\n      allowedSlippage = _useUserSlippageToler4[0]; // balances\n\n\n  var relevantTokenBalances = useTokenBalances(account !== null && account !== void 0 ? account : undefined, [pair === null || pair === void 0 ? void 0 : pair.liquidityToken]);\n  var userLiquidity = relevantTokenBalances === null || relevantTokenBalances === void 0 ? void 0 : relevantTokenBalances[(_pair$liquidityToken$2 = pair === null || pair === void 0 ? void 0 : (_pair$liquidityToken2 = pair.liquidityToken) === null || _pair$liquidityToken2 === void 0 ? void 0 : _pair$liquidityToken2.address) !== null && _pair$liquidityToken$2 !== void 0 ? _pair$liquidityToken$2 : ''];\n  var tokens = (_tokens2 = {}, _defineProperty(_tokens2, Field.CURRENCY_A, tokenA), _defineProperty(_tokens2, Field.CURRENCY_B, tokenB), _defineProperty(_tokens2, Field.LIQUIDITY, pair === null || pair === void 0 ? void 0 : pair.liquidityToken), _tokens2); // liquidity values\n\n  var totalSupply = useTotalSupply(pair === null || pair === void 0 ? void 0 : pair.liquidityToken);\n  var liquidityValueA = pair && totalSupply && userLiquidity && tokenA && // this condition is a short-circuit in the case where useTokenBalance updates sooner than useTotalSupply\n  JSBI.greaterThanOrEqual(totalSupply.quotient, userLiquidity.quotient) ? TokenAmount.fromRawAmount(tokenA, pair.getLiquidityValue(tokenA, totalSupply, userLiquidity).quotient) : undefined;\n  var liquidityValueB = pair && totalSupply && userLiquidity && tokenB && // this condition is a short-circuit in the case where useTokenBalance updates sooner than useTotalSupply\n  JSBI.greaterThanOrEqual(totalSupply.quotient, userLiquidity.quotient) ? TokenAmount.fromRawAmount(tokenB, pair.getLiquidityValue(tokenB, totalSupply, userLiquidity).quotient) : undefined;\n  var liquidityValues = (_liquidityValues2 = {}, _defineProperty(_liquidityValues2, Field.CURRENCY_A, liquidityValueA), _defineProperty(_liquidityValues2, Field.CURRENCY_B, liquidityValueB), _liquidityValues2);\n  var percentToRemove = new Percent('0', '100'); // user specified a %\n\n  if (independentField === Field.LIQUIDITY_PERCENT) {\n    percentToRemove = new Percent(typedValue, '100');\n  } // user specified a specific amount of liquidity tokens\n  else if (independentField === Field.LIQUIDITY) {\n    if (pair !== null && pair !== void 0 && pair.liquidityToken) {\n      var independentAmount = tryParseAmount(typedValue, pair.liquidityToken);\n\n      if (independentAmount && userLiquidity && independentAmount.greaterThan(userLiquidity)) {\n        var _error4;\n\n        error = (_error4 = error) !== null && _error4 !== void 0 ? _error4 :\n        /*i18n*/\n        i18n._(\"Insufficient balance\");\n      }\n\n      if (independentAmount && userLiquidity && !independentAmount.greaterThan(userLiquidity)) {\n        percentToRemove = new Percent(independentAmount.quotient, userLiquidity.quotient);\n      }\n    }\n  } // user specified a specific amount of token a or b\n  else {\n    if (tokens[independentField]) {\n      var _independentAmount2 = tryParseAmount(typedValue, tokens[independentField]);\n\n      var liquidityValue = liquidityValues[independentField];\n\n      if (_independentAmount2 && liquidityValue && !_independentAmount2.greaterThan(liquidityValue)) {\n        percentToRemove = new Percent(_independentAmount2.quotient, liquidityValue.quotient);\n      }\n    }\n  }\n\n  var lpQty = useMemo(function () {\n    if (!userLiquidity) {\n      return BigNumber.from('0');\n    }\n\n    var liquidityToRemove = JSBI.divide(JSBI.multiply(userLiquidity.quotient, percentToRemove.numerator), percentToRemove.denominator);\n    return BigNumber.from(liquidityToRemove.toString()); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [userLiquidity === null || userLiquidity === void 0 ? void 0 : userLiquidity.quotient.toString(), percentToRemove.numerator.toString(), percentToRemove.denominator.toString()]);\n  var zapOutAmount = useZapOutAmount(!!isStaticFeePair, !!isOldStaticFeeContract, tokenIn === null || tokenIn === void 0 ? void 0 : tokenIn.address, tokenOut === null || tokenOut === void 0 ? void 0 : tokenOut.address, pair === null || pair === void 0 ? void 0 : pair.address, lpQty); // amounts\n\n  var independentTokenAmount = tryParseAmount(zapOutAmount.amount.toString(), currencies[independentTokenField], false);\n  var dependentTokenAmount = useMemo(function () {\n    if (independentTokenAmount && liquidityValueA && liquidityValueB) {\n      var amount = dependentTokenField === Field.CURRENCY_A ? JSBI.divide(JSBI.multiply(liquidityValueA.quotient, percentToRemove.numerator), percentToRemove.denominator) : JSBI.divide(JSBI.multiply(liquidityValueB.quotient, percentToRemove.numerator), percentToRemove.denominator);\n      return tryParseAmount(amount.toString(), currencies[dependentTokenField], false);\n    } else {\n      return undefined;\n    }\n  }, [independentTokenAmount, liquidityValueA, liquidityValueB, dependentTokenField, percentToRemove.numerator, percentToRemove.denominator, currencies]);\n  var noZapAmounts = (_noZapAmounts = {}, _defineProperty(_noZapAmounts, Field.CURRENCY_A, tokenA && liquidityValueA && percentToRemove && percentToRemove.greaterThan('0') ? TokenAmount.fromRawAmount(tokenA, percentToRemove.multiply(liquidityValueA.quotient).quotient) : undefined), _defineProperty(_noZapAmounts, Field.CURRENCY_B, tokenB && liquidityValueB && percentToRemove && percentToRemove.greaterThan('0') ? TokenAmount.fromRawAmount(tokenB, percentToRemove.multiply(liquidityValueB.quotient).quotient) : undefined), _noZapAmounts);\n  var parsedAmounts = (_parsedAmounts2 = {}, _defineProperty(_parsedAmounts2, Field.LIQUIDITY_PERCENT, percentToRemove), _defineProperty(_parsedAmounts2, Field.LIQUIDITY, userLiquidity && percentToRemove && percentToRemove.greaterThan('0') ? TokenAmount.fromRawAmount(userLiquidity.currency, percentToRemove.multiply(userLiquidity.quotient).quotient) : undefined), _defineProperty(_parsedAmounts2, independentTokenField, tokenOut && independentTokenAmount ? TokenAmount.fromRawAmount(tokenOut, independentTokenAmount.quotient) : undefined), _defineProperty(_parsedAmounts2, dependentTokenField, tokenIn && dependentTokenAmount ? TokenAmount.fromRawAmount(tokenIn, dependentTokenAmount.quotient) : undefined), _parsedAmounts2);\n  var amountsMin = (_amountsMin2 = {}, _defineProperty(_amountsMin2, Field.CURRENCY_A, parsedAmounts && parsedAmounts[Field.CURRENCY_A] ? calculateSlippageAmount(parsedAmounts[Field.CURRENCY_A], allowedSlippage)[0] : JSBI.BigInt(0)), _defineProperty(_amountsMin2, Field.CURRENCY_B, parsedAmounts && parsedAmounts[Field.CURRENCY_B] ? calculateSlippageAmount(parsedAmounts[Field.CURRENCY_B], allowedSlippage)[0] : JSBI.BigInt(0)), _amountsMin2);\n  var price = useMemo(function () {\n    var wrappedCurrencyA = currencyA === null || currencyA === void 0 ? void 0 : currencyA.wrapped;\n    return pair && wrappedCurrencyA ? pair.priceOf(wrappedCurrencyA) : undefined;\n  }, [currencyA, pair]);\n\n  if (!account) {\n    error =\n    /*i18n*/\n    i18n._(\"Connect wallet\");\n  }\n\n  if (!typedValue && !parsedAmounts[Field.LIQUIDITY]) {\n    var _error5;\n\n    error = (_error5 = error) !== null && _error5 !== void 0 ? _error5 :\n    /*i18n*/\n    i18n._(\"Enter an amount\");\n  }\n\n  if (typedValue && !parsedAmounts[Field.LIQUIDITY]) {\n    var _error6;\n\n    error = (_error6 = error) !== null && _error6 !== void 0 ? _error6 :\n    /*i18n*/\n    i18n._(\"Invalid amount\");\n  }\n\n  if (userLiquidity && (_parsedAmounts$Field$2 = parsedAmounts[Field.LIQUIDITY]) !== null && _parsedAmounts$Field$2 !== void 0 && _parsedAmounts$Field$2.greaterThan(userLiquidity)) {\n    var _error7;\n\n    error = (_error7 = error) !== null && _error7 !== void 0 ? _error7 :\n    /*i18n*/\n    i18n._(\"Insufficient balance\");\n  }\n\n  if (zapOutAmount.error && ((_zapOutAmount$error$m = zapOutAmount.error.message) !== null && _zapOutAmount$error$m !== void 0 && _zapOutAmount$error$m.includes('INSUFFICIENT_LIQUIDITY') || (_zapOutAmount$error$d = zapOutAmount.error.data) !== null && _zapOutAmount$error$d !== void 0 && (_zapOutAmount$error$d2 = _zapOutAmount$error$d.message) !== null && _zapOutAmount$error$d2 !== void 0 && _zapOutAmount$error$d2.includes('INSUFFICIENT_LIQUIDITY'))) {\n    insufficientLiquidity = true;\n  }\n\n  if (zapOutAmount.error && !insufficientLiquidity) {\n    console.error(zapOutAmount.error);\n    error =\n    /*i18n*/\n    i18n._(\"Something went wrong\");\n  }\n\n  return {\n    dependentTokenField: dependentTokenField,\n    currencies: currencies,\n    pair: pair,\n    userLiquidity: userLiquidity,\n    noZapAmounts: noZapAmounts,\n    parsedAmounts: parsedAmounts,\n    amountsMin: amountsMin,\n    insufficientLiquidity: insufficientLiquidity,\n    price: price,\n    error: error,\n    isStaticFeePair: isStaticFeePair,\n    isOldStaticFeeContract: isOldStaticFeeContract\n  };\n}\n\n_s4(useDerivedZapOutInfo, \"wki05J2aKqd/Khmhkud8mp2vziU=\", false, function () {\n  return [useActiveWeb3React, useBurnState, usePairByAddress, useUserSlippageTolerance, useTokenBalances, useTotalSupply, useZapOutAmount];\n});\n\nexport function useZapOutActionHandlers() {\n  _s5();\n\n  var dispatch = useAppDispatch();\n\n  var _useBurnState3 = useBurnState(),\n      independentTokenField = _useBurnState3.independentTokenField;\n\n  var onUserInput = useCallback(function (field, typedValue) {\n    dispatch(typeInput({\n      field: field,\n      typedValue: typedValue\n    }));\n  }, [dispatch]);\n  var onSwitchField = useCallback(function () {\n    dispatch(switchTokenField({\n      field: independentTokenField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A\n    }));\n  }, [dispatch, independentTokenField]);\n  return {\n    onUserInput: onUserInput,\n    onSwitchField: onSwitchField\n  };\n}\n\n_s5(useZapOutActionHandlers, \"dckkDgcvAkcqVXtNe++d/rR6F14=\", false, function () {\n  return [useAppDispatch, useBurnState];\n});","map":{"version":3,"names":["BigNumber","Percent","TokenAmount","JSBI","useCallback","useMemo","useSelector","useZapOutAmount","useAppDispatch","useUserSlippageTolerance","calculateSlippageAmount","usePairByAddress","useTotalSupply","useActiveWeb3React","tryParseAmount","useTokenBalances","Field","switchTokenField","typeInput","useBurnState","state","burn","useDerivedBurnInfo","currencyA","currencyB","pairAddress","account","independentField","typedValue","dependentField","CURRENCY_A","CURRENCY_B","currencies","undefined","tokenA","wrapped","tokenB","error","pair","isStaticFeePair","isOldStaticFeeContract","allowedSlippage","relevantTokenBalances","liquidityToken","userLiquidity","address","tokens","LIQUIDITY","totalSupply","liquidityValueA","greaterThanOrEqual","quotient","fromRawAmount","getLiquidityValue","liquidityValueB","liquidityValues","percentToRemove","LIQUIDITY_PERCENT","independentAmount","greaterThan","liquidityValue","parsedAmounts","currency","multiply","amountsMin","price","wrappedCurrencyA","priceOf","useBurnActionHandlers","dispatch","onUserInput","field","useDerivedZapOutInfo","independentTokenField","dependentTokenField","tokenIn","tokenOut","insufficientLiquidity","lpQty","from","liquidityToRemove","divide","numerator","denominator","toString","zapOutAmount","independentTokenAmount","amount","dependentTokenAmount","noZapAmounts","BigInt","message","includes","data","console","useZapOutActionHandlers","onSwitchField"],"sources":["/Applications/XAMPP/voxel-interface/src/state/burn/hooks.ts"],"sourcesContent":["import { BigNumber } from '@ethersproject/bignumber'\nimport { Pair } from '@kyberswap/ks-sdk-classic'\nimport { Currency, CurrencyAmount, Percent, Price, TokenAmount } from '@kyberswap/ks-sdk-core'\nimport { t } from '@lingui/macro'\nimport JSBI from 'jsbi'\nimport { useCallback, useMemo } from 'react'\nimport { useSelector } from 'react-redux'\n\nimport { useZapOutAmount } from 'hooks/useZap'\nimport { useAppDispatch } from 'state/hooks'\nimport { useUserSlippageTolerance } from 'state/user/hooks'\nimport { calculateSlippageAmount } from 'utils'\n\nimport { usePairByAddress } from '../../data/Reserves'\nimport { useTotalSupply } from '../../data/TotalSupply'\nimport { useActiveWeb3React } from '../../hooks'\nimport { AppState } from '../index'\nimport { tryParseAmount } from '../swap/hooks'\nimport { useTokenBalances } from '../wallet/hooks'\nimport { Field, switchTokenField, typeInput } from './actions'\n\nexport function useBurnState(): AppState['burn'] {\n  return useSelector<AppState, AppState['burn']>(state => state.burn)\n}\n\nexport function useDerivedBurnInfo(\n  currencyA: Currency | undefined,\n  currencyB: Currency | undefined,\n  pairAddress: string | undefined,\n): {\n  dependentField: Field\n  currencies: { [field in Field]?: Currency }\n  pair?: Pair | null\n  userLiquidity?: TokenAmount\n  parsedAmounts: {\n    [Field.LIQUIDITY_PERCENT]: Percent\n    [Field.LIQUIDITY]?: TokenAmount\n    [Field.CURRENCY_A]?: CurrencyAmount<Currency>\n    [Field.CURRENCY_B]?: CurrencyAmount<Currency>\n  }\n  amountsMin: {\n    [Field.CURRENCY_A]?: JSBI\n    [Field.CURRENCY_B]?: JSBI\n  }\n  price?: Price<Currency, Currency>\n  error?: string\n  isStaticFeePair?: boolean\n  isOldStaticFeeContract?: boolean\n} {\n  const { account } = useActiveWeb3React()\n\n  const { independentField, typedValue } = useBurnState()\n  const dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A\n\n  // tokens\n  const currencies: { [field in Field]?: Currency } = useMemo(\n    () => ({\n      [Field.CURRENCY_A]: currencyA ?? undefined,\n      [Field.CURRENCY_B]: currencyB ?? undefined,\n    }),\n    [currencyA, currencyB],\n  )\n\n  const [tokenA, tokenB] = [currencyA?.wrapped, currencyB?.wrapped]\n\n  let error: string | undefined\n\n  // pair + totalsupply\n  const [, pair, isStaticFeePair, isOldStaticFeeContract] = usePairByAddress(tokenA, tokenB, pairAddress)\n\n  const [allowedSlippage] = useUserSlippageTolerance()\n\n  // balances\n  const relevantTokenBalances = useTokenBalances(account ?? undefined, [pair?.liquidityToken])\n  const userLiquidity: undefined | TokenAmount = relevantTokenBalances?.[pair?.liquidityToken?.address ?? '']\n\n  const tokens = {\n    [Field.CURRENCY_A]: tokenA,\n    [Field.CURRENCY_B]: tokenB,\n    [Field.LIQUIDITY]: pair?.liquidityToken,\n  }\n\n  // liquidity values\n  const totalSupply = useTotalSupply(pair?.liquidityToken)\n  const liquidityValueA =\n    pair &&\n    totalSupply &&\n    userLiquidity &&\n    tokenA &&\n    // this condition is a short-circuit in the case where useTokenBalance updates sooner than useTotalSupply\n    JSBI.greaterThanOrEqual(totalSupply.quotient, userLiquidity.quotient)\n      ? TokenAmount.fromRawAmount(tokenA, pair.getLiquidityValue(tokenA, totalSupply, userLiquidity).quotient)\n      : undefined\n  const liquidityValueB =\n    pair &&\n    totalSupply &&\n    userLiquidity &&\n    tokenB &&\n    // this condition is a short-circuit in the case where useTokenBalance updates sooner than useTotalSupply\n    JSBI.greaterThanOrEqual(totalSupply.quotient, userLiquidity.quotient)\n      ? TokenAmount.fromRawAmount(tokenB, pair.getLiquidityValue(tokenB, totalSupply, userLiquidity).quotient)\n      : undefined\n  const liquidityValues: { [Field.CURRENCY_A]?: TokenAmount; [Field.CURRENCY_B]?: TokenAmount } = {\n    [Field.CURRENCY_A]: liquidityValueA,\n    [Field.CURRENCY_B]: liquidityValueB,\n  }\n\n  let percentToRemove: Percent = new Percent('0', '100')\n  // user specified a %\n  if (independentField === Field.LIQUIDITY_PERCENT) {\n    percentToRemove = new Percent(typedValue, '100')\n  }\n  // user specified a specific amount of liquidity tokens\n  else if (independentField === Field.LIQUIDITY) {\n    if (pair?.liquidityToken) {\n      const independentAmount = tryParseAmount(typedValue, pair.liquidityToken)\n      if (independentAmount && userLiquidity && independentAmount.greaterThan(userLiquidity)) {\n        error = error ?? t`Insufficient balance`\n      }\n\n      if (independentAmount && userLiquidity && !independentAmount.greaterThan(userLiquidity)) {\n        percentToRemove = new Percent(independentAmount.quotient, userLiquidity.quotient)\n      }\n    }\n  }\n  // user specified a specific amount of token a or b\n  else {\n    if (tokens[independentField]) {\n      const independentAmount = tryParseAmount(typedValue, tokens[independentField])\n      const liquidityValue = liquidityValues[independentField]\n      if (independentAmount && liquidityValue && !independentAmount.greaterThan(liquidityValue)) {\n        percentToRemove = new Percent(independentAmount.quotient, liquidityValue.quotient)\n      }\n    }\n  }\n\n  const parsedAmounts: {\n    [Field.LIQUIDITY_PERCENT]: Percent\n    [Field.LIQUIDITY]?: TokenAmount\n    [Field.CURRENCY_A]?: TokenAmount\n    [Field.CURRENCY_B]?: TokenAmount\n  } = {\n    [Field.LIQUIDITY_PERCENT]: percentToRemove,\n    [Field.LIQUIDITY]:\n      userLiquidity && percentToRemove && percentToRemove.greaterThan('0')\n        ? TokenAmount.fromRawAmount(userLiquidity.currency, percentToRemove.multiply(userLiquidity.quotient).quotient)\n        : undefined,\n    [Field.CURRENCY_A]:\n      tokenA && percentToRemove && percentToRemove.greaterThan('0') && liquidityValueA\n        ? TokenAmount.fromRawAmount(tokenA, percentToRemove.multiply(liquidityValueA.quotient).quotient)\n        : undefined,\n    [Field.CURRENCY_B]:\n      tokenB && percentToRemove && percentToRemove.greaterThan('0') && liquidityValueB\n        ? TokenAmount.fromRawAmount(tokenB, percentToRemove.multiply(liquidityValueB.quotient).quotient)\n        : undefined,\n  }\n\n  const amountsMin = {\n    [Field.CURRENCY_A]:\n      parsedAmounts && parsedAmounts[Field.CURRENCY_A]\n        ? calculateSlippageAmount(parsedAmounts[Field.CURRENCY_A] as CurrencyAmount<Currency>, allowedSlippage)[0]\n        : undefined,\n    [Field.CURRENCY_B]:\n      parsedAmounts && parsedAmounts[Field.CURRENCY_B]\n        ? calculateSlippageAmount(parsedAmounts[Field.CURRENCY_B] as CurrencyAmount<Currency>, allowedSlippage)[0]\n        : undefined,\n  }\n\n  const price = useMemo(() => {\n    const wrappedCurrencyA = currencyA?.wrapped\n    return pair && wrappedCurrencyA ? pair.priceOf(wrappedCurrencyA) : undefined\n  }, [currencyA, pair])\n\n  if (!account) {\n    error = t`Connect wallet`\n  }\n\n  if (!parsedAmounts[Field.LIQUIDITY] || !parsedAmounts[Field.CURRENCY_A] || !parsedAmounts[Field.CURRENCY_B]) {\n    error = error ?? t`Enter an amount`\n  }\n\n  if (userLiquidity && parsedAmounts[Field.LIQUIDITY]?.greaterThan(userLiquidity)) {\n    error = error ?? t`Insufficient balance`\n  }\n\n  return {\n    dependentField,\n    currencies,\n    pair,\n    userLiquidity,\n    parsedAmounts,\n    amountsMin,\n    price,\n    error,\n    isStaticFeePair,\n    isOldStaticFeeContract,\n  }\n}\n\nexport function useBurnActionHandlers(): {\n  onUserInput: (field: Field, typedValue: string) => void\n} {\n  const dispatch = useAppDispatch()\n\n  const onUserInput = useCallback(\n    (field: Field, typedValue: string) => {\n      dispatch(typeInput({ field, typedValue }))\n    },\n    [dispatch],\n  )\n\n  return {\n    onUserInput,\n  }\n}\n\nexport function useDerivedZapOutInfo(\n  currencyA: Currency | undefined,\n  currencyB: Currency | undefined,\n  pairAddress: string | undefined,\n): {\n  dependentTokenField: Field\n  currencies: { [field in Field]?: Currency }\n  pair?: Pair | null\n  userLiquidity?: TokenAmount\n  noZapAmounts: {\n    [field in Field]?: TokenAmount\n  }\n  parsedAmounts: {\n    [Field.LIQUIDITY_PERCENT]: Percent\n    [Field.LIQUIDITY]?: TokenAmount\n    [Field.CURRENCY_A]?: TokenAmount\n    [Field.CURRENCY_B]?: TokenAmount\n  }\n  amountsMin: {\n    [Field.CURRENCY_A]: JSBI\n    [Field.CURRENCY_B]: JSBI\n  }\n  insufficientLiquidity: boolean\n  price?: Price<Currency, Currency>\n  error?: string\n  isStaticFeePair?: boolean\n  isOldStaticFeeContract?: boolean\n} {\n  const { account } = useActiveWeb3React()\n\n  const { independentField, independentTokenField, typedValue } = useBurnState()\n  const dependentTokenField = independentTokenField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A\n\n  // tokens\n  const currencies: { [field in Field]?: Currency } = useMemo(\n    () => ({\n      [Field.CURRENCY_A]: currencyA ?? undefined,\n      [Field.CURRENCY_B]: currencyB ?? undefined,\n    }),\n    [currencyA, currencyB],\n  )\n\n  const [tokenA, tokenB] = [currencyA?.wrapped, currencyB?.wrapped]\n\n  const tokenIn = independentTokenField === Field.CURRENCY_A ? tokenB : tokenA\n  const tokenOut = independentTokenField === Field.CURRENCY_A ? tokenA : tokenB\n\n  let insufficientLiquidity = false\n  let error: string | undefined\n\n  // pair + totalsupply\n  const [, pair, isStaticFeePair, isOldStaticFeeContract] = usePairByAddress(tokenA, tokenB, pairAddress)\n\n  const [allowedSlippage] = useUserSlippageTolerance()\n\n  // balances\n  const relevantTokenBalances = useTokenBalances(account ?? undefined, [pair?.liquidityToken])\n  const userLiquidity: undefined | TokenAmount = relevantTokenBalances?.[pair?.liquidityToken?.address ?? '']\n\n  const tokens = {\n    [Field.CURRENCY_A]: tokenA,\n    [Field.CURRENCY_B]: tokenB,\n    [Field.LIQUIDITY]: pair?.liquidityToken,\n  }\n\n  // liquidity values\n  const totalSupply = useTotalSupply(pair?.liquidityToken)\n  const liquidityValueA =\n    pair &&\n    totalSupply &&\n    userLiquidity &&\n    tokenA &&\n    // this condition is a short-circuit in the case where useTokenBalance updates sooner than useTotalSupply\n    JSBI.greaterThanOrEqual(totalSupply.quotient, userLiquidity.quotient)\n      ? TokenAmount.fromRawAmount(tokenA, pair.getLiquidityValue(tokenA, totalSupply, userLiquidity).quotient)\n      : undefined\n  const liquidityValueB =\n    pair &&\n    totalSupply &&\n    userLiquidity &&\n    tokenB &&\n    // this condition is a short-circuit in the case where useTokenBalance updates sooner than useTotalSupply\n    JSBI.greaterThanOrEqual(totalSupply.quotient, userLiquidity.quotient)\n      ? TokenAmount.fromRawAmount(tokenB, pair.getLiquidityValue(tokenB, totalSupply, userLiquidity).quotient)\n      : undefined\n  const liquidityValues: { [field in Field]?: TokenAmount } = {\n    [Field.CURRENCY_A]: liquidityValueA,\n    [Field.CURRENCY_B]: liquidityValueB,\n  }\n\n  let percentToRemove: Percent = new Percent('0', '100')\n  // user specified a %\n  if (independentField === Field.LIQUIDITY_PERCENT) {\n    percentToRemove = new Percent(typedValue, '100')\n  }\n  // user specified a specific amount of liquidity tokens\n  else if (independentField === Field.LIQUIDITY) {\n    if (pair?.liquidityToken) {\n      const independentAmount = tryParseAmount(typedValue, pair.liquidityToken)\n\n      if (independentAmount && userLiquidity && independentAmount.greaterThan(userLiquidity)) {\n        error = error ?? t`Insufficient balance`\n      }\n\n      if (independentAmount && userLiquidity && !independentAmount.greaterThan(userLiquidity)) {\n        percentToRemove = new Percent(independentAmount.quotient, userLiquidity.quotient)\n      }\n    }\n  }\n  // user specified a specific amount of token a or b\n  else {\n    if (tokens[independentField]) {\n      const independentAmount = tryParseAmount(typedValue, tokens[independentField])\n      const liquidityValue = liquidityValues[independentField]\n      if (independentAmount && liquidityValue && !independentAmount.greaterThan(liquidityValue)) {\n        percentToRemove = new Percent(independentAmount.quotient, liquidityValue.quotient)\n      }\n    }\n  }\n\n  const lpQty = useMemo(() => {\n    if (!userLiquidity) {\n      return BigNumber.from('0')\n    }\n\n    const liquidityToRemove = JSBI.divide(\n      JSBI.multiply(userLiquidity.quotient, percentToRemove.numerator),\n      percentToRemove.denominator,\n    )\n\n    return BigNumber.from(liquidityToRemove.toString())\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [userLiquidity?.quotient.toString(), percentToRemove.numerator.toString(), percentToRemove.denominator.toString()])\n\n  const zapOutAmount = useZapOutAmount(\n    !!isStaticFeePair,\n    !!isOldStaticFeeContract,\n    tokenIn?.address,\n    tokenOut?.address,\n    pair?.address,\n    lpQty,\n  )\n\n  // amounts\n  const independentTokenAmount: CurrencyAmount<Currency> | undefined = tryParseAmount(\n    zapOutAmount.amount.toString(),\n    currencies[independentTokenField],\n    false,\n  )\n\n  const dependentTokenAmount: CurrencyAmount<Currency> | undefined = useMemo(() => {\n    if (independentTokenAmount && liquidityValueA && liquidityValueB) {\n      const amount =\n        dependentTokenField === Field.CURRENCY_A\n          ? JSBI.divide(JSBI.multiply(liquidityValueA.quotient, percentToRemove.numerator), percentToRemove.denominator)\n          : JSBI.divide(JSBI.multiply(liquidityValueB.quotient, percentToRemove.numerator), percentToRemove.denominator)\n\n      return tryParseAmount(amount.toString(), currencies[dependentTokenField], false)\n    } else {\n      return undefined\n    }\n  }, [\n    independentTokenAmount,\n    liquidityValueA,\n    liquidityValueB,\n    dependentTokenField,\n    percentToRemove.numerator,\n    percentToRemove.denominator,\n    currencies,\n  ])\n\n  const noZapAmounts: {\n    [Field.CURRENCY_A]?: TokenAmount\n    [Field.CURRENCY_B]?: TokenAmount\n  } = {\n    [Field.CURRENCY_A]:\n      tokenA && liquidityValueA && percentToRemove && percentToRemove.greaterThan('0')\n        ? TokenAmount.fromRawAmount(tokenA, percentToRemove.multiply(liquidityValueA.quotient).quotient)\n        : undefined,\n    [Field.CURRENCY_B]:\n      tokenB && liquidityValueB && percentToRemove && percentToRemove.greaterThan('0')\n        ? TokenAmount.fromRawAmount(tokenB, percentToRemove.multiply(liquidityValueB.quotient).quotient)\n        : undefined,\n  }\n\n  const parsedAmounts: {\n    [Field.LIQUIDITY_PERCENT]: Percent\n    [Field.LIQUIDITY]?: TokenAmount\n    [Field.CURRENCY_A]?: TokenAmount\n    [Field.CURRENCY_B]?: TokenAmount\n  } = {\n    [Field.LIQUIDITY_PERCENT]: percentToRemove,\n    [Field.LIQUIDITY]:\n      userLiquidity && percentToRemove && percentToRemove.greaterThan('0')\n        ? TokenAmount.fromRawAmount(userLiquidity.currency, percentToRemove.multiply(userLiquidity.quotient).quotient)\n        : undefined,\n    [independentTokenField]:\n      tokenOut && independentTokenAmount\n        ? TokenAmount.fromRawAmount(tokenOut, independentTokenAmount.quotient)\n        : undefined,\n    [dependentTokenField]:\n      tokenIn && dependentTokenAmount ? TokenAmount.fromRawAmount(tokenIn, dependentTokenAmount.quotient) : undefined,\n  }\n\n  const amountsMin = {\n    [Field.CURRENCY_A]:\n      parsedAmounts && parsedAmounts[Field.CURRENCY_A]\n        ? calculateSlippageAmount(parsedAmounts[Field.CURRENCY_A] as CurrencyAmount<Currency>, allowedSlippage)[0]\n        : JSBI.BigInt(0),\n    [Field.CURRENCY_B]:\n      parsedAmounts && parsedAmounts[Field.CURRENCY_B]\n        ? calculateSlippageAmount(parsedAmounts[Field.CURRENCY_B] as CurrencyAmount<Currency>, allowedSlippage)[0]\n        : JSBI.BigInt(0),\n  }\n\n  const price = useMemo(() => {\n    const wrappedCurrencyA = currencyA?.wrapped\n    return pair && wrappedCurrencyA ? pair.priceOf(wrappedCurrencyA) : undefined\n  }, [currencyA, pair])\n\n  if (!account) {\n    error = t`Connect wallet`\n  }\n\n  if (!typedValue && !parsedAmounts[Field.LIQUIDITY]) {\n    error = error ?? t`Enter an amount`\n  }\n\n  if (typedValue && !parsedAmounts[Field.LIQUIDITY]) {\n    error = error ?? t`Invalid amount`\n  }\n\n  if (userLiquidity && parsedAmounts[Field.LIQUIDITY]?.greaterThan(userLiquidity)) {\n    error = error ?? t`Insufficient balance`\n  }\n\n  if (\n    zapOutAmount.error &&\n    (zapOutAmount.error.message?.includes('INSUFFICIENT_LIQUIDITY') ||\n      zapOutAmount.error.data?.message?.includes('INSUFFICIENT_LIQUIDITY'))\n  ) {\n    insufficientLiquidity = true\n  }\n\n  if (zapOutAmount.error && !insufficientLiquidity) {\n    console.error(zapOutAmount.error)\n    error = t`Something went wrong`\n  }\n\n  return {\n    dependentTokenField,\n    currencies,\n    pair,\n    userLiquidity,\n    noZapAmounts,\n    parsedAmounts,\n    amountsMin,\n    insufficientLiquidity,\n    price,\n    error,\n    isStaticFeePair,\n    isOldStaticFeeContract,\n  }\n}\n\nexport function useZapOutActionHandlers(): {\n  onUserInput: (field: Field, typedValue: string) => void\n  onSwitchField: () => void\n} {\n  const dispatch = useAppDispatch()\n  const { independentTokenField } = useBurnState()\n\n  const onUserInput = useCallback(\n    (field: Field, typedValue: string) => {\n      dispatch(typeInput({ field, typedValue }))\n    },\n    [dispatch],\n  )\n\n  const onSwitchField = useCallback(() => {\n    dispatch(\n      switchTokenField({ field: independentTokenField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A }),\n    )\n  }, [dispatch, independentTokenField])\n\n  return {\n    onUserInput,\n    onSwitchField,\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}