{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethUtil = require(\"ethereumjs-util\");\n\nvar _ = require(\"lodash\");\n\nvar constants_1 = require(\"../utils/constants\");\n\nvar pointer_1 = require(\"./blocks/pointer\");\n\nvar set_1 = require(\"./blocks/set\");\n\nvar iterator_1 = require(\"./iterator\");\n\nvar Calldata =\n/** @class */\nfunction () {\n  function Calldata(rules) {\n    this._rules = rules;\n    this._selector = '';\n    this._root = undefined;\n  }\n  /**\n   * Sets the root calldata block. This block usually corresponds to a Method.\n   */\n\n\n  Calldata.prototype.setRoot = function (block) {\n    this._root = block;\n  };\n  /**\n   * Sets the selector to be prepended onto the calldata.\n   * If the root block was created by a Method then a selector will likely be set.\n   */\n\n\n  Calldata.prototype.setSelector = function (selector) {\n    if (!_.startsWith(selector, '0x')) {\n      throw new Error(\"Expected selector to be hex. Missing prefix '0x'\");\n    } else if (selector.length !== constants_1.constants.HEX_SELECTOR_LENGTH_IN_CHARS) {\n      throw new Error(\"Invalid selector '\" + selector + \"'\");\n    }\n\n    this._selector = selector;\n  };\n  /**\n   * Iterates through the calldata blocks, starting from the root block, to construct calldata as a hex string.\n   * If the `optimize` flag is set then this calldata will be condensed, to save gas.\n   * If the `annotate` flag is set then this will return human-readable calldata.\n   * If the `annotate` flag is *not* set then this will return EVM-compatible calldata.\n   */\n\n\n  Calldata.prototype.toString = function () {\n    var e_1, _a; // Sanity check: root block must be set\n\n\n    if (this._root === undefined) {\n      throw new Error('expected root');\n    } // Optimize, if flag set\n\n\n    if (this._rules.shouldOptimize) {\n      this._optimize();\n    } // Set offsets\n\n\n    var iterator = new iterator_1.CalldataIterator(this._root);\n    var offset = 0;\n\n    try {\n      for (var iterator_2 = __values(iterator), iterator_2_1 = iterator_2.next(); !iterator_2_1.done; iterator_2_1 = iterator_2.next()) {\n        var block = iterator_2_1.value;\n        block.setOffset(offset);\n        offset += block.getSizeInBytes();\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (iterator_2_1 && !iterator_2_1.done && (_a = iterator_2.return)) _a.call(iterator_2);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    } // Generate hex string\n\n\n    var hexString = this._rules.shouldAnnotate ? this._toHumanReadableCallData() : this._toEvmCompatibeCallDataHex();\n    return hexString;\n  };\n  /**\n   * There are three types of calldata blocks: Blob, Set and Pointer.\n   * Scenarios arise where distinct pointers resolve to identical values.\n   * We optimize by keeping only one such instance of the identical value, and redirecting all pointers here.\n   * We keep the last such duplicate value because pointers can only be positive (they cannot point backwards).\n   *\n   * Example #1:\n   *  function f(string[], string[])\n   *  f([\"foo\", \"bar\", \"blitz\"], [\"foo\", \"bar\", \"blitz\"])\n   *  The array [\"foo\", \"bar\", \"blitz\"] will only be included in the calldata once.\n   *\n   * Example #2:\n   *  function f(string[], string)\n   *  f([\"foo\", \"bar\", \"blitz\"], \"foo\")\n   *  The string \"foo\" will only be included in the calldata once.\n   *\n   * Example #3:\n   *  function f((string, uint, bytes), string, uint, bytes)\n   *  f((\"foo\", 5, \"0x05\"), \"foo\", 5, \"0x05\")\n   *  The string \"foo\" and bytes \"0x05\" will only be included in the calldata once.\n   *  The duplicate `uint 5` values cannot be optimized out because they are static values (no pointer points to them).\n   *\n   * @TODO #1:\n   *   This optimization strategy handles blocks that are exact duplicates of one another.\n   *   But what if some block is a combination of two other blocks? Or a subset of another block?\n   *   This optimization problem is not much different from the current implemetation.\n   *   Instead of tracking \"observed\" hashes, at each node we would simply do pattern-matching on the calldata.\n   *   This strategy would be applied after assigning offsets to the tree, rather than before (as in this strategy).\n   *   Note that one consequence of this strategy is pointers may resolve to offsets that are not word-aligned.\n   *   This shouldn't be a problem but further investigation should be done.\n   *\n   * @TODO #2:\n   *   To be done as a follow-up to @TODO #1.\n   *   Since we optimize from the bottom-up, we could be affecting the outcome of a later potential optimization.\n   *   For example, what if by removing one duplicate value we miss out on optimizing another block higher in the tree.\n   *   To handle this case, at each node we can store a candidate optimization in a priority queue (sorted by calldata size).\n   *   At the end of traversing the tree, the candidate at the front of the queue will be the most optimal output.\n   *\n   */\n\n\n  Calldata.prototype._optimize = function () {\n    var e_2, _a; // Step 1/1 Create a reverse iterator (starts from the end of the calldata to the beginning)\n\n\n    if (this._root === undefined) {\n      throw new Error('expected root');\n    }\n\n    var iterator = new iterator_1.ReverseCalldataIterator(this._root); // Step 2/2 Iterate over each block, keeping track of which blocks have been seen and pruning redundant blocks.\n\n    var blocksByHash = {};\n\n    try {\n      for (var iterator_3 = __values(iterator), iterator_3_1 = iterator_3.next(); !iterator_3_1.done; iterator_3_1 = iterator_3.next()) {\n        var block = iterator_3_1.value; // If a block is a pointer and its value has already been observed, then update\n        // the pointer to resolve to the existing value.\n\n        if (block instanceof pointer_1.PointerCalldataBlock) {\n          var dependencyBlockHashBuf = block.getDependency().computeHash();\n          var dependencyBlockHash = ethUtil.bufferToHex(dependencyBlockHashBuf);\n\n          if (dependencyBlockHash in blocksByHash) {\n            var blockWithSameHash = blocksByHash[dependencyBlockHash];\n\n            if (blockWithSameHash !== block.getDependency()) {\n              block.setAlias(blockWithSameHash);\n            }\n          }\n\n          continue;\n        } // This block has not been seen. Record its hash.\n\n\n        var blockHashBuf = block.computeHash();\n        var blockHash = ethUtil.bufferToHex(blockHashBuf);\n\n        if (!(blockHash in blocksByHash)) {\n          blocksByHash[blockHash] = block;\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (iterator_3_1 && !iterator_3_1.done && (_a = iterator_3.return)) _a.call(iterator_3);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n  };\n\n  Calldata.prototype._toEvmCompatibeCallDataHex = function () {\n    var e_3, _a; // Sanity check: must have a root block.\n\n\n    if (this._root === undefined) {\n      throw new Error('expected root');\n    } // Construct an array of buffers (one buffer for each block).\n\n\n    var selectorBuffer = ethUtil.toBuffer(this._selector);\n    var valueBufs = [selectorBuffer];\n    var iterator = new iterator_1.CalldataIterator(this._root);\n\n    try {\n      for (var iterator_4 = __values(iterator), iterator_4_1 = iterator_4.next(); !iterator_4_1.done; iterator_4_1 = iterator_4.next()) {\n        var block = iterator_4_1.value;\n        valueBufs.push(block.toBuffer());\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (iterator_4_1 && !iterator_4_1.done && (_a = iterator_4.return)) _a.call(iterator_4);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    } // Create hex from buffer array.\n\n\n    var combinedBuffers = Buffer.concat(valueBufs);\n    var hexValue = ethUtil.bufferToHex(combinedBuffers);\n    return hexValue;\n  };\n  /**\n   * Returns human-readable calldata.\n   *\n   * Example:\n   *   simpleFunction(string[], string[])\n   *   strings = [\"Hello\", \"World\"]\n   *   simpleFunction(strings, strings)\n   *\n   * Output:\n   *   0xbb4f12e3\n   *                                                                                      ### simpleFunction\n   *   0x0       0000000000000000000000000000000000000000000000000000000000000040              ptr<array1> (alias for array2)\n   *   0x20      0000000000000000000000000000000000000000000000000000000000000040              ptr<array2>\n   *\n   *   0x40      0000000000000000000000000000000000000000000000000000000000000002          ### array2\n   *   0x60      0000000000000000000000000000000000000000000000000000000000000040              ptr<array2[0]>\n   *   0x80      0000000000000000000000000000000000000000000000000000000000000080              ptr<array2[1]>\n   *   0xa0      0000000000000000000000000000000000000000000000000000000000000005              array2[0]\n   *   0xc0      48656c6c6f000000000000000000000000000000000000000000000000000000\n   *   0xe0      0000000000000000000000000000000000000000000000000000000000000005              array2[1]\n   *   0x100     576f726c64000000000000000000000000000000000000000000000000000000\n   */\n\n\n  Calldata.prototype._toHumanReadableCallData = function () {\n    var e_4, _a; // Sanity check: must have a root block.\n\n\n    if (this._root === undefined) {\n      throw new Error('expected root');\n    } // Constants for constructing annotated string\n\n\n    var offsetPadding = 10;\n    var valuePadding = 74;\n    var namePadding = 80;\n    var evmWordStartIndex = 0;\n    var emptySize = 0; // Construct annotated calldata\n\n    var hexValue = \"\" + this._selector;\n    var offset = 0;\n\n    var functionName = this._root.getName();\n\n    var iterator = new iterator_1.CalldataIterator(this._root);\n\n    try {\n      for (var iterator_5 = __values(iterator), iterator_5_1 = iterator_5.next(); !iterator_5_1.done; iterator_5_1 = iterator_5.next()) {\n        var block = iterator_5_1.value; // Process each block 1 word at a time\n\n        var size = block.getSizeInBytes();\n        var name_1 = block.getName();\n        var parentName = block.getParentName();\n        var prettyName = name_1.replace(parentName + \".\", '').replace(functionName + \".\", ''); // Resulting line will be <offsetStr><valueStr><nameStr>\n\n        var offsetStr = '';\n        var valueStr = '';\n        var nameStr = '';\n        var lineStr = '';\n\n        if (size === emptySize) {\n          // This is a Set block with no header.\n          // For example, a tuple or an array with a defined length.\n          offsetStr = ' '.repeat(offsetPadding);\n          valueStr = ' '.repeat(valuePadding);\n          nameStr = \"### \" + prettyName.padEnd(namePadding);\n          lineStr = \"\\n\" + offsetStr + valueStr + nameStr;\n        } else {\n          // This block has at least one word of value.\n          offsetStr = (\"0x\" + offset.toString(constants_1.constants.HEX_BASE)).padEnd(offsetPadding);\n          valueStr = ethUtil.stripHexPrefix(ethUtil.bufferToHex(block.toBuffer().slice(evmWordStartIndex, constants_1.constants.EVM_WORD_WIDTH_IN_BYTES))).padEnd(valuePadding);\n\n          if (block instanceof set_1.SetCalldataBlock) {\n            nameStr = \"### \" + prettyName.padEnd(namePadding);\n            lineStr = \"\\n\" + offsetStr + valueStr + nameStr;\n          } else {\n            nameStr = \"    \" + prettyName.padEnd(namePadding);\n            lineStr = \"\" + offsetStr + valueStr + nameStr;\n          }\n        } // This block has a value that is more than 1 word.\n\n\n        for (var j = constants_1.constants.EVM_WORD_WIDTH_IN_BYTES; j < size; j += constants_1.constants.EVM_WORD_WIDTH_IN_BYTES) {\n          offsetStr = (\"0x\" + (offset + j).toString(constants_1.constants.HEX_BASE)).padEnd(offsetPadding);\n          valueStr = ethUtil.stripHexPrefix(ethUtil.bufferToHex(block.toBuffer().slice(j, j + constants_1.constants.EVM_WORD_WIDTH_IN_BYTES))).padEnd(valuePadding);\n          nameStr = ' '.repeat(namePadding);\n          lineStr = lineStr + \"\\n\" + offsetStr + valueStr + nameStr;\n        } // Append to hex value\n\n\n        hexValue = hexValue + \"\\n\" + lineStr;\n        offset += size;\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (iterator_5_1 && !iterator_5_1.done && (_a = iterator_5.return)) _a.call(iterator_5);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n\n    return hexValue;\n  };\n\n  return Calldata;\n}();\n\nexports.Calldata = Calldata;","map":null,"metadata":{},"sourceType":"script"}