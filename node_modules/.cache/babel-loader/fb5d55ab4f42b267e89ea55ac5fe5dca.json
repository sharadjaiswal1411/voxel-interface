{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$();\n\nimport { ChainId } from '@kyberswap/ks-sdk-core';\nimport { useEffect, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { EMPTY_ARRAY } from 'constants/index';\nimport { useActiveWeb3React } from '../../hooks';\nimport { useBlockNumber } from '../application/hooks';\nimport { addMulticallListeners, parseCallKey, removeMulticallListeners, toCallKey } from './actions';\n\nfunction isMethodArg(x) {\n  return ['string', 'number'].indexOf(typeof x) !== -1;\n}\n\nfunction isValidMethodArgs(x) {\n  return x === undefined || Array.isArray(x) && x.every(function (xi) {\n    return isMethodArg(xi) || Array.isArray(xi) && xi.every(isMethodArg);\n  });\n}\n\nvar INVALID_RESULT = {\n  valid: false,\n  blockNumber: undefined,\n  data: undefined\n}; // use this options object\n\nexport var NEVER_RELOAD = {\n  blocksPerFetch: Infinity\n}; // the lowest level call for subscribing to contract data\n\nfunction useCallsData(calls, options) {\n  _s();\n\n  var _useActiveWeb3React = useActiveWeb3React(),\n      chainId = _useActiveWeb3React.chainId;\n\n  var callResults = useSelector(function (state) {\n    var _state$multicall$call;\n\n    return (_state$multicall$call = state.multicall.callResults) === null || _state$multicall$call === void 0 ? void 0 : _state$multicall$call[chainId || ChainId.MAINNET];\n  });\n  var dispatch = useDispatch();\n  var serializedCallKeys = useMemo(function () {\n    var _calls$filter$map$sor, _calls$filter, _calls$filter$map;\n\n    return JSON.stringify((_calls$filter$map$sor = calls === null || calls === void 0 ? void 0 : (_calls$filter = calls.filter(function (c) {\n      return Boolean(c);\n    })) === null || _calls$filter === void 0 ? void 0 : (_calls$filter$map = _calls$filter.map(toCallKey)) === null || _calls$filter$map === void 0 ? void 0 : _calls$filter$map.sort()) !== null && _calls$filter$map$sor !== void 0 ? _calls$filter$map$sor : []);\n  }, [calls]); // update listeners when there is an actual change that persists for at least 100ms\n\n  useEffect(function () {\n    var callKeys = JSON.parse(serializedCallKeys);\n    if (!chainId || callKeys.length === 0) return undefined;\n    var calls = callKeys.map(function (key) {\n      return parseCallKey(key);\n    });\n    dispatch(addMulticallListeners({\n      chainId: chainId,\n      calls: calls,\n      options: options\n    }));\n    return function () {\n      dispatch(removeMulticallListeners({\n        chainId: chainId,\n        calls: calls,\n        options: options\n      }));\n    };\n  }, [chainId, dispatch, options, serializedCallKeys]);\n  return useMemo(function () {\n    return calls.length ? calls.map(function (call) {\n      if (!chainId || !call) return INVALID_RESULT;\n      var result = callResults === null || callResults === void 0 ? void 0 : callResults[toCallKey(call)];\n      var data;\n\n      if (result !== null && result !== void 0 && result.data && (result === null || result === void 0 ? void 0 : result.data) !== '0x') {\n        data = result.data;\n      }\n\n      return {\n        valid: true,\n        data: data,\n        blockNumber: result === null || result === void 0 ? void 0 : result.blockNumber\n      };\n    }) : EMPTY_ARRAY;\n  }, [callResults, calls, chainId]);\n}\n\n_s(useCallsData, \"wfAl8Ey0eVorbPIKvJVE0ZbvRK4=\", false, function () {\n  return [useActiveWeb3React, useSelector, useDispatch];\n});\n\nvar INVALID_CALL_STATE = {\n  valid: false,\n  result: undefined,\n  loading: false,\n  syncing: false,\n  error: false\n};\nvar LOADING_CALL_STATE = {\n  valid: true,\n  result: undefined,\n  loading: true,\n  syncing: true,\n  error: false\n};\n\nfunction toCallState(callResult, contractInterface, fragment, latestBlockNumber) {\n  if (!callResult) return INVALID_CALL_STATE;\n  var valid = callResult.valid,\n      data = callResult.data,\n      blockNumber = callResult.blockNumber;\n  if (!valid) return INVALID_CALL_STATE;\n  if (valid && !blockNumber) return LOADING_CALL_STATE;\n  if (!contractInterface || !fragment || !latestBlockNumber) return LOADING_CALL_STATE;\n  var success = data && data.length > 2;\n  var syncing = (blockNumber !== null && blockNumber !== void 0 ? blockNumber : 0) < latestBlockNumber;\n  var result = undefined;\n\n  if (success && data) {\n    try {\n      result = contractInterface.decodeFunctionResult(fragment, data);\n    } catch (error) {\n      console.debug('Result data parsing failed', fragment, data);\n      return {\n        valid: true,\n        loading: false,\n        error: true,\n        syncing: syncing,\n        result: result\n      };\n    }\n  }\n\n  return {\n    valid: true,\n    loading: false,\n    syncing: syncing,\n    result: result,\n    error: !success\n  };\n}\n\nexport function useSingleContractMultipleData(contract, methodName, callInputs, options) {\n  _s2();\n\n  var fragment = useMemo(function () {\n    var _contract$interface;\n\n    return contract === null || contract === void 0 ? void 0 : (_contract$interface = contract.interface) === null || _contract$interface === void 0 ? void 0 : _contract$interface.getFunction(methodName);\n  }, [contract, methodName]);\n\n  var _useMemo = useMemo(function () {\n    return options !== null && options !== void 0 ? options : {};\n  }, [options]),\n      gasRequired = _useMemo.gasRequired;\n\n  var calls = useMemo(function () {\n    return contract && fragment && callInputs && callInputs.length > 0 ? callInputs.map(function (inputs) {\n      return {\n        address: contract.address,\n        callData: contract.interface.encodeFunctionData(fragment, inputs),\n        gasRequired: gasRequired\n      };\n    }) : EMPTY_ARRAY;\n  }, [callInputs, contract, fragment, gasRequired]);\n  var results = useCallsData(calls, options);\n  var latestBlockNumber = useBlockNumber();\n  return useMemo(function () {\n    return results.map(function (result) {\n      return toCallState(result, contract === null || contract === void 0 ? void 0 : contract.interface, fragment, latestBlockNumber);\n    });\n  }, [fragment, contract, results, latestBlockNumber]);\n}\n\n_s2(useSingleContractMultipleData, \"YGy5343ffT+ofIczuRm3u0iMjoI=\", false, function () {\n  return [useCallsData, useBlockNumber];\n});\n\nexport function useSingleContractWithCallData(contract, callDatas, options) {\n  _s3();\n\n  var _ref = options !== null && options !== void 0 ? options : {},\n      gasRequired = _ref.gasRequired;\n\n  var calls = useMemo(function () {\n    return contract && callDatas && callDatas.length > 0 ? callDatas.map(function (callData) {\n      return {\n        address: contract.address,\n        callData: callData,\n        gasRequired: gasRequired\n      };\n    }) : EMPTY_ARRAY;\n  }, [callDatas, contract, gasRequired]);\n  var results = useCallsData(calls, options);\n  var latestBlockNumber = useBlockNumber();\n  return useMemo(function () {\n    return results.map(function (result, i) {\n      var _contract$interface2;\n\n      return toCallState(result, contract === null || contract === void 0 ? void 0 : contract.interface, contract === null || contract === void 0 ? void 0 : (_contract$interface2 = contract.interface) === null || _contract$interface2 === void 0 ? void 0 : _contract$interface2.getFunction(callDatas[i].substring(0, 10)), latestBlockNumber);\n    });\n  }, [contract, results, latestBlockNumber, callDatas]);\n}\n\n_s3(useSingleContractWithCallData, \"HYpM6QoPXgb4gu76hrEQp646A9E=\", false, function () {\n  return [useCallsData, useBlockNumber];\n});\n\nexport function useMultipleContractSingleData(addresses, contractInterface, methodName, callInputs, options) {\n  _s4();\n\n  var fragment = useMemo(function () {\n    return contractInterface.getFunction(methodName);\n  }, [contractInterface, methodName]);\n  var callData = useMemo(function () {\n    return fragment && isValidMethodArgs(callInputs) ? contractInterface.encodeFunctionData(fragment, callInputs) : undefined;\n  }, [callInputs, contractInterface, fragment]);\n\n  var _useMemo2 = useMemo(function () {\n    return options !== null && options !== void 0 ? options : {};\n  }, [options]),\n      gasRequired = _useMemo2.gasRequired;\n\n  var calls = useMemo(function () {\n    return fragment && addresses && addresses.length > 0 && callData ? addresses.map(function (address) {\n      return address && callData ? {\n        address: address,\n        callData: callData,\n        gasRequired: gasRequired\n      } : undefined;\n    }) : EMPTY_ARRAY;\n  }, [addresses, callData, fragment, gasRequired]);\n  var results = useCallsData(calls, options);\n  var latestBlockNumber = useBlockNumber();\n  return useMemo(function () {\n    return results.map(function (result) {\n      return toCallState(result, contractInterface, fragment, latestBlockNumber);\n    });\n  }, [fragment, results, contractInterface, latestBlockNumber]);\n}\n\n_s4(useMultipleContractSingleData, \"Y47cBIBExcDxWMySLpWEbVV5V7M=\", false, function () {\n  return [useCallsData, useBlockNumber];\n});\n\nexport function useSingleCallResult(contract, methodName, inputs, options) {\n  _s5();\n\n  var fragment = useMemo(function () {\n    var _contract$interface3;\n\n    return contract === null || contract === void 0 ? void 0 : (_contract$interface3 = contract.interface) === null || _contract$interface3 === void 0 ? void 0 : _contract$interface3.getFunction(methodName);\n  }, [contract, methodName]);\n\n  var _ref2 = options !== null && options !== void 0 ? options : {},\n      gasRequired = _ref2.gasRequired;\n\n  var calls = useMemo(function () {\n    return contract && fragment && isValidMethodArgs(inputs) ? [{\n      address: contract.address,\n      callData: contract.interface.encodeFunctionData(fragment, inputs),\n      gasRequired: gasRequired\n    }] : EMPTY_ARRAY;\n  }, [contract, fragment, inputs, gasRequired]);\n\n  var _ref3 = useCallsData(calls, options)[0] || {},\n      valid = _ref3.valid,\n      data = _ref3.data,\n      blockNumber = _ref3.blockNumber;\n\n  var latestBlockNumber = useBlockNumber();\n  return useMemo(function () {\n    return toCallState({\n      valid: valid,\n      data: data,\n      blockNumber: blockNumber\n    }, contract === null || contract === void 0 ? void 0 : contract.interface, fragment, latestBlockNumber);\n  }, [valid, data, blockNumber, contract, fragment, latestBlockNumber]);\n}\n\n_s5(useSingleCallResult, \"w3FP0tU2v530x+kbmRIp+PuTg70=\", false, function () {\n  return [useCallsData, useBlockNumber];\n});","map":{"version":3,"names":["ChainId","useEffect","useMemo","useDispatch","useSelector","EMPTY_ARRAY","useActiveWeb3React","useBlockNumber","addMulticallListeners","parseCallKey","removeMulticallListeners","toCallKey","isMethodArg","x","indexOf","isValidMethodArgs","undefined","Array","isArray","every","xi","INVALID_RESULT","valid","blockNumber","data","NEVER_RELOAD","blocksPerFetch","Infinity","useCallsData","calls","options","chainId","callResults","state","multicall","MAINNET","dispatch","serializedCallKeys","JSON","stringify","filter","c","Boolean","map","sort","callKeys","parse","length","key","call","result","INVALID_CALL_STATE","loading","syncing","error","LOADING_CALL_STATE","toCallState","callResult","contractInterface","fragment","latestBlockNumber","success","decodeFunctionResult","console","debug","useSingleContractMultipleData","contract","methodName","callInputs","interface","getFunction","gasRequired","inputs","address","callData","encodeFunctionData","results","useSingleContractWithCallData","callDatas","i","substring","useMultipleContractSingleData","addresses","useSingleCallResult"],"sources":["/Applications/XAMPP/voxel-interface/src/state/multicall/hooks.ts"],"sourcesContent":["import { FunctionFragment, Interface } from '@ethersproject/abi'\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { Contract } from '@ethersproject/contracts'\nimport { ChainId } from '@kyberswap/ks-sdk-core'\nimport { useEffect, useMemo } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\n\nimport { EMPTY_ARRAY } from 'constants/index'\n\nimport { useActiveWeb3React } from '../../hooks'\nimport { useBlockNumber } from '../application/hooks'\nimport { AppDispatch, AppState } from '../index'\nimport {\n  Call,\n  ListenerOptions,\n  addMulticallListeners,\n  parseCallKey,\n  removeMulticallListeners,\n  toCallKey,\n} from './actions'\n\nexport interface Result extends ReadonlyArray<any> {\n  readonly [key: string]: any\n}\n\ntype MethodArg = string | number | BigNumber\ntype MethodArgs = Array<MethodArg | MethodArg[]>\n\ntype OptionalMethodInputs = Array<MethodArg | MethodArg[] | undefined> | undefined\n\nfunction isMethodArg(x: unknown): x is MethodArg {\n  return ['string', 'number'].indexOf(typeof x) !== -1\n}\n\nfunction isValidMethodArgs(x: unknown): x is MethodArgs | undefined {\n  return (\n    x === undefined ||\n    (Array.isArray(x) && x.every(xi => isMethodArg(xi) || (Array.isArray(xi) && xi.every(isMethodArg))))\n  )\n}\n\ninterface CallResult {\n  readonly valid: boolean\n  readonly data: string | undefined\n  readonly blockNumber: number | undefined\n}\n\nconst INVALID_RESULT: CallResult = { valid: false, blockNumber: undefined, data: undefined }\n\n// use this options object\nexport const NEVER_RELOAD: ListenerOptions = {\n  blocksPerFetch: Infinity,\n}\n\n// the lowest level call for subscribing to contract data\nfunction useCallsData(calls: (Call | undefined)[], options?: ListenerOptions): CallResult[] {\n  const { chainId } = useActiveWeb3React()\n  const callResults = useSelector<AppState, AppState['multicall']['callResults'][ChainId]>(\n    state => state.multicall.callResults?.[chainId || ChainId.MAINNET],\n  )\n  const dispatch = useDispatch<AppDispatch>()\n\n  const serializedCallKeys: string = useMemo(\n    () =>\n      JSON.stringify(\n        calls\n          ?.filter((c): c is Call => Boolean(c))\n          ?.map(toCallKey)\n          ?.sort() ?? [],\n      ),\n    [calls],\n  )\n\n  // update listeners when there is an actual change that persists for at least 100ms\n  useEffect(() => {\n    const callKeys: string[] = JSON.parse(serializedCallKeys)\n    if (!chainId || callKeys.length === 0) return undefined\n    const calls = callKeys.map(key => parseCallKey(key))\n\n    dispatch(\n      addMulticallListeners({\n        chainId,\n        calls,\n        options,\n      }),\n    )\n\n    return () => {\n      dispatch(\n        removeMulticallListeners({\n          chainId,\n          calls,\n          options,\n        }),\n      )\n    }\n  }, [chainId, dispatch, options, serializedCallKeys])\n\n  return useMemo(\n    () =>\n      calls.length\n        ? calls.map<CallResult>(call => {\n            if (!chainId || !call) return INVALID_RESULT\n\n            const result = callResults?.[toCallKey(call)]\n            let data\n            if (result?.data && result?.data !== '0x') {\n              data = result.data\n            }\n\n            return { valid: true, data, blockNumber: result?.blockNumber }\n          })\n        : EMPTY_ARRAY,\n    [callResults, calls, chainId],\n  )\n}\n\ninterface CallState {\n  readonly valid: boolean\n  // the result, or undefined if loading or errored/no data\n  readonly result: Result | undefined\n  // true if the result has never been fetched\n  readonly loading: boolean\n  // true if the result is not for the latest block\n  readonly syncing: boolean\n  // true if the call was made and is synced, but the return data is invalid\n  readonly error: boolean\n}\n\nconst INVALID_CALL_STATE: CallState = { valid: false, result: undefined, loading: false, syncing: false, error: false }\nconst LOADING_CALL_STATE: CallState = { valid: true, result: undefined, loading: true, syncing: true, error: false }\n\nfunction toCallState(\n  callResult: CallResult | undefined,\n  contractInterface: Interface | undefined,\n  fragment: FunctionFragment | undefined,\n  latestBlockNumber: number | undefined,\n): CallState {\n  if (!callResult) return INVALID_CALL_STATE\n  const { valid, data, blockNumber } = callResult\n  if (!valid) return INVALID_CALL_STATE\n  if (valid && !blockNumber) return LOADING_CALL_STATE\n  if (!contractInterface || !fragment || !latestBlockNumber) return LOADING_CALL_STATE\n  const success = data && data.length > 2\n  const syncing = (blockNumber ?? 0) < latestBlockNumber\n  let result: Result | undefined = undefined\n  if (success && data) {\n    try {\n      result = contractInterface.decodeFunctionResult(fragment, data)\n    } catch (error) {\n      console.debug('Result data parsing failed', fragment, data)\n      return {\n        valid: true,\n        loading: false,\n        error: true,\n        syncing,\n        result,\n      }\n    }\n  }\n  return {\n    valid: true,\n    loading: false,\n    syncing,\n    result: result,\n    error: !success,\n  }\n}\n\nexport function useSingleContractMultipleData(\n  contract: Contract | null | undefined,\n  methodName: string,\n  callInputs: OptionalMethodInputs[],\n  options?: ListenerOptions,\n): CallState[] {\n  const fragment = useMemo(() => contract?.interface?.getFunction(methodName), [contract, methodName])\n  const { gasRequired } = useMemo(() => options ?? {}, [options])\n  const calls = useMemo(\n    () =>\n      contract && fragment && callInputs && callInputs.length > 0\n        ? callInputs.map<Call>(inputs => {\n            return {\n              address: contract.address,\n              callData: contract.interface.encodeFunctionData(fragment, inputs),\n              gasRequired,\n            }\n          })\n        : EMPTY_ARRAY,\n    [callInputs, contract, fragment, gasRequired],\n  )\n\n  const results = useCallsData(calls, options)\n\n  const latestBlockNumber = useBlockNumber()\n\n  return useMemo(() => {\n    return results.map(result => toCallState(result, contract?.interface, fragment, latestBlockNumber))\n  }, [fragment, contract, results, latestBlockNumber])\n}\n\nexport function useSingleContractWithCallData(\n  contract: Contract | null | undefined,\n  callDatas: string[],\n  options?: ListenerOptions,\n): CallState[] {\n  const { gasRequired } = options ?? {}\n  const calls = useMemo(\n    () =>\n      contract && callDatas && callDatas.length > 0\n        ? callDatas.map<Call>(callData => {\n            return {\n              address: contract.address,\n              callData,\n              gasRequired,\n            }\n          })\n        : EMPTY_ARRAY,\n    [callDatas, contract, gasRequired],\n  )\n\n  const results = useCallsData(calls, options)\n\n  const latestBlockNumber = useBlockNumber()\n\n  return useMemo(() => {\n    return results.map((result, i) =>\n      toCallState(\n        result,\n        contract?.interface,\n        contract?.interface?.getFunction(callDatas[i].substring(0, 10)),\n        latestBlockNumber,\n      ),\n    )\n  }, [contract, results, latestBlockNumber, callDatas])\n}\n\nexport function useMultipleContractSingleData(\n  addresses: (string | undefined)[],\n  contractInterface: Interface,\n  methodName: string,\n  callInputs?: OptionalMethodInputs,\n  options?: ListenerOptions,\n): CallState[] {\n  const fragment = useMemo(() => contractInterface.getFunction(methodName), [contractInterface, methodName])\n\n  const callData: string | undefined = useMemo(\n    () =>\n      fragment && isValidMethodArgs(callInputs)\n        ? contractInterface.encodeFunctionData(fragment, callInputs)\n        : undefined,\n    [callInputs, contractInterface, fragment],\n  )\n  const { gasRequired } = useMemo(() => options ?? {}, [options])\n  const calls = useMemo(\n    () =>\n      fragment && addresses && addresses.length > 0 && callData\n        ? addresses.map<Call | undefined>(address => {\n            return address && callData\n              ? {\n                  address,\n                  callData,\n                  gasRequired,\n                }\n              : undefined\n          })\n        : EMPTY_ARRAY,\n    [addresses, callData, fragment, gasRequired],\n  )\n\n  const results = useCallsData(calls, options)\n\n  const latestBlockNumber = useBlockNumber()\n\n  return useMemo(() => {\n    return results.map(result => toCallState(result, contractInterface, fragment, latestBlockNumber))\n  }, [fragment, results, contractInterface, latestBlockNumber])\n}\n\nexport function useSingleCallResult(\n  contract: Contract | null | undefined,\n  methodName: string,\n  inputs?: OptionalMethodInputs,\n  options?: ListenerOptions,\n): CallState {\n  const fragment = useMemo(() => contract?.interface?.getFunction(methodName), [contract, methodName])\n  const { gasRequired } = options ?? {}\n  const calls = useMemo<Call[]>(() => {\n    return contract && fragment && isValidMethodArgs(inputs)\n      ? [\n          {\n            address: contract.address,\n            callData: contract.interface.encodeFunctionData(fragment, inputs),\n            gasRequired,\n          },\n        ]\n      : EMPTY_ARRAY\n  }, [contract, fragment, inputs, gasRequired])\n\n  const { valid, data, blockNumber } = useCallsData(calls, options)[0] || {}\n  const latestBlockNumber = useBlockNumber()\n\n  return useMemo(() => {\n    return toCallState({ valid, data, blockNumber }, contract?.interface, fragment, latestBlockNumber)\n  }, [valid, data, blockNumber, contract, fragment, latestBlockNumber])\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}