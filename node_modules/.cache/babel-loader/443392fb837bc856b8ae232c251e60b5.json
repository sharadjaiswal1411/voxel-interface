{"ast":null,"code":"import _regeneratorRuntime from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/**\n * Polyfill for the optional chain operator, `?.`, given previous conversion of the expression into an array of values,\n * descriptors, and functions, for situations in which at least one part of the expression is async.\n *\n * Adapted from Sucrase (https://github.com/alangpierce/sucrase) See\n * https://github.com/alangpierce/sucrase/blob/265887868966917f3b924ce38dfad01fbab1329f/src/transformers/OptionalChainingNullishTransformer.ts#L15\n *\n * @param ops Array result of expression conversion\n * @returns The value of the expression\n */\nfunction _asyncOptionalChain(_x) {\n  return _asyncOptionalChain2.apply(this, arguments);\n} // Sucrase version:\n// async function _asyncOptionalChain(ops) {\n//   let lastAccessLHS = undefined;\n//   let value = ops[0];\n//   let i = 1;\n//   while (i < ops.length) {\n//     var op = ops[i];\n//     var fn = ops[i + 1];\n//     i += 2;\n//     if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n//       return undefined;\n//     }\n//     if (op === 'access' || op === 'optionalAccess') {\n//       lastAccessLHS = value;\n//       value = await fn(value);\n//     } else if (op === 'call' || op === 'optionalCall') {\n//       value = await fn((...args) => value.call(lastAccessLHS, ...args));\n//       lastAccessLHS = undefined;\n//     }\n//   }\n//   return value;\n// }\n\n\nfunction _asyncOptionalChain2() {\n  _asyncOptionalChain2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(ops) {\n    var lastAccessLHS, value, i, op, fn;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            lastAccessLHS = undefined;\n            value = ops[0];\n            i = 1;\n\n          case 3:\n            if (!(i < ops.length)) {\n              _context.next = 23;\n              break;\n            }\n\n            op = ops[i];\n            fn = ops[i + 1];\n            i += 2; // by checking for loose equality to `null`, we catch both `null` and `undefined`\n\n            if (!((op === 'optionalAccess' || op === 'optionalCall') && value == null)) {\n              _context.next = 9;\n              break;\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 9:\n            if (!(op === 'access' || op === 'optionalAccess')) {\n              _context.next = 16;\n              break;\n            }\n\n            lastAccessLHS = value;\n            _context.next = 13;\n            return fn(value);\n\n          case 13:\n            value = _context.sent;\n            _context.next = 21;\n            break;\n\n          case 16:\n            if (!(op === 'call' || op === 'optionalCall')) {\n              _context.next = 21;\n              break;\n            }\n\n            _context.next = 19;\n            return fn(function () {\n              var _value;\n\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n\n              return (_value = value).call.apply(_value, [lastAccessLHS].concat(args));\n            });\n\n          case 19:\n            value = _context.sent;\n            lastAccessLHS = undefined;\n\n          case 21:\n            _context.next = 3;\n            break;\n\n          case 23:\n            return _context.abrupt(\"return\", value);\n\n          case 24:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _asyncOptionalChain2.apply(this, arguments);\n}\n\nexport { _asyncOptionalChain };","map":null,"metadata":{},"sourceType":"module"}