{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport { useState, useEffect, useRef, cloneElement } from 'react';\nimport { render } from 'react-universal-interface';\nimport useLatest from './useLatest';\n\nvar noop = function noop() {};\n\nvar useScratch = function useScratch(params) {\n  if (params === void 0) {\n    params = {};\n  }\n\n  var disabled = params.disabled;\n  var paramsRef = useLatest(params);\n\n  var _a = useState({\n    isScratching: false\n  }),\n      state = _a[0],\n      setState = _a[1];\n\n  var refState = useRef(state);\n  var refScratching = useRef(false);\n  var refAnimationFrame = useRef(null);\n\n  var _b = useState(null),\n      el = _b[0],\n      setEl = _b[1];\n\n  useEffect(function () {\n    if (disabled) return;\n    if (!el) return;\n\n    var onMoveEvent = function onMoveEvent(docX, docY) {\n      cancelAnimationFrame(refAnimationFrame.current);\n      refAnimationFrame.current = requestAnimationFrame(function () {\n        var _a = el.getBoundingClientRect(),\n            left = _a.left,\n            top = _a.top;\n\n        var elX = left + window.scrollX;\n        var elY = top + window.scrollY;\n        var x = docX - elX;\n        var y = docY - elY;\n        setState(function (oldState) {\n          var newState = __assign(__assign({}, oldState), {\n            dx: x - (oldState.x || 0),\n            dy: y - (oldState.y || 0),\n            end: Date.now(),\n            isScratching: true\n          });\n\n          refState.current = newState;\n          (paramsRef.current.onScratch || noop)(newState);\n          return newState;\n        });\n      });\n    };\n\n    var onMouseMove = function onMouseMove(event) {\n      onMoveEvent(event.pageX, event.pageY);\n    };\n\n    var onTouchMove = function onTouchMove(event) {\n      onMoveEvent(event.changedTouches[0].pageX, event.changedTouches[0].pageY);\n    };\n\n    var onMouseUp;\n    var onTouchEnd;\n\n    var stopScratching = function stopScratching() {\n      if (!refScratching.current) return;\n      refScratching.current = false;\n      refState.current = __assign(__assign({}, refState.current), {\n        isScratching: false\n      });\n      (paramsRef.current.onScratchEnd || noop)(refState.current);\n      setState({\n        isScratching: false\n      });\n      window.removeEventListener('mousemove', onMouseMove);\n      window.removeEventListener('touchmove', onTouchMove);\n      window.removeEventListener('mouseup', onMouseUp);\n      window.removeEventListener('touchend', onTouchEnd);\n    };\n\n    onMouseUp = stopScratching;\n    onTouchEnd = stopScratching;\n\n    var startScratching = function startScratching(docX, docY) {\n      if (!refScratching.current) return;\n\n      var _a = el.getBoundingClientRect(),\n          left = _a.left,\n          top = _a.top;\n\n      var elX = left + window.scrollX;\n      var elY = top + window.scrollY;\n      var x = docX - elX;\n      var y = docY - elY;\n      var time = Date.now();\n      var newState = {\n        isScratching: true,\n        start: time,\n        end: time,\n        docX: docX,\n        docY: docY,\n        x: x,\n        y: y,\n        dx: 0,\n        dy: 0,\n        elH: el.offsetHeight,\n        elW: el.offsetWidth,\n        elX: elX,\n        elY: elY\n      };\n      refState.current = newState;\n      (paramsRef.current.onScratchStart || noop)(newState);\n      setState(newState);\n      window.addEventListener('mousemove', onMouseMove);\n      window.addEventListener('touchmove', onTouchMove);\n      window.addEventListener('mouseup', onMouseUp);\n      window.addEventListener('touchend', onTouchEnd);\n    };\n\n    var onMouseDown = function onMouseDown(event) {\n      refScratching.current = true;\n      startScratching(event.pageX, event.pageY);\n    };\n\n    var onTouchStart = function onTouchStart(event) {\n      refScratching.current = true;\n      startScratching(event.changedTouches[0].pageX, event.changedTouches[0].pageY);\n    };\n\n    el.addEventListener('mousedown', onMouseDown);\n    el.addEventListener('touchstart', onTouchStart);\n    return function () {\n      el.removeEventListener('mousedown', onMouseDown);\n      el.removeEventListener('touchstart', onTouchStart);\n      window.removeEventListener('mousemove', onMouseMove);\n      window.removeEventListener('touchmove', onTouchMove);\n      window.removeEventListener('mouseup', onMouseUp);\n      window.removeEventListener('touchend', onTouchEnd);\n      if (refAnimationFrame.current) cancelAnimationFrame(refAnimationFrame.current);\n      refAnimationFrame.current = null;\n      refScratching.current = false;\n      refState.current = {\n        isScratching: false\n      };\n      setState(refState.current);\n    };\n  }, [el, disabled, paramsRef]);\n  return [setEl, state];\n};\n\nexport var ScratchSensor = function ScratchSensor(props) {\n  var children = props.children,\n      params = __rest(props, [\"children\"]);\n\n  var _a = useScratch(params),\n      _ref = _a[0],\n      state = _a[1];\n\n  var element = render(props, state);\n  return cloneElement(element, __assign(__assign({}, element.props), {\n    ref: function ref(el) {\n      if (element.props.ref) {\n        if (typeof element.props.ref === 'object') element.props.ref.current = el;\n        if (typeof element.props.ref === 'function') element.props.ref(el);\n      }\n\n      _ref(el);\n    }\n  }));\n};\nexport default useScratch;","map":null,"metadata":{},"sourceType":"module"}