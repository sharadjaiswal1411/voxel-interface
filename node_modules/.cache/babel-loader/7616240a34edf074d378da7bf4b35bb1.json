{"ast":null,"code":"import _defineProperty from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _slicedToArray from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n\nvar _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$();\n\nimport { i18n } from \"@lingui/core\";\nimport { parseUnits } from '@ethersproject/units';\nimport { CurrencyAmount } from '@kyberswap/ks-sdk-core';\nimport JSBI from 'jsbi';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { BAD_RECIPIENT_ADDRESSES, DEFAULT_OUTPUT_TOKEN_BY_CHAIN } from 'constants/index';\nimport { nativeOnChain } from 'constants/tokens';\nimport { useActiveWeb3React } from 'hooks';\nimport { useCurrency } from 'hooks/Tokens';\nimport { useTradeExactIn } from 'hooks/Trades';\nimport useENS from 'hooks/useENS';\nimport useParsedQueryString from 'hooks/useParsedQueryString';\nimport { Field, chooseToSaveGas, replaceSwapState, resetSelectCurrency, selectCurrency, setRecipient, setTrade, switchCurrencies, switchCurrenciesV2, typeInput } from 'state/swap/actions';\nimport { useExpertModeManager, useUserSlippageTolerance } from 'state/user/hooks';\nimport { useCurrencyBalances } from 'state/wallet/hooks';\nimport { isAddress } from 'utils';\nimport { computeSlippageAdjustedAmounts } from 'utils/prices';\nexport function useSwapState() {\n  _s();\n\n  return useSelector(function (state) {\n    return state.swap;\n  });\n}\n\n_s(useSwapState, \"nKHvd/QB6hocKEk0fSJoSYcCyR8=\", false, function () {\n  return [useSelector];\n});\n\nexport function useSwapActionHandlers() {\n  _s2();\n\n  var _useActiveWeb3React = useActiveWeb3React(),\n      chainId = _useActiveWeb3React.chainId;\n\n  var dispatch = useDispatch();\n  var onCurrencySelection = useCallback(function (field, currency) {\n    dispatch(selectCurrency({\n      field: field,\n      currencyId: currency.isNative ? nativeOnChain(chainId).symbol : currency.address\n    }));\n  }, [dispatch, chainId]);\n\n  var _useExpertModeManager = useExpertModeManager(),\n      _useExpertModeManager2 = _slicedToArray(_useExpertModeManager, 1),\n      expertMode = _useExpertModeManager2[0];\n\n  useEffect(function () {\n    if (expertMode) dispatch(setRecipient({\n      recipient: null\n    }));\n  }, [expertMode, dispatch]);\n  var onResetSelectCurrency = useCallback(function (field) {\n    dispatch(resetSelectCurrency({\n      field: field\n    }));\n  }, [dispatch]);\n  var onSwitchTokens = useCallback(function () {\n    dispatch(switchCurrencies());\n  }, [dispatch]);\n  var onSwitchTokensV2 = useCallback(function () {\n    dispatch(switchCurrenciesV2());\n  }, [dispatch]);\n  var onUserInput = useCallback(function (field, typedValue) {\n    dispatch(typeInput({\n      field: field,\n      typedValue: typedValue\n    }));\n  }, [dispatch]);\n  var onChangeRecipient = useCallback(function (recipient) {\n    dispatch(setRecipient({\n      recipient: recipient\n    }));\n  }, [dispatch]);\n  var onChooseToSaveGas = useCallback(function (saveGas) {\n    dispatch(chooseToSaveGas({\n      saveGas: saveGas\n    }));\n  }, [dispatch]);\n  var onChangeTrade = useCallback(function (trade) {\n    dispatch(setTrade({\n      trade: trade\n    }));\n  }, [dispatch]);\n  return {\n    onSwitchTokens: onSwitchTokens,\n    onSwitchTokensV2: onSwitchTokensV2,\n    onCurrencySelection: onCurrencySelection,\n    onUserInput: onUserInput,\n    onChangeRecipient: onChangeRecipient,\n    onChooseToSaveGas: onChooseToSaveGas,\n    onResetSelectCurrency: onResetSelectCurrency,\n    // deselect token in select input: (use cases: remove \"imported token\")\n    onChangeTrade: onChangeTrade\n  };\n} // try to parse a user entered amount for a given token\n\n_s2(useSwapActionHandlers, \"jakZfZs4m41AD5v+q2L0kkyHwLE=\", false, function () {\n  return [useActiveWeb3React, useDispatch, useExpertModeManager];\n});\n\nexport function tryParseAmount(value, currency) {\n  var shouldParse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  if (!value || !currency) {\n    return undefined;\n  }\n\n  try {\n    var typedValueParsed = shouldParse ? parseUnits(value, currency.decimals).toString() : value;\n\n    if (typedValueParsed !== '0') {\n      return CurrencyAmount.fromRawAmount(currency, JSBI.BigInt(typedValueParsed));\n    }\n  } catch (error) {\n    // should fail if the user specifies too many decimal places of precision (or maybe exceed max uint?)\n    console.debug(\"Failed to parse input amount: \\\"\".concat(value, \"\\\"\"), error);\n  } // necessary for all paths to return a value\n\n\n  return undefined;\n}\n/**\n * Returns true if any of the pairs or tokens in a trade have the given checksummed address\n * @param trade to check for the given address\n * @param checksummedAddress address to check in the pairs and tokens\n */\n\nfunction involvesAddress(trade, checksummedAddress) {\n  return trade.route.path.some(function (token) {\n    return token.address === checksummedAddress;\n  }) || trade.route.pairs.some(function (pair) {\n    return pair.liquidityToken.address === checksummedAddress;\n  });\n} // from the current swap inputs, compute the best trade and return it.\n\n\nexport function useDerivedSwapInfo() {\n  _s3();\n\n  var _ref, _currencyBalances;\n\n  var _useActiveWeb3React2 = useActiveWeb3React(),\n      account = _useActiveWeb3React2.account;\n\n  var _useSwapState = useSwapState(),\n      independentField = _useSwapState.independentField,\n      typedValue = _useSwapState.typedValue,\n      inputCurrencyId = _useSwapState[Field.INPUT].currencyId,\n      outputCurrencyId = _useSwapState[Field.OUTPUT].currencyId,\n      recipient = _useSwapState.recipient;\n\n  var inputCurrency = useCurrency(inputCurrencyId);\n  var outputCurrency = useCurrency(outputCurrencyId);\n  var recipientLookup = useENS(recipient !== null && recipient !== void 0 ? recipient : undefined);\n  var to = (_ref = recipient === null ? account : recipientLookup.address) !== null && _ref !== void 0 ? _ref : null;\n  var relevantTokenBalances = useCurrencyBalances(account !== null && account !== void 0 ? account : undefined, useMemo(function () {\n    return [inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined, outputCurrency !== null && outputCurrency !== void 0 ? outputCurrency : undefined];\n  }, [inputCurrency, outputCurrency]));\n  var isExactIn = useMemo(function () {\n    return independentField === Field.INPUT;\n  }, [independentField]);\n  var parsedAmount = useMemo(function () {\n    var _ref2;\n\n    return tryParseAmount(typedValue, (_ref2 = isExactIn ? inputCurrency : outputCurrency) !== null && _ref2 !== void 0 ? _ref2 : undefined);\n  }, [inputCurrency, isExactIn, outputCurrency, typedValue]);\n  var currencyAmountIn = useMemo(function () {\n    return isExactIn ? parsedAmount : undefined;\n  }, [isExactIn, parsedAmount]);\n  var currencyOut = useMemo(function () {\n    return outputCurrency !== null && outputCurrency !== void 0 ? outputCurrency : undefined;\n  }, [outputCurrency]);\n  var bestTradeExactIn = useTradeExactIn(currencyAmountIn, currencyOut);\n  var v2Trade = bestTradeExactIn;\n  var currencyBalances = (_currencyBalances = {}, _defineProperty(_currencyBalances, Field.INPUT, relevantTokenBalances[0]), _defineProperty(_currencyBalances, Field.OUTPUT, relevantTokenBalances[1]), _currencyBalances);\n  var currencies = useMemo(function () {\n    var _ref3;\n\n    return _ref3 = {}, _defineProperty(_ref3, Field.INPUT, inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined), _defineProperty(_ref3, Field.OUTPUT, outputCurrency !== null && outputCurrency !== void 0 ? outputCurrency : undefined), _ref3;\n  }, [inputCurrency, outputCurrency]);\n  var inputError;\n\n  if (!account) {\n    inputError =\n    /*i18n*/\n    i18n._(\"Connect wallet\");\n  }\n\n  if (!parsedAmount) {\n    var _inputError, _inputError2;\n\n    if (typedValue) inputError = (_inputError = inputError) !== null && _inputError !== void 0 ? _inputError :\n    /*i18n*/\n    i18n._(\"Invalid amount\");else inputError = (_inputError2 = inputError) !== null && _inputError2 !== void 0 ? _inputError2 :\n    /*i18n*/\n    i18n._(\"Enter an amount\");\n  }\n\n  if (!currencies[Field.INPUT] || !currencies[Field.OUTPUT]) {\n    var _inputError3;\n\n    inputError = (_inputError3 = inputError) !== null && _inputError3 !== void 0 ? _inputError3 :\n    /*i18n*/\n    i18n._(\"Select a token\");\n  }\n\n  var formattedTo = isAddress(to);\n\n  if (!to || !formattedTo) {\n    var _inputError4;\n\n    inputError = (_inputError4 = inputError) !== null && _inputError4 !== void 0 ? _inputError4 :\n    /*i18n*/\n    i18n._(\"Enter a recipient\");\n  } else {\n    if (BAD_RECIPIENT_ADDRESSES.indexOf(formattedTo) !== -1 || bestTradeExactIn && involvesAddress(bestTradeExactIn, formattedTo)) {\n      var _inputError5;\n\n      inputError = (_inputError5 = inputError) !== null && _inputError5 !== void 0 ? _inputError5 :\n      /*i18n*/\n      i18n._(\"Invalid recipient\");\n    }\n  }\n\n  var _useUserSlippageToler = useUserSlippageTolerance(),\n      _useUserSlippageToler2 = _slicedToArray(_useUserSlippageToler, 1),\n      allowedSlippage = _useUserSlippageToler2[0];\n\n  var slippageAdjustedAmounts = v2Trade && allowedSlippage && computeSlippageAdjustedAmounts(v2Trade, allowedSlippage); // compare input balance to max input based on version\n\n  var _ref4 = [currencyBalances[Field.INPUT], slippageAdjustedAmounts ? slippageAdjustedAmounts[Field.INPUT] : null],\n      balanceIn = _ref4[0],\n      amountIn = _ref4[1];\n\n  if (balanceIn && amountIn && balanceIn.lessThan(amountIn)) {\n    inputError =\n    /*i18n*/\n    i18n._(\"Insufficient {0} balance\", {\n      0: amountIn.currency.symbol\n    });\n  }\n\n  return {\n    currencies: currencies,\n    currencyBalances: currencyBalances,\n    parsedAmount: parsedAmount,\n    v2Trade: v2Trade !== null && v2Trade !== void 0 ? v2Trade : undefined,\n    inputError: inputError\n  };\n}\n\n_s3(useDerivedSwapInfo, \"9x3yw85qyAfzCFjp8yjgPBEFwn4=\", false, function () {\n  return [useActiveWeb3React, useSwapState, useCurrency, useCurrency, useENS, useCurrencyBalances, useTradeExactIn, useUserSlippageTolerance];\n});\n\nfunction parseCurrencyFromURLParameter(urlParam, chainId) {\n  var _nativeOnChain$symbol;\n\n  if (typeof urlParam === 'string') {\n    var valid = isAddress(urlParam);\n    if (valid) return valid;\n    return nativeOnChain(chainId).symbol;\n  }\n\n  return (_nativeOnChain$symbol = nativeOnChain(chainId).symbol) !== null && _nativeOnChain$symbol !== void 0 ? _nativeOnChain$symbol : '';\n}\n\nfunction parseTokenAmountURLParameter(urlParam) {\n  return typeof urlParam === 'string' && !isNaN(parseFloat(urlParam)) ? urlParam : '';\n}\n\nfunction parseIndependentFieldURLParameter(urlParam) {\n  return typeof urlParam === 'string' && urlParam.toLowerCase() === 'output' ? Field.OUTPUT : Field.INPUT;\n}\n\nvar ENS_NAME_REGEX = /^[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)?$/;\nvar ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;\n\nfunction validatedRecipient(recipient) {\n  if (typeof recipient !== 'string') return null;\n  var address = isAddress(recipient);\n  if (address) return address;\n  if (ENS_NAME_REGEX.test(recipient)) return recipient;\n  if (ADDRESS_REGEX.test(recipient)) return recipient;\n  return null;\n}\n\nexport function queryParametersToSwapState(parsedQs, chainId) {\n  var _parsedQs$fee_bip, _ref5;\n\n  var inputCurrency = parseCurrencyFromURLParameter(parsedQs.inputCurrency, chainId);\n  var outputCurrency = parseCurrencyFromURLParameter(parsedQs.outputCurrency, chainId);\n\n  if (inputCurrency === outputCurrency) {\n    if (typeof parsedQs.outputCurrency === 'string') {\n      inputCurrency = '';\n    } else {\n      outputCurrency = '';\n    }\n  }\n\n  var recipient = validatedRecipient(parsedQs.recipient);\n  var feePercent = parseInt((parsedQs === null || parsedQs === void 0 ? void 0 : (_parsedQs$fee_bip = parsedQs['fee_bip']) === null || _parsedQs$fee_bip === void 0 ? void 0 : _parsedQs$fee_bip.toString()) || '0');\n  var feeConfig = parsedQs.referral && isAddress(parsedQs.referral) && parsedQs['fee_bip'] && !isNaN(feePercent) ? {\n    chargeFeeBy: 'currency_in',\n    feeReceiver: parsedQs.referral.toString(),\n    isInBps: true,\n    feeAmount: feePercent < 1 ? '1' : feePercent > 10 ? '10' : feePercent.toString()\n  } : undefined;\n  return _ref5 = {}, _defineProperty(_ref5, Field.INPUT, {\n    currencyId: inputCurrency\n  }), _defineProperty(_ref5, Field.OUTPUT, {\n    currencyId: outputCurrency\n  }), _defineProperty(_ref5, \"typedValue\", parseTokenAmountURLParameter(parsedQs.exactAmount)), _defineProperty(_ref5, \"independentField\", parseIndependentFieldURLParameter(parsedQs.exactField)), _defineProperty(_ref5, \"recipient\", recipient), _defineProperty(_ref5, \"feeConfig\", feeConfig), _ref5;\n}\n\nvar getCurrencySymbolOrAddress = function getCurrencySymbolOrAddress(currency) {\n  if (!currency) return '';\n  return currency.isNative ? currency.symbol : currency.address;\n}; // updates the swap state to use the defaults for a given network\n\n\nexport var useDefaultsFromURLSearch = function useDefaultsFromURLSearch() {\n  _s4();\n\n  // TODO: this hook is called more than 100 times just on startup, need to check\n  var _useActiveWeb3React3 = useActiveWeb3React(),\n      chainId = _useActiveWeb3React3.chainId;\n\n  var dispatch = useDispatch(); // this is already memo-ed\n\n  var parsedQs = useParsedQueryString();\n\n  var _useState = useState(),\n      _useState2 = _slicedToArray(_useState, 2),\n      result = _useState2[0],\n      setResult = _useState2[1];\n\n  var _useDerivedSwapInfo = useDerivedSwapInfo(),\n      currencies = _useDerivedSwapInfo.currencies;\n\n  var currenciesRef = useRef(currencies);\n  currenciesRef.current = currencies;\n  useEffect(function () {\n    var _DEFAULT_OUTPUT_TOKEN;\n\n    if (!chainId) {\n      return;\n    }\n\n    var parsed = queryParametersToSwapState(parsedQs, chainId);\n    var outputCurrencyAddress = ((_DEFAULT_OUTPUT_TOKEN = DEFAULT_OUTPUT_TOKEN_BY_CHAIN[chainId]) === null || _DEFAULT_OUTPUT_TOKEN === void 0 ? void 0 : _DEFAULT_OUTPUT_TOKEN.address) || ''; // symbol or address of the input\n\n    var storedInputValue = getCurrencySymbolOrAddress(currenciesRef.current[Field.INPUT]);\n    var storedOutputValue = getCurrencySymbolOrAddress(currenciesRef.current[Field.OUTPUT]);\n    var parsedInputValue = parsed[Field.INPUT].currencyId; // default inputCurrency is the native token\n\n    var parsedOutputValue = parsed[Field.OUTPUT].currencyId || outputCurrencyAddress; // priority order\n    // 1. address on url (inputCurrency, outputCurrency)\n    // 2. previous currency (to not reset default pair when back to swap page)\n    // 3. default pair\n\n    var inputCurrencyId = parsedQs.inputCurrency ? parsedInputValue : storedInputValue || parsedInputValue;\n    var outputCurrencyId = parsedQs.outputCurrency ? parsedOutputValue : storedOutputValue || parsedOutputValue;\n    dispatch(replaceSwapState({\n      field: parsed.independentField,\n      inputCurrencyId: inputCurrencyId,\n      outputCurrencyId: outputCurrencyId,\n      recipient: parsed.recipient,\n      feeConfig: parsed.feeConfig\n    }));\n    setResult({\n      inputCurrencyId: inputCurrencyId,\n      outputCurrencyId: outputCurrencyId\n    }); // TODO: can not add `currencies` as dependency here because it will retrigger replaceSwapState => got some issue when we have in/outputCurrency on URL\n  }, [dispatch, chainId, parsedQs]);\n  return result;\n};\n\n_s4(useDefaultsFromURLSearch, \"8H0lMlXNMiDNs6uZVkzj2HxV7zQ=\", false, function () {\n  return [useActiveWeb3React, useDispatch, useParsedQueryString, useDerivedSwapInfo];\n});","map":{"version":3,"names":["parseUnits","CurrencyAmount","JSBI","useCallback","useEffect","useMemo","useRef","useState","useDispatch","useSelector","BAD_RECIPIENT_ADDRESSES","DEFAULT_OUTPUT_TOKEN_BY_CHAIN","nativeOnChain","useActiveWeb3React","useCurrency","useTradeExactIn","useENS","useParsedQueryString","Field","chooseToSaveGas","replaceSwapState","resetSelectCurrency","selectCurrency","setRecipient","setTrade","switchCurrencies","switchCurrenciesV2","typeInput","useExpertModeManager","useUserSlippageTolerance","useCurrencyBalances","isAddress","computeSlippageAdjustedAmounts","useSwapState","state","swap","useSwapActionHandlers","chainId","dispatch","onCurrencySelection","field","currency","currencyId","isNative","symbol","address","expertMode","recipient","onResetSelectCurrency","onSwitchTokens","onSwitchTokensV2","onUserInput","typedValue","onChangeRecipient","onChooseToSaveGas","saveGas","onChangeTrade","trade","tryParseAmount","value","shouldParse","undefined","typedValueParsed","decimals","toString","fromRawAmount","BigInt","error","console","debug","involvesAddress","checksummedAddress","route","path","some","token","pairs","pair","liquidityToken","useDerivedSwapInfo","account","independentField","inputCurrencyId","INPUT","outputCurrencyId","OUTPUT","inputCurrency","outputCurrency","recipientLookup","to","relevantTokenBalances","isExactIn","parsedAmount","currencyAmountIn","currencyOut","bestTradeExactIn","v2Trade","currencyBalances","currencies","inputError","formattedTo","indexOf","allowedSlippage","slippageAdjustedAmounts","balanceIn","amountIn","lessThan","parseCurrencyFromURLParameter","urlParam","valid","parseTokenAmountURLParameter","isNaN","parseFloat","parseIndependentFieldURLParameter","toLowerCase","ENS_NAME_REGEX","ADDRESS_REGEX","validatedRecipient","test","queryParametersToSwapState","parsedQs","feePercent","parseInt","feeConfig","referral","chargeFeeBy","feeReceiver","isInBps","feeAmount","exactAmount","exactField","getCurrencySymbolOrAddress","useDefaultsFromURLSearch","result","setResult","currenciesRef","current","parsed","outputCurrencyAddress","storedInputValue","storedOutputValue","parsedInputValue","parsedOutputValue"],"sources":["/Applications/XAMPP/voxel-interface/src/state/swap/hooks.ts"],"sourcesContent":["import { parseUnits } from '@ethersproject/units'\nimport { Trade } from '@kyberswap/ks-sdk-classic'\nimport { ChainId, Currency, CurrencyAmount, TradeType } from '@kyberswap/ks-sdk-core'\nimport { t } from '@lingui/macro'\nimport JSBI from 'jsbi'\nimport { ParsedQs } from 'qs'\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\n\nimport { BAD_RECIPIENT_ADDRESSES, DEFAULT_OUTPUT_TOKEN_BY_CHAIN } from 'constants/index'\nimport { nativeOnChain } from 'constants/tokens'\nimport { useActiveWeb3React } from 'hooks'\nimport { useCurrency } from 'hooks/Tokens'\nimport { useTradeExactIn } from 'hooks/Trades'\nimport useENS from 'hooks/useENS'\nimport useParsedQueryString from 'hooks/useParsedQueryString'\nimport { FeeConfig } from 'hooks/useSwapV2Callback'\nimport { AppDispatch, AppState } from 'state/index'\nimport {\n  Field,\n  chooseToSaveGas,\n  replaceSwapState,\n  resetSelectCurrency,\n  selectCurrency,\n  setRecipient,\n  setTrade,\n  switchCurrencies,\n  switchCurrenciesV2,\n  typeInput,\n} from 'state/swap/actions'\nimport { SwapState } from 'state/swap/reducer'\nimport { useExpertModeManager, useUserSlippageTolerance } from 'state/user/hooks'\nimport { useCurrencyBalances } from 'state/wallet/hooks'\nimport { isAddress } from 'utils'\nimport { Aggregator } from 'utils/aggregator'\nimport { computeSlippageAdjustedAmounts } from 'utils/prices'\n\nexport function useSwapState(): AppState['swap'] {\n  return useSelector<AppState, AppState['swap']>(state => state.swap)\n}\n\nexport function useSwapActionHandlers(): {\n  onCurrencySelection: (field: Field, currency: Currency) => void\n  onSwitchTokens: () => void\n  onSwitchTokensV2: () => void\n  onUserInput: (field: Field, typedValue: string) => void\n  onChangeRecipient: (recipient: string | null) => void\n  onChooseToSaveGas: (saveGas: boolean) => void\n  onResetSelectCurrency: (field: Field) => void\n  onChangeTrade: (trade: Aggregator | undefined) => void\n} {\n  const { chainId } = useActiveWeb3React()\n  const dispatch = useDispatch<AppDispatch>()\n\n  const onCurrencySelection = useCallback(\n    (field: Field, currency: Currency) => {\n      dispatch(\n        selectCurrency({\n          field,\n          currencyId: currency.isNative ? (nativeOnChain(chainId as number).symbol as string) : currency.address,\n        }),\n      )\n    },\n    [dispatch, chainId],\n  )\n  const [expertMode] = useExpertModeManager()\n\n  useEffect(() => {\n    if (expertMode) dispatch(setRecipient({ recipient: null }))\n  }, [expertMode, dispatch])\n\n  const onResetSelectCurrency = useCallback(\n    (field: Field) => {\n      dispatch(\n        resetSelectCurrency({\n          field,\n        }),\n      )\n    },\n    [dispatch],\n  )\n\n  const onSwitchTokens = useCallback(() => {\n    dispatch(switchCurrencies())\n  }, [dispatch])\n\n  const onSwitchTokensV2 = useCallback(() => {\n    dispatch(switchCurrenciesV2())\n  }, [dispatch])\n\n  const onUserInput = useCallback(\n    (field: Field, typedValue: string) => {\n      dispatch(typeInput({ field, typedValue }))\n    },\n    [dispatch],\n  )\n\n  const onChangeRecipient = useCallback(\n    (recipient: string | null) => {\n      dispatch(setRecipient({ recipient }))\n    },\n    [dispatch],\n  )\n\n  const onChooseToSaveGas = useCallback(\n    (saveGas: boolean) => {\n      dispatch(chooseToSaveGas({ saveGas }))\n    },\n    [dispatch],\n  )\n\n  const onChangeTrade = useCallback(\n    (trade: Aggregator | undefined) => {\n      dispatch(setTrade({ trade }))\n    },\n    [dispatch],\n  )\n\n  return {\n    onSwitchTokens,\n    onSwitchTokensV2,\n    onCurrencySelection,\n    onUserInput,\n    onChangeRecipient,\n    onChooseToSaveGas,\n    onResetSelectCurrency, // deselect token in select input: (use cases: remove \"imported token\")\n    onChangeTrade,\n  }\n}\n\n// try to parse a user entered amount for a given token\nexport function tryParseAmount<T extends Currency>(\n  value?: string,\n  currency?: T,\n  shouldParse = true,\n): CurrencyAmount<T> | undefined {\n  if (!value || !currency) {\n    return undefined\n  }\n  try {\n    const typedValueParsed = shouldParse ? parseUnits(value, currency.decimals).toString() : value\n    if (typedValueParsed !== '0') {\n      return CurrencyAmount.fromRawAmount(currency, JSBI.BigInt(typedValueParsed))\n    }\n  } catch (error) {\n    // should fail if the user specifies too many decimal places of precision (or maybe exceed max uint?)\n    console.debug(`Failed to parse input amount: \"${value}\"`, error)\n  }\n  // necessary for all paths to return a value\n  return undefined\n}\n\n/**\n * Returns true if any of the pairs or tokens in a trade have the given checksummed address\n * @param trade to check for the given address\n * @param checksummedAddress address to check in the pairs and tokens\n */\nfunction involvesAddress(trade: Trade<Currency, Currency, TradeType>, checksummedAddress: string): boolean {\n  return (\n    trade.route.path.some(token => token.address === checksummedAddress) ||\n    trade.route.pairs.some(pair => pair.liquidityToken.address === checksummedAddress)\n  )\n}\n\n// from the current swap inputs, compute the best trade and return it.\nexport function useDerivedSwapInfo(): {\n  currencies: { [field in Field]?: Currency }\n  currencyBalances: { [field in Field]?: CurrencyAmount<Currency> }\n  parsedAmount: CurrencyAmount<Currency> | undefined\n  v2Trade: Trade<Currency, Currency, TradeType> | undefined\n  inputError?: string\n} {\n  const { account } = useActiveWeb3React()\n\n  const {\n    independentField,\n    typedValue,\n    [Field.INPUT]: { currencyId: inputCurrencyId },\n    [Field.OUTPUT]: { currencyId: outputCurrencyId },\n    recipient,\n  } = useSwapState()\n\n  const inputCurrency = useCurrency(inputCurrencyId)\n  const outputCurrency = useCurrency(outputCurrencyId)\n  const recipientLookup = useENS(recipient ?? undefined)\n  const to: string | null = (recipient === null ? account : recipientLookup.address) ?? null\n\n  const relevantTokenBalances = useCurrencyBalances(\n    account ?? undefined,\n    useMemo(() => [inputCurrency ?? undefined, outputCurrency ?? undefined], [inputCurrency, outputCurrency]),\n  )\n\n  const isExactIn = useMemo(() => independentField === Field.INPUT, [independentField])\n  const parsedAmount = useMemo(\n    () => tryParseAmount(typedValue, (isExactIn ? inputCurrency : outputCurrency) ?? undefined),\n    [inputCurrency, isExactIn, outputCurrency, typedValue],\n  )\n\n  const currencyAmountIn = useMemo(() => (isExactIn ? parsedAmount : undefined), [isExactIn, parsedAmount])\n  const currencyOut = useMemo(() => outputCurrency ?? undefined, [outputCurrency])\n  const bestTradeExactIn = useTradeExactIn(currencyAmountIn, currencyOut)\n\n  const v2Trade = bestTradeExactIn\n\n  const currencyBalances = {\n    [Field.INPUT]: relevantTokenBalances[0],\n    [Field.OUTPUT]: relevantTokenBalances[1],\n  }\n\n  const currencies: { [field in Field]?: Currency } = useMemo(() => {\n    return {\n      [Field.INPUT]: inputCurrency ?? undefined,\n      [Field.OUTPUT]: outputCurrency ?? undefined,\n    }\n  }, [inputCurrency, outputCurrency])\n\n  let inputError: string | undefined\n  if (!account) {\n    inputError = t`Connect wallet`\n  }\n\n  if (!parsedAmount) {\n    if (typedValue) inputError = inputError ?? t`Invalid amount`\n    else inputError = inputError ?? t`Enter an amount`\n  }\n\n  if (!currencies[Field.INPUT] || !currencies[Field.OUTPUT]) {\n    inputError = inputError ?? t`Select a token`\n  }\n\n  const formattedTo = isAddress(to)\n  if (!to || !formattedTo) {\n    inputError = inputError ?? t`Enter a recipient`\n  } else {\n    if (\n      BAD_RECIPIENT_ADDRESSES.indexOf(formattedTo) !== -1 ||\n      (bestTradeExactIn && involvesAddress(bestTradeExactIn, formattedTo))\n    ) {\n      inputError = inputError ?? t`Invalid recipient`\n    }\n  }\n\n  const [allowedSlippage] = useUserSlippageTolerance()\n\n  const slippageAdjustedAmounts = v2Trade && allowedSlippage && computeSlippageAdjustedAmounts(v2Trade, allowedSlippage)\n\n  // compare input balance to max input based on version\n  const [balanceIn, amountIn] = [\n    currencyBalances[Field.INPUT],\n    slippageAdjustedAmounts ? slippageAdjustedAmounts[Field.INPUT] : null,\n  ]\n\n  if (balanceIn && amountIn && balanceIn.lessThan(amountIn)) {\n    inputError = t`Insufficient ${amountIn.currency.symbol} balance`\n  }\n\n  return {\n    currencies,\n    currencyBalances,\n    parsedAmount,\n    v2Trade: v2Trade ?? undefined,\n    inputError,\n  }\n}\n\nfunction parseCurrencyFromURLParameter(urlParam: any, chainId: ChainId): string {\n  if (typeof urlParam === 'string') {\n    const valid = isAddress(urlParam)\n    if (valid) return valid\n    return nativeOnChain(chainId).symbol as string\n  }\n  return nativeOnChain(chainId).symbol ?? ''\n}\n\nfunction parseTokenAmountURLParameter(urlParam: any): string {\n  return typeof urlParam === 'string' && !isNaN(parseFloat(urlParam)) ? urlParam : ''\n}\n\nfunction parseIndependentFieldURLParameter(urlParam: any): Field {\n  return typeof urlParam === 'string' && urlParam.toLowerCase() === 'output' ? Field.OUTPUT : Field.INPUT\n}\n\nconst ENS_NAME_REGEX = /^[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)?$/\nconst ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/\nfunction validatedRecipient(recipient: any): string | null {\n  if (typeof recipient !== 'string') return null\n  const address = isAddress(recipient)\n  if (address) return address\n  if (ENS_NAME_REGEX.test(recipient)) return recipient\n  if (ADDRESS_REGEX.test(recipient)) return recipient\n  return null\n}\n\nexport function queryParametersToSwapState(parsedQs: ParsedQs, chainId: ChainId): Omit<SwapState, 'saveGas'> {\n  let inputCurrency = parseCurrencyFromURLParameter(parsedQs.inputCurrency, chainId)\n  let outputCurrency = parseCurrencyFromURLParameter(parsedQs.outputCurrency, chainId)\n  if (inputCurrency === outputCurrency) {\n    if (typeof parsedQs.outputCurrency === 'string') {\n      inputCurrency = ''\n    } else {\n      outputCurrency = ''\n    }\n  }\n\n  const recipient = validatedRecipient(parsedQs.recipient)\n  const feePercent = parseInt(parsedQs?.['fee_bip']?.toString() || '0')\n  const feeConfig: FeeConfig | undefined =\n    parsedQs.referral && isAddress(parsedQs.referral) && parsedQs['fee_bip'] && !isNaN(feePercent)\n      ? {\n          chargeFeeBy: 'currency_in',\n          feeReceiver: parsedQs.referral.toString(),\n          isInBps: true,\n          feeAmount: feePercent < 1 ? '1' : feePercent > 10 ? '10' : feePercent.toString(),\n        }\n      : undefined\n  return {\n    [Field.INPUT]: {\n      currencyId: inputCurrency,\n    },\n    [Field.OUTPUT]: {\n      currencyId: outputCurrency,\n    },\n    typedValue: parseTokenAmountURLParameter(parsedQs.exactAmount),\n    independentField: parseIndependentFieldURLParameter(parsedQs.exactField),\n    recipient,\n    feeConfig,\n  }\n}\n\nconst getCurrencySymbolOrAddress = (currency: Currency | undefined): string | undefined => {\n  if (!currency) return ''\n  return currency.isNative ? currency.symbol : currency.address\n}\n\n// updates the swap state to use the defaults for a given network\nexport const useDefaultsFromURLSearch = ():\n  | {\n      inputCurrencyId?: string\n      outputCurrencyId?: string\n    }\n  | undefined => {\n  // TODO: this hook is called more than 100 times just on startup, need to check\n\n  const { chainId } = useActiveWeb3React()\n  const dispatch = useDispatch()\n\n  // this is already memo-ed\n  const parsedQs = useParsedQueryString()\n\n  const [result, setResult] = useState<\n    | {\n        inputCurrencyId?: string\n        outputCurrencyId?: string\n      }\n    | undefined\n  >()\n\n  const { currencies } = useDerivedSwapInfo()\n\n  const currenciesRef = useRef(currencies)\n  currenciesRef.current = currencies\n\n  useEffect(() => {\n    if (!chainId) {\n      return\n    }\n\n    const parsed = queryParametersToSwapState(parsedQs, chainId)\n\n    const outputCurrencyAddress = DEFAULT_OUTPUT_TOKEN_BY_CHAIN[chainId]?.address || ''\n\n    // symbol or address of the input\n    const storedInputValue = getCurrencySymbolOrAddress(currenciesRef.current[Field.INPUT])\n    const storedOutputValue = getCurrencySymbolOrAddress(currenciesRef.current[Field.OUTPUT])\n\n    const parsedInputValue = parsed[Field.INPUT].currencyId // default inputCurrency is the native token\n    const parsedOutputValue = parsed[Field.OUTPUT].currencyId || outputCurrencyAddress\n\n    // priority order\n    // 1. address on url (inputCurrency, outputCurrency)\n    // 2. previous currency (to not reset default pair when back to swap page)\n    // 3. default pair\n    const inputCurrencyId = parsedQs.inputCurrency ? parsedInputValue : storedInputValue || parsedInputValue\n    const outputCurrencyId = parsedQs.outputCurrency ? parsedOutputValue : storedOutputValue || parsedOutputValue\n\n    dispatch(\n      replaceSwapState({\n        field: parsed.independentField,\n        inputCurrencyId,\n        outputCurrencyId,\n        recipient: parsed.recipient,\n        feeConfig: parsed.feeConfig,\n      }),\n    )\n\n    setResult({\n      inputCurrencyId,\n      outputCurrencyId,\n    })\n\n    // TODO: can not add `currencies` as dependency here because it will retrigger replaceSwapState => got some issue when we have in/outputCurrency on URL\n  }, [dispatch, chainId, parsedQs])\n\n  return result\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}