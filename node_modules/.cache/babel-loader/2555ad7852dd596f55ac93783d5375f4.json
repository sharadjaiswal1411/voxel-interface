{"ast":null,"code":"import _defineProperty from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _slicedToArray from \"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n\nvar _s = $RefreshSig$();\n\nimport { i18n } from \"@lingui/core\";\nimport JSBI from 'jsbi';\nimport { useMemo } from 'react';\nimport { BAD_RECIPIENT_ADDRESSES } from 'constants/index';\nimport { useActiveWeb3React } from 'hooks';\nimport { useCurrency } from 'hooks/Tokens';\nimport { useTradeExactInV2 } from 'hooks/Trades';\nimport useENS from 'hooks/useENS';\nimport { useCurrencyBalances } from 'state/wallet/hooks';\nimport { isAddress } from 'utils';\nimport { computeSlippageAdjustedAmounts } from 'utils/prices';\nimport { useUserSlippageTolerance } from '../user/hooks';\nimport { Field } from './actions';\nimport { tryParseAmount, useSwapState } from './hooks';\n// from the current swap inputs, compute the best trade and return it.\nexport function useDerivedSwapInfoV2() {\n  _s();\n\n  var _ref;\n\n  var _useActiveWeb3React = useActiveWeb3React(),\n      account = _useActiveWeb3React.account;\n\n  var _useSwapState = useSwapState(),\n      independentField = _useSwapState.independentField,\n      typedValue = _useSwapState.typedValue,\n      inputCurrencyId = _useSwapState[Field.INPUT].currencyId,\n      outputCurrencyId = _useSwapState[Field.OUTPUT].currencyId,\n      recipient = _useSwapState.recipient,\n      saveGas = _useSwapState.saveGas;\n\n  var inputCurrency = useCurrency(inputCurrencyId);\n  var outputCurrency = useCurrency(outputCurrencyId);\n  var recipientLookup = useENS(recipient !== null && recipient !== void 0 ? recipient : undefined);\n  var to = (_ref = recipient === null || recipient === '' ? account : recipientLookup.address) !== null && _ref !== void 0 ? _ref : null;\n  var relevantTokenBalances = useCurrencyBalances(account !== null && account !== void 0 ? account : undefined, useMemo(function () {\n    return [inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined, outputCurrency !== null && outputCurrency !== void 0 ? outputCurrency : undefined];\n  }, [inputCurrency, outputCurrency]));\n  var isExactIn = independentField === Field.INPUT;\n  var currency = isExactIn ? inputCurrency : outputCurrency;\n  var parsedAmount = useMemo(function () {\n    return tryParseAmount(typedValue, currency !== null && currency !== void 0 ? currency : undefined);\n  }, [typedValue, currency]);\n\n  var _useUserSlippageToler = useUserSlippageTolerance(),\n      _useUserSlippageToler2 = _slicedToArray(_useUserSlippageToler, 1),\n      allowedSlippage = _useUserSlippageToler2[0];\n\n  var _useTradeExactInV = useTradeExactInV2(isExactIn ? parsedAmount : undefined, outputCurrency !== null && outputCurrency !== void 0 ? outputCurrency : undefined, saveGas, to, allowedSlippage),\n      bestTradeExactIn = _useTradeExactInV.trade,\n      baseTradeComparer = _useTradeExactInV.comparer,\n      onUpdateCallback = _useTradeExactInV.onUpdateCallback,\n      loading = _useTradeExactInV.loading;\n\n  var tradeComparer = useMemo(function () {\n    var _bestTradeExactIn$out, _baseTradeComparer$ou;\n\n    if (bestTradeExactIn !== null && bestTradeExactIn !== void 0 && (_bestTradeExactIn$out = bestTradeExactIn.outputAmount) !== null && _bestTradeExactIn$out !== void 0 && _bestTradeExactIn$out.greaterThan(JSBI.BigInt(0)) && baseTradeComparer !== null && baseTradeComparer !== void 0 && (_baseTradeComparer$ou = baseTradeComparer.outputAmount) !== null && _baseTradeComparer$ou !== void 0 && _baseTradeComparer$ou.greaterThan(JSBI.BigInt(0)) // && baseTradeComparer?.outputPriceUSD\n    ) {\n      try {\n        var diffAmount = bestTradeExactIn.outputAmount.subtract(baseTradeComparer.outputAmount);\n        var diffAmountUSD = bestTradeExactIn.receivedUsd - parseFloat(baseTradeComparer.receivedUsd);\n\n        if (diffAmount.greaterThan(JSBI.BigInt(0)) && bestTradeExactIn.receivedUsd > 0 && parseFloat(baseTradeComparer.receivedUsd) > 0 && diffAmountUSD > 0) {\n          var savedUsd = diffAmountUSD; // const savedUsd = parseFloat(diffAmount.toFixed()) * parseFloat(baseTradeComparer.outputPriceUSD.toString())\n\n          if (savedUsd) {\n            return Object.assign({}, baseTradeComparer, {\n              tradeSaved: {\n                usd: savedUsd.toString(),\n                percent: savedUsd / bestTradeExactIn.receivedUsd * 100\n              }\n            });\n          }\n        }\n      } catch (e) {}\n    }\n\n    return baseTradeComparer !== null && baseTradeComparer !== void 0 ? baseTradeComparer : undefined;\n  }, [bestTradeExactIn, baseTradeComparer]);\n  var v2Trade = isExactIn ? bestTradeExactIn : undefined;\n  var currencyBalances = useMemo(function () {\n    var _ref2;\n\n    return _ref2 = {}, _defineProperty(_ref2, Field.INPUT, relevantTokenBalances[0]), _defineProperty(_ref2, Field.OUTPUT, relevantTokenBalances[1]), _ref2;\n  }, [relevantTokenBalances]);\n  var currencies = useMemo(function () {\n    var _ref3;\n\n    return _ref3 = {}, _defineProperty(_ref3, Field.INPUT, inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined), _defineProperty(_ref3, Field.OUTPUT, outputCurrency !== null && outputCurrency !== void 0 ? outputCurrency : undefined), _ref3;\n  }, [inputCurrency, outputCurrency]);\n  var inputError;\n\n  if (!account) {\n    inputError =\n    /*i18n*/\n    i18n._(\"Connect wallet\");\n  }\n\n  if (!parsedAmount) {\n    var _inputError, _inputError2;\n\n    if (typedValue) inputError = (_inputError = inputError) !== null && _inputError !== void 0 ? _inputError :\n    /*i18n*/\n    i18n._(\"Invalid amount\");else inputError = (_inputError2 = inputError) !== null && _inputError2 !== void 0 ? _inputError2 :\n    /*i18n*/\n    i18n._(\"Enter an amount\");\n  }\n\n  if (!currencies[Field.INPUT] || !currencies[Field.OUTPUT]) {\n    var _inputError3;\n\n    inputError = (_inputError3 = inputError) !== null && _inputError3 !== void 0 ? _inputError3 :\n    /*i18n*/\n    i18n._(\"Select a token\");\n  }\n\n  var formattedTo = isAddress(to);\n\n  if (!to || !formattedTo) {\n    var _inputError4;\n\n    inputError = (_inputError4 = inputError) !== null && _inputError4 !== void 0 ? _inputError4 :\n    /*i18n*/\n    i18n._(\"Enter a recipient\");\n  } else {\n    if (BAD_RECIPIENT_ADDRESSES.indexOf(formattedTo) !== -1) {\n      var _inputError5;\n\n      inputError = (_inputError5 = inputError) !== null && _inputError5 !== void 0 ? _inputError5 :\n      /*i18n*/\n      i18n._(\"Invalid recipient\");\n    }\n  }\n\n  var slippageAdjustedAmounts = v2Trade && allowedSlippage && computeSlippageAdjustedAmounts(v2Trade, allowedSlippage); // compare input balance to max input based on version\n\n  var _ref4 = [currencyBalances[Field.INPUT], slippageAdjustedAmounts ? slippageAdjustedAmounts[Field.INPUT] : null],\n      balanceIn = _ref4[0],\n      amountIn = _ref4[1];\n\n  if (amountIn && (balanceIn && balanceIn.lessThan(amountIn) || !balanceIn)) {\n    inputError =\n    /*i18n*/\n    i18n._(\"Insufficient {0} balance\", {\n      0: amountIn.currency.symbol\n    });\n  } // inputCurrency/outputCurrency null is loading, undefined is not found, see useToken for detail\n\n\n  var isPairNotfound = inputCurrency === undefined && outputCurrency === undefined;\n  return useMemo(function () {\n    return {\n      currencies: currencies,\n      currencyBalances: currencyBalances,\n      parsedAmount: parsedAmount,\n      v2Trade: v2Trade !== null && v2Trade !== void 0 ? v2Trade : undefined,\n      tradeComparer: tradeComparer,\n      inputError: inputError,\n      onRefresh: onUpdateCallback,\n      loading: loading,\n      isPairNotfound: isPairNotfound\n    };\n  }, [currencies, currencyBalances, inputError, loading, onUpdateCallback, parsedAmount, tradeComparer, v2Trade, isPairNotfound]);\n}\n\n_s(useDerivedSwapInfoV2, \"bxdu+DSPBXUkjwsTyb3Gwa480xM=\", false, function () {\n  return [useActiveWeb3React, useSwapState, useCurrency, useCurrency, useENS, useCurrencyBalances, useUserSlippageTolerance, useTradeExactInV2];\n});","map":{"version":3,"names":["JSBI","useMemo","BAD_RECIPIENT_ADDRESSES","useActiveWeb3React","useCurrency","useTradeExactInV2","useENS","useCurrencyBalances","isAddress","computeSlippageAdjustedAmounts","useUserSlippageTolerance","Field","tryParseAmount","useSwapState","useDerivedSwapInfoV2","account","independentField","typedValue","inputCurrencyId","INPUT","currencyId","outputCurrencyId","OUTPUT","recipient","saveGas","inputCurrency","outputCurrency","recipientLookup","undefined","to","address","relevantTokenBalances","isExactIn","currency","parsedAmount","allowedSlippage","bestTradeExactIn","trade","baseTradeComparer","comparer","onUpdateCallback","loading","tradeComparer","outputAmount","greaterThan","BigInt","diffAmount","subtract","diffAmountUSD","receivedUsd","parseFloat","savedUsd","Object","assign","tradeSaved","usd","toString","percent","e","v2Trade","currencyBalances","currencies","inputError","formattedTo","indexOf","slippageAdjustedAmounts","balanceIn","amountIn","lessThan","symbol","isPairNotfound","onRefresh"],"sources":["/Applications/XAMPP/voxel-interface/src/state/swap/useAggregator.ts"],"sourcesContent":["import { Currency, CurrencyAmount } from '@kyberswap/ks-sdk-core'\nimport { t } from '@lingui/macro'\nimport JSBI from 'jsbi'\nimport { useMemo } from 'react'\n\nimport { BAD_RECIPIENT_ADDRESSES } from 'constants/index'\nimport { useActiveWeb3React } from 'hooks'\nimport { useCurrency } from 'hooks/Tokens'\nimport { useTradeExactInV2 } from 'hooks/Trades'\nimport useENS from 'hooks/useENS'\nimport { useCurrencyBalances } from 'state/wallet/hooks'\nimport { isAddress } from 'utils'\nimport { Aggregator } from 'utils/aggregator'\nimport { computeSlippageAdjustedAmounts } from 'utils/prices'\n\nimport { useUserSlippageTolerance } from '../user/hooks'\nimport { Field } from './actions'\nimport { tryParseAmount, useSwapState } from './hooks'\nimport { AggregationComparer } from './types'\n\n// from the current swap inputs, compute the best trade and return it.\nexport function useDerivedSwapInfoV2(): {\n  currencies: { [field in Field]?: Currency }\n  currencyBalances: { [field in Field]?: CurrencyAmount<Currency> }\n  parsedAmount: CurrencyAmount<Currency> | undefined\n  v2Trade: Aggregator | undefined\n  tradeComparer: AggregationComparer | undefined\n  inputError?: string\n  onRefresh: (resetRoute: boolean, minimumLoadingTime: number) => void\n  loading: boolean\n  isPairNotfound: boolean\n} {\n  const { account } = useActiveWeb3React()\n\n  const {\n    independentField,\n    typedValue,\n    [Field.INPUT]: { currencyId: inputCurrencyId },\n    [Field.OUTPUT]: { currencyId: outputCurrencyId },\n    recipient,\n    saveGas,\n  } = useSwapState()\n\n  const inputCurrency = useCurrency(inputCurrencyId)\n  const outputCurrency = useCurrency(outputCurrencyId)\n  const recipientLookup = useENS(recipient ?? undefined)\n  const to: string | null = (recipient === null || recipient === '' ? account : recipientLookup.address) ?? null\n\n  const relevantTokenBalances = useCurrencyBalances(\n    account ?? undefined,\n    useMemo(() => [inputCurrency ?? undefined, outputCurrency ?? undefined], [inputCurrency, outputCurrency]),\n  )\n\n  const isExactIn: boolean = independentField === Field.INPUT\n\n  const currency = isExactIn ? inputCurrency : outputCurrency\n  const parsedAmount = useMemo(() => {\n    return tryParseAmount(typedValue, currency ?? undefined)\n  }, [typedValue, currency])\n\n  const [allowedSlippage] = useUserSlippageTolerance()\n\n  const {\n    trade: bestTradeExactIn,\n    comparer: baseTradeComparer,\n    onUpdateCallback,\n    loading,\n  } = useTradeExactInV2(isExactIn ? parsedAmount : undefined, outputCurrency ?? undefined, saveGas, to, allowedSlippage)\n\n  const tradeComparer = useMemo((): AggregationComparer | undefined => {\n    if (\n      bestTradeExactIn?.outputAmount?.greaterThan(JSBI.BigInt(0)) &&\n      baseTradeComparer?.outputAmount?.greaterThan(JSBI.BigInt(0))\n      // && baseTradeComparer?.outputPriceUSD\n    ) {\n      try {\n        const diffAmount = bestTradeExactIn.outputAmount.subtract(baseTradeComparer.outputAmount)\n        const diffAmountUSD = bestTradeExactIn.receivedUsd - parseFloat(baseTradeComparer.receivedUsd)\n        if (\n          diffAmount.greaterThan(JSBI.BigInt(0)) &&\n          bestTradeExactIn.receivedUsd > 0 &&\n          parseFloat(baseTradeComparer.receivedUsd) > 0 &&\n          diffAmountUSD > 0\n        ) {\n          const savedUsd = diffAmountUSD\n          // const savedUsd = parseFloat(diffAmount.toFixed()) * parseFloat(baseTradeComparer.outputPriceUSD.toString())\n          if (savedUsd) {\n            return Object.assign({}, baseTradeComparer, {\n              tradeSaved: {\n                usd: savedUsd.toString(),\n                percent: (savedUsd / bestTradeExactIn.receivedUsd) * 100,\n              },\n            })\n          }\n        }\n      } catch (e) {}\n    }\n    return baseTradeComparer ?? undefined\n  }, [bestTradeExactIn, baseTradeComparer])\n\n  const v2Trade = isExactIn ? bestTradeExactIn : undefined\n\n  const currencyBalances = useMemo(() => {\n    return {\n      [Field.INPUT]: relevantTokenBalances[0],\n      [Field.OUTPUT]: relevantTokenBalances[1],\n    }\n  }, [relevantTokenBalances])\n\n  const currencies: { [field in Field]?: Currency } = useMemo(() => {\n    return {\n      [Field.INPUT]: inputCurrency ?? undefined,\n      [Field.OUTPUT]: outputCurrency ?? undefined,\n    }\n  }, [inputCurrency, outputCurrency])\n\n  let inputError: string | undefined\n  if (!account) {\n    inputError = t`Connect wallet`\n  }\n\n  if (!parsedAmount) {\n    if (typedValue) inputError = inputError ?? t`Invalid amount`\n    else inputError = inputError ?? t`Enter an amount`\n  }\n\n  if (!currencies[Field.INPUT] || !currencies[Field.OUTPUT]) {\n    inputError = inputError ?? t`Select a token`\n  }\n\n  const formattedTo = isAddress(to)\n  if (!to || !formattedTo) {\n    inputError = inputError ?? t`Enter a recipient`\n  } else {\n    if (BAD_RECIPIENT_ADDRESSES.indexOf(formattedTo) !== -1) {\n      inputError = inputError ?? t`Invalid recipient`\n    }\n  }\n\n  const slippageAdjustedAmounts = v2Trade && allowedSlippage && computeSlippageAdjustedAmounts(v2Trade, allowedSlippage)\n\n  // compare input balance to max input based on version\n  const [balanceIn, amountIn] = [\n    currencyBalances[Field.INPUT],\n    slippageAdjustedAmounts ? slippageAdjustedAmounts[Field.INPUT] : null,\n  ]\n\n  if (amountIn && ((balanceIn && balanceIn.lessThan(amountIn)) || !balanceIn)) {\n    inputError = t`Insufficient ${amountIn.currency.symbol} balance`\n  }\n\n  // inputCurrency/outputCurrency null is loading, undefined is not found, see useToken for detail\n  const isPairNotfound = inputCurrency === undefined && outputCurrency === undefined\n\n  return useMemo(\n    () => ({\n      currencies,\n      currencyBalances,\n      parsedAmount,\n      v2Trade: v2Trade ?? undefined,\n      tradeComparer,\n      inputError,\n      onRefresh: onUpdateCallback,\n      loading,\n      isPairNotfound,\n    }),\n    [\n      currencies,\n      currencyBalances,\n      inputError,\n      loading,\n      onUpdateCallback,\n      parsedAmount,\n      tradeComparer,\n      v2Trade,\n      isPairNotfound,\n    ],\n  )\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}