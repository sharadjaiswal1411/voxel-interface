{"ast":null,"code":"\"use strict\"; // Copyright (c) 2018-2022 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\n\nvar _classCallCheck = require(\"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/Applications/XAMPP/voxel-interface/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RxWebSocket = exports.ConnectionState = void 0;\n\nvar rxjs_1 = require(\"rxjs\");\n\nvar operators_1 = require(\"rxjs/operators\");\n\nvar ConnectionState;\n\n(function (ConnectionState) {\n  ConnectionState[ConnectionState[\"DISCONNECTED\"] = 0] = \"DISCONNECTED\";\n  ConnectionState[ConnectionState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n  ConnectionState[ConnectionState[\"CONNECTED\"] = 2] = \"CONNECTED\";\n})(ConnectionState = exports.ConnectionState || (exports.ConnectionState = {}));\n/**\n * Rx-ified WebSocket\n */\n\n\nvar RxWebSocket = /*#__PURE__*/function () {\n  /**\n   * Constructor\n   * @param url WebSocket server URL\n   * @param [WebSocketClass] Custom WebSocket implementation\n   */\n  function RxWebSocket(url) {\n    var WebSocketClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : WebSocket;\n\n    _classCallCheck(this, RxWebSocket);\n\n    this.WebSocketClass = WebSocketClass;\n    this.webSocket = null;\n    this.connectionStateSubject = new rxjs_1.BehaviorSubject(ConnectionState.DISCONNECTED);\n    this.incomingDataSubject = new rxjs_1.Subject();\n    this.url = url.replace(/^http/, \"ws\");\n  }\n  /**\n   * Make a websocket connection\n   * @returns an Observable that completes when connected\n   */\n\n\n  _createClass(RxWebSocket, [{\n    key: \"connect\",\n    value: function connect() {\n      var _this = this;\n\n      if (this.webSocket) {\n        return (0, rxjs_1.throwError)(new Error(\"webSocket object is not null\"));\n      }\n\n      return new rxjs_1.Observable(function (obs) {\n        var webSocket;\n\n        try {\n          _this.webSocket = webSocket = new _this.WebSocketClass(_this.url);\n        } catch (err) {\n          obs.error(err);\n          return;\n        }\n\n        _this.connectionStateSubject.next(ConnectionState.CONNECTING);\n\n        webSocket.onclose = function (evt) {\n          _this.clearWebSocket();\n\n          obs.error(new Error(\"websocket error \".concat(evt.code, \": \").concat(evt.reason)));\n\n          _this.connectionStateSubject.next(ConnectionState.DISCONNECTED);\n        };\n\n        webSocket.onopen = function (_) {\n          obs.next();\n          obs.complete();\n\n          _this.connectionStateSubject.next(ConnectionState.CONNECTED);\n        };\n\n        webSocket.onmessage = function (evt) {\n          _this.incomingDataSubject.next(evt.data);\n        };\n      }).pipe((0, operators_1.take)(1));\n    }\n    /**\n     * Disconnect from server\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      var webSocket = this.webSocket;\n\n      if (!webSocket) {\n        return;\n      }\n\n      this.clearWebSocket();\n      this.connectionStateSubject.next(ConnectionState.DISCONNECTED);\n\n      try {\n        webSocket.close();\n      } catch (_a) {}\n    }\n    /**\n     * Emit current connection state and subsequent changes\n     * @returns an Observable for the connection state\n     */\n\n  }, {\n    key: \"connectionState$\",\n    get: function get() {\n      return this.connectionStateSubject.asObservable();\n    }\n    /**\n     * Emit incoming data from server\n     * @returns an Observable for the data received\n     */\n\n  }, {\n    key: \"incomingData$\",\n    get: function get() {\n      return this.incomingDataSubject.asObservable();\n    }\n    /**\n     * Emit incoming JSON data from server. non-JSON data are ignored\n     * @returns an Observable for parsed JSON data\n     */\n\n  }, {\n    key: \"incomingJSONData$\",\n    get: function get() {\n      return this.incomingData$.pipe((0, operators_1.flatMap)(function (m) {\n        var j;\n\n        try {\n          j = JSON.parse(m);\n        } catch (err) {\n          return (0, rxjs_1.empty)();\n        }\n\n        return (0, rxjs_1.of)(j);\n      }));\n    }\n    /**\n     * Send data to server\n     * @param data text to send\n     */\n\n  }, {\n    key: \"sendData\",\n    value: function sendData(data) {\n      var webSocket = this.webSocket;\n\n      if (!webSocket) {\n        throw new Error(\"websocket is not connected\");\n      }\n\n      webSocket.send(data);\n    }\n  }, {\n    key: \"clearWebSocket\",\n    value: function clearWebSocket() {\n      var webSocket = this.webSocket;\n\n      if (!webSocket) {\n        return;\n      }\n\n      this.webSocket = null;\n      webSocket.onclose = null;\n      webSocket.onerror = null;\n      webSocket.onmessage = null;\n      webSocket.onopen = null;\n    }\n  }]);\n\n  return RxWebSocket;\n}();\n\nexports.RxWebSocket = RxWebSocket;","map":null,"metadata":{},"sourceType":"script"}