{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethUtil = require(\"ethereumjs-util\");\n\nvar _ = require(\"lodash\");\n\nvar constants_1 = require(\"../utils/constants\");\n\nvar queue_1 = require(\"../utils/queue\");\n\nvar RawCalldata =\n/** @class */\nfunction () {\n  function RawCalldata(value, hasSelector) {\n    if (hasSelector === void 0) {\n      hasSelector = true;\n    } // Sanity check\n\n\n    if (typeof value === 'string' && !_.startsWith(value, '0x')) {\n      throw new Error(\"Expected raw calldata to start with '0x'\");\n    } // Construct initial values\n\n\n    this._value = ethUtil.toBuffer(value);\n    this._selector = '0x';\n    this._scopes = new queue_1.Queue();\n\n    this._scopes.pushBack(RawCalldata._INITIAL_OFFSET);\n\n    this._offset = RawCalldata._INITIAL_OFFSET; // If there's a selector then slice it\n\n    if (hasSelector) {\n      var selectorBuf = this._value.slice(constants_1.constants.HEX_SELECTOR_LENGTH_IN_BYTES);\n\n      this._value = this._value.slice(constants_1.constants.HEX_SELECTOR_LENGTH_IN_BYTES);\n      this._selector = ethUtil.bufferToHex(selectorBuf);\n    }\n  }\n\n  RawCalldata.prototype.popBytes = function (lengthInBytes) {\n    var popBegin = this._offset;\n    var popEnd = popBegin + lengthInBytes;\n\n    if (popEnd > this._value.byteLength) {\n      throw new Error(\"Tried to decode beyond the end of calldata\");\n    }\n\n    var value = this._value.slice(popBegin, popEnd);\n\n    this.setOffset(popEnd);\n    return value;\n  };\n\n  RawCalldata.prototype.popWord = function () {\n    var wordInBytes = 32;\n    return this.popBytes(wordInBytes);\n  };\n\n  RawCalldata.prototype.popWords = function (length) {\n    var wordInBytes = 32;\n    return this.popBytes(length * wordInBytes);\n  };\n\n  RawCalldata.prototype.readBytes = function (from, to) {\n    var value = this._value.slice(from, to);\n\n    return value;\n  };\n\n  RawCalldata.prototype.setOffset = function (offsetInBytes) {\n    this._offset = offsetInBytes;\n  };\n\n  RawCalldata.prototype.startScope = function () {\n    this._scopes.pushFront(this._offset);\n  };\n\n  RawCalldata.prototype.endScope = function () {\n    this._scopes.popFront();\n  };\n\n  RawCalldata.prototype.getOffset = function () {\n    return this._offset;\n  };\n\n  RawCalldata.prototype.toAbsoluteOffset = function (relativeOffset) {\n    var scopeOffset = this._scopes.peekFront();\n\n    if (scopeOffset === undefined) {\n      throw new Error(\"Tried to access undefined scope.\");\n    }\n\n    var absoluteOffset = relativeOffset + scopeOffset;\n    return absoluteOffset;\n  };\n\n  RawCalldata.prototype.getSelector = function () {\n    return this._selector;\n  };\n\n  RawCalldata.prototype.getSizeInBytes = function () {\n    var sizeInBytes = this._value.byteLength;\n    return sizeInBytes;\n  };\n\n  RawCalldata._INITIAL_OFFSET = 0;\n  return RawCalldata;\n}();\n\nexports.RawCalldata = RawCalldata;","map":null,"metadata":{},"sourceType":"script"}